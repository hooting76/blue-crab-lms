# 01. 데이터베이스 설계

> **작성일**: 2025-10-10
> **버전**: 2.1 (명명 규칙 통일 버전)
> **변경사항**: 모든 테이블/컬럼명을 대문자 + 언더스코어 규칙으로 통일

---

## 📊 데이터베이스 설계 개요

강의 관리 시스템의 데이터베이스 설계를 정의합니다. **신규 테이블 2개**로 모든 기능을 구현하는 최소화 설계입니다.

**명명 규칙**: 모든 테이블/컬럼명은 **대문자 + 언더스코어** (예: `USER_TBL`, `LEC_IDX`, `ENROLLMENT_DATA`)

---

## 📋 목차

1. [ERD 다이어그램](#1-erd-다이어그램)
2. [테이블 스키마](#2-테이블-스키마)
3. [제약조건 및 인덱스](#3-제약조건-및-인덱스)
4. [데이터 마이그레이션](#4-데이터-마이그레이션)

---

## 1. ERD 다이어그램

### **최소화 테이블 관계**

```
┌─────────────────────┐       ┌─────────────────────┐
│     USER_TBL        │       │      LEC_TBL        │
│  (기존 + 평가 확장) │       │   (기존 + 확장)     │
├─────────────────────┤       ├─────────────────────┤
│🔑 USER_IDX (INT)    │───┐   │🔑 LEC_IDX (INT)     │───┐
│  USER_ID (VARCHAR)  │   │   │  LEC_SERIAL (VARCHAR)│   │
│  USER_NAME (VARCHAR)│   │   │  LEC_TIT (VARCHAR)  │   │
│  USER_STUDENT (0/1) │   │   │  LEC_PROF (VARCHAR) │   │
│  LECTURE_EVALUATIONS│   │   │  LEC_CURRENT (INT)  │   │
│  (LONGTEXT)         │   │   │  LEC_YEAR (INT)     │   │
└─────────────────────┘   │   │  LEC_SEMESTER (INT) │   │
                          │   │  ... (확장 필드)    │   │
                          │   └─────────────────────┘   │
                          │                             │
                          ├─────────────────────────────┼─────────────────────────────┐
                          │                             │                             │
                          ▼                             ▼                             ▼
                ┌─────────────────────┐       ┌─────────────────────┐       ┌─────────────────────┐
                │ENROLLMENT_EXTENDED  │       │ASSIGNMENT_EXTENDED  │       │     BOARD_TBL       │
                │_TBL (신규)          │       │_TBL (신규)          │       │  (기존 + 확장)      │
                ├─────────────────────┤       ├─────────────────────┤       ├─────────────────────┤
                │🔑 ENROLLMENT_IDX    │       │🔑 ASSIGNMENT_IDX    │       │🔑 BOARD_IDX         │
                │🔗 LEC_IDX           │       │🔗 LEC_IDX           │       │  BOARD_CODE (확장)  │
                │🔗 STUDENT_IDX       │       │  ASSIGNMENT_DATA    │       │  ...                 │
                │  ENROLLMENT_DATA    │       │  (LONGTEXT)         │       │                      │
                │  (LONGTEXT)         │       └─────────────────────┘       └─────────────────────┘
                └─────────────────────┘
```

### **관계 설명**

#### **1. USER_TBL ↔ LEC_TBL (교수 연결)**
- **교수 → 강의**: 한 교수가 여러 강의 담당
- **연결 방식**: `LEC_TBL.LEC_PROF_IDX` → `USER_TBL.USER_IDX`
- **조건**: `USER_TBL.USER_STUDENT = 1` (교수인 경우)

#### **2. USER_TBL ↔ ENROLLMENT_EXTENDED_TBL (학생 수강)**
- **학생 → 수강**: 한 학생이 여러 강의 수강
- **연결 방식**: `ENROLLMENT_EXTENDED_TBL.STUDENT_IDX` → `USER_TBL.USER_IDX`
- **조건**: `USER_TBL.USER_STUDENT = 0` (학생인 경우)

#### **3. LEC_TBL ↔ ENROLLMENT_EXTENDED_TBL (강의 수강)**
- **강의 → 수강**: 한 강의에 여러 학생 수강
- **연결 방식**: `ENROLLMENT_EXTENDED_TBL.LEC_IDX` → `LEC_TBL.LEC_IDX`

#### **4. LEC_TBL ↔ ASSIGNMENT_EXTENDED_TBL (강의 과제)**
- **강의 → 과제**: 한 강의에 여러 과제
- **연결 방식**: `ASSIGNMENT_EXTENDED_TBL.LEC_IDX` → `LEC_TBL.LEC_IDX`

#### **5. USER_TBL ↔ BOARD_TBL (강의별 게시판)**
- **강의별 공지사항**: BOARD_CODE 확장으로 강의별 게시판 구현
- **연결 방식**: `BOARD_TBL.BOARD_CODE`에 강의 IDX 저장
                          └─────────────────────────────┼────────────┘
                                    교수가 강의 담당     │
                                  (LEC_PROF = userName) │
                                                        │
                          ┌─────────────────────────────┘
                          │    학생이 강의 수강
                          │  (userStudent = 0)
                          ▼
```

### **관계 설명**

#### **1. USER_TBL ↔ LEC_TBL (1:N)**
- **교수 → 강의**: 한 교수가 여러 강의 담당
- **연결 방식**: `USER_TBL.userName` = `LEC_TBL.LEC_PROF` (문자열 매칭)
- **조건**: `USER_TBL.userStudent = 1` (교수인 경우)

#### **2. USER_TBL ↔ ENROLLMENT_TBL (1:N)**  
- **학생 → 수강신청**: 한 학생이 여러 강의 수강
- **연결 방식**: `USER_TBL.userIdx` → `ENROLLMENT_TBL.USER_IDX` (FK)
- **조건**: `USER_TBL.userStudent = 0` (학생인 경우)

#### **3. LEC_TBL ↔ ENROLLMENT_TBL (1:N)**
- **강의 → 수강신청**: 한 강의에 여러 학생 수강
- **연결 방식**: `LEC_TBL.LEC_IDX` → `ENROLLMENT_TBL.LEC_IDX` (FK)

### **간단한 관계도 (가장 직관적)**

```
🎯 핵심 관계만 표시

[사용자] ─── 1:N ─── [강의] ─── 1:N ─── [수강관리]
    │                       │
    │                       │
    └── 1:N ────────────────┼── 1:N ─── [과제관리]
    │                       │
    └── 1:N ────────────────┴── 1:N ─── [게시판]

📋 관계 설명:
• 교수 1명 → 강의 N개 (담당)
• 학생 1명 → 수강신청 N개
• 강의 1개 → 수강생 N명
• 강의 1개 → 과제 N개
• 사용자 1명 → 게시글 N개
```

### **추천: Draw.io로 직접 그리기**

화살표가 복잡하다면 **Draw.io**를 사용해보세요:

1. **접속**: https://app.diagrams.net/
2. **Entity Relationship 선택**
3. **직접 그리면 더 명확해집니다**

### **또는 PowerPoint/Excel로 간단히 그리기**

```
┌─────┐     ┌─────┐     ┌─────┐
│사용자│────▶│강의  │────▶│수강  │
│     │     │     │     │관리  │
└─────┘     └─────┘     └─────┘
                │
                ▼
           ┌─────┐
           │과제  │
           │관리  │
           └─────┘
```
        int LEC_POINT "이수학점"
        tinyint LEC_MAJOR "전공(1)/교양(0)"
        tinyint LEC_MUST "필수(1)/선택(0)"
        text LEC_SUMMARY "강의 개요"
        varchar LEC_TIME "강의 시간"
        tinyint LEC_ASSIGN "과제 여부"
        tinyint LEC_OPEN "수강신청 상태"
        int LEC_MANY "최대 수강인원"
        varchar LEC_MCODE "학부 코드"
        varchar LEC_MCODE_DEP "학과 코드"
        int LEC_MIN "최소 학년"
        varchar LEC_REG "등록일"
        varchar LEC_IP "등록 IP"
    }

    ENROLLMENT_TBL {
        bigint ENROLLMENT_ID PK "수강신청 고유번호"
        int USER_IDX FK "학생 IDX"
        int LEC_IDX FK "강의 IDX"
        varchar STATUS "수강 상태"
        datetime ENROLLMENT_DATE "수강신청일"
        datetime CREATED_AT "생성일"
        datetime UPDATED_AT "수정일"
    }

    ATTENDANCE_TBL {
        bigint ATTENDANCE_ID PK "출결 고유번호"
        bigint ENROLLMENT_ID FK "수강신청 IDX"
        date ATTENDANCE_DATE "출결 날짜"
        varchar STATUS "출결 상태"
        datetime CREATED_AT "생성일"
    }

    GRADE_TBL {
        bigint GRADE_ID PK "성적 고유번호"
        bigint ENROLLMENT_ID FK "수강신청 IDX"
        decimal MIDTERM_SCORE "중간고사"
        decimal FINAL_SCORE "기말고사"
        decimal TOTAL_SCORE "총점"
        varchar GRADE "학점"
        datetime CREATED_AT "생성일"
    }

    ASSIGNMENT_TBL {
        bigint ASSIGNMENT_ID PK "과제 고유번호"
        int LEC_IDX FK "강의 IDX"
        varchar TITLE "과제 제목"
        text DESCRIPTION "과제 설명"
        date DUE_DATE "마감일"
        datetime CREATED_AT "생성일"
    }
```

---

## 2. 테이블 스키마 (최소화 버전)

### **LEC_TBL - 기존 강의 테이블 (확장)**

#### **최종 구현된 구조**
```sql
CREATE TABLE `LEC_TBL` (
    `LEC_IDX` INT(200) NOT NULL AUTO_INCREMENT,
    `LEC_SERIAL` VARCHAR(50) NOT NULL COMMENT '강의 코드',
    `LEC_TIT` VARCHAR(50) NOT NULL COMMENT '강의명칭',
    `LEC_PROF` VARCHAR(50) NOT NULL COMMENT '강의 담당교수',
    `LEC_POINT` INT(10) NOT NULL DEFAULT '0' COMMENT '이수학점',
    `LEC_MAJOR` INT(1) NOT NULL DEFAULT '1' COMMENT '전공 강의: 1/ 그외(교양): 0',
    `LEC_MUST` INT(1) NOT NULL DEFAULT '1' COMMENT '필수과목: 1 / 선택과목: 0',
    `LEC_SUMMARY` TEXT NULL DEFAULT NULL COMMENT '강의 개요 내용',
    `LEC_TIME` VARCHAR(50) NOT NULL COMMENT '강의 시간',
    `LEC_ASSIGN` INT(1) NOT NULL DEFAULT '0' COMMENT '과제있음: 1 / 과제없음: 0',
    `LEC_OPEN` INT(1) NOT NULL DEFAULT '0' COMMENT '강의 열림: 1 / 강의 닫힘: 0 <= 수강신청에 대한 상태값',
    `LEC_MANY` INT(10) NOT NULL DEFAULT '0' COMMENT '수강가능 인원수',
    `LEC_MCODE` VARCHAR(50) NOT NULL COMMENT '학부 코드',
    `LEC_MCODE_DEP` VARCHAR(50) NOT NULL COMMENT '학과 코드',
    `LEC_MIN` INT(10) NOT NULL DEFAULT '0' COMMENT '수강 가능한 최저 학년 제한(학기수로 판별)',
    `LEC_REG` VARCHAR(100) NULL DEFAULT NULL COMMENT '강의 등록일',
    `LEC_IP` VARCHAR(100) NULL DEFAULT NULL,
    `LEC_CURRENT` INT(11) NULL DEFAULT '0' COMMENT '현재 수강 인원',
    `LEC_YEAR` INT(11) NULL DEFAULT NULL COMMENT '대상 학년 (1~4학년)',
    `LEC_SEMESTER` INT(1) NULL DEFAULT NULL COMMENT '학기 (1학기:1, 2학기:2)',
    PRIMARY KEY (`LEC_IDX`) USING BTREE
)
COLLATE='utf8mb3_general_ci'
ENGINE=InnoDB
AUTO_INCREMENT=6;
```

#### **추가된 컬럼 (v2.1)**
- `LEC_CURRENT`: 현재 수강 인원 추적
- `LEC_YEAR`: 대상 학년 (1~4학년)
- `LEC_SEMESTER`: 학기 구분 (1 또는 2)

### **ENROLLMENT_EXTENDED_TBL - 수강관리 통합 테이블 (신규)**

#### **최종 구현된 구조**
```sql
CREATE TABLE `ENROLLMENT_EXTENDED_TBL` (
  `ENROLLMENT_IDX` INT(200) NOT NULL AUTO_INCREMENT COMMENT '수강 고유번호',
  `LEC_IDX` INT(200) NOT NULL COMMENT '강의 IDX (FK)',
  `STUDENT_IDX` INT(200) NOT NULL COMMENT '학생 IDX (FK)',
  `ENROLLMENT_DATA` LONGTEXT NULL DEFAULT NULL COMMENT 'JSON 데이터 (수강/출결/성적)',
  PRIMARY KEY (`ENROLLMENT_IDX`) USING BTREE,
  INDEX `FK_LEC` (`LEC_IDX`) USING BTREE,
  INDEX `FK_STUDENT` (`STUDENT_IDX`) USING BTREE,
  CONSTRAINT `FK_ENROLLMENT_LEC` FOREIGN KEY (`LEC_IDX`) REFERENCES `LEC_TBL` (`LEC_IDX`) ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT `FK_ENROLLMENT_STUDENT` FOREIGN KEY (`STUDENT_IDX`) REFERENCES `USER_TBL` (`USER_IDX`) ON UPDATE CASCADE ON DELETE CASCADE
)
COLLATE='utf8mb3_general_ci'
ENGINE=InnoDB
AUTO_INCREMENT=1;
```

### **ASSIGNMENT_EXTENDED_TBL - 과제관리 통합 테이블 (신규)**

#### **최종 구현된 구조**
```sql
CREATE TABLE `ASSIGNMENT_EXTENDED_TBL` (
  `ASSIGNMENT_IDX` INT(200) NOT NULL AUTO_INCREMENT COMMENT '과제 고유번호',
  `LEC_IDX` INT(200) NOT NULL COMMENT '강의 IDX (FK)',
  `ASSIGNMENT_DATA` LONGTEXT NULL DEFAULT NULL COMMENT 'JSON 데이터 (과제정보/제출목록)',
  PRIMARY KEY (`ASSIGNMENT_IDX`) USING BTREE,
  INDEX `FK_ASSIGNMENT_LEC` (`LEC_IDX`) USING BTREE,
  CONSTRAINT `FK_ASSIGNMENT_LEC` FOREIGN KEY (`LEC_IDX`) REFERENCES `LEC_TBL` (`LEC_IDX`) ON UPDATE CASCADE ON DELETE CASCADE
)
COLLATE='utf8mb3_general_ci'
ENGINE=InnoDB
AUTO_INCREMENT=1;
```

### **USER_TBL 확장 - 강의 평가 기능 추가**

#### **최종 구현 상태**
```sql
-- USER_TBL에 강의 평가 데이터 저장용 컬럼 추가 완료
-- LECTURE_EVALUATIONS (LONGTEXT) 컬럼이 추가되어 JSON 배열로 평가 데이터 저장
```

#### **LECTURE_EVALUATIONS JSON 구조 예시**
```json
[
  {
    "lecIdx": 1,
    "lecTitle": "Spring Boot 기초",
    "evaluationDate": "2025-06-15T10:30:00",
    "ratings": {
      "lectureQuality": 5,
      "professorSkill": 4,
      "contentDifficulty": 3,
      "assignmentAmount": 4,
      "overallSatisfaction": 5
    },
    "comment": "매우 유익한 강의였습니다."
  }
]
```

### **BOARD_TBL 확장 - 강의별 게시판 기능**

#### **BOARD_CODE 확장**
- 기존: 0(학교공지), 1(학사공지), 2(학과공지), 3(교수공지)
- 확장: 1000번대 = 강의별 게시판 (예: 1001 = 강의IDX 1의 게시판)
ALTER TABLE LEC_TBL ADD COLUMN `LEC_ROOM` VARCHAR(50) NULL COMMENT '강의실' AFTER `LEC_TIME`;

-- 교수 참조를 위한 컬럼 추가 (기존 LEC_PROF는 문자열, 새로운 컬럼은 FK)
ALTER TABLE LEC_TBL ADD COLUMN `LEC_PROF_IDX` BIGINT NULL COMMENT '담당 교수 IDX (USER_TBL 참조)' AFTER `LEC_PROF`;

-- 표준 타임스탬프 컬럼 추가
ALTER TABLE LEC_TBL ADD COLUMN `CREATED_AT` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP AFTER `LEC_IP`;
ALTER TABLE LEC_TBL ADD COLUMN `UPDATED_AT` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP AFTER `CREATED_AT`;
```

##### **2단계: 기존 컬럼 수정**
```sql
-- LEC_TIME 컬럼을 새로운 포맷으로 확장
ALTER TABLE LEC_TBL MODIFY COLUMN `LEC_TIME` VARCHAR(100) NOT NULL COMMENT '강의 시간 (요일+교시 반복: 11121314=월1,2,3,4교시)';

-- LEC_OPEN을 더 명확한 상태값으로 변경 (기존 0/1을 문자열로)
ALTER TABLE LEC_TBL ADD COLUMN `LEC_STATUS` VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' COMMENT '강의 상태 (ACTIVE:활성, CANCELLED:폐강, CLOSED:마감)' AFTER `LEC_OPEN`;
```

##### **3단계: 외래키 추가**
```sql
-- 교수 참조 외래키 (USER_TBL의 userStudent=1인 사용자만)
ALTER TABLE LEC_TBL ADD CONSTRAINT fk_lecture_professor 
FOREIGN KEY (LEC_PROF_IDX) REFERENCES USER_TBL(userIdx);
```

##### **4단계: 인덱스 추가**
```sql
-- 성능 최적화를 위한 인덱스
CREATE INDEX idx_lec_prof_idx ON LEC_TBL(LEC_PROF_IDX);
CREATE INDEX idx_lec_year_semester ON LEC_TBL(LEC_YEAR, LEC_SEMESTER);
CREATE INDEX idx_lec_status ON LEC_TBL(LEC_STATUS);
CREATE INDEX idx_lec_mcode ON LEC_TBL(LEC_MCODE, LEC_MCODE_DEP);
```

#### **컬럼 매핑 정보**

| 기존 컬럼 | 새 설계 대응 | 비고 |
|-----------|-------------|------|
| `LEC_IDX` | 그대로 사용 | Primary Key |
| `LEC_SERIAL` | 그대로 사용 | 강의 코드 |
| `LEC_TIT` | 그대로 사용 | 강의명 |
| `LEC_PROF` | 보존 + `LEC_PROF_IDX` 추가 | 문자열 + FK 병행 |
| `LEC_POINT` | 그대로 사용 | 학점 |
| `LEC_MAJOR` | 그대로 사용 | 전공/교양 구분 |
| `LEC_MUST` | 그대로 사용 | 필수/선택 구분 |
| `LEC_SUMMARY` | 그대로 사용 | 강의 개요 |
| `LEC_TIME` | **업데이트 필요** | 새 포맷으로 변경 |
| `LEC_ASSIGN` | 그대로 사용 | 과제 여부 |
| `LEC_OPEN` | 보존 + `LEC_STATUS` 추가 | 상태 관리 개선 |
| `LEC_MANY` | 그대로 사용 | 최대 수강인원 |
| `LEC_MCODE` | 그대로 사용 | 학부 코드 |
| `LEC_MCODE_DEP` | 그대로 사용 | 학과 코드 |
| `LEC_MIN` | 그대로 사용 | 최소 학년 제한 |
| `LEC_REG` | 보존 + `CREATED_AT` 추가 | 표준 타임스탬프 |
| `LEC_IP` | 그대로 사용 | 등록 IP |

#### **데이터 마이그레이션 예시**

```sql
-- 1. 기존 LEC_TIME 데이터를 새 포맷으로 변환
-- 예: "월1,2 수3,4" → "11123334"
UPDATE LEC_TBL SET LEC_TIME = CASE 
    WHEN LEC_TIME LIKE '%월1,2 수3,4%' THEN '11123334'
    WHEN LEC_TIME LIKE '%화2,3 목2%' THEN '22234242'
    -- 추가 변환 규칙...
END;

-- 2. 교수명을 USER_TBL과 매칭하여 LEC_PROF_IDX 설정
UPDATE LEC_TBL l 
JOIN USER_TBL u ON l.LEC_PROF = u.userName 
SET l.LEC_PROF_IDX = u.userIdx 
WHERE u.userStudent = 1;

-- 3. LEC_OPEN 값을 LEC_STATUS로 변환
UPDATE LEC_TBL SET LEC_STATUS = CASE 
    WHEN LEC_OPEN = 1 THEN 'ACTIVE'
    WHEN LEC_OPEN = 0 THEN 'CLOSED'
END;

-- 4. 학년도/학기 기본값 설정
UPDATE LEC_TBL SET 
    LEC_YEAR = 2025,
    LEC_SEMESTER = 1,
    LEC_START_DATE = '2025-03-01',
    LEC_END_DATE = '2025-06-30'
WHERE LEC_YEAR IS NULL;
```

### **ENROLLMENT_TBL - 수강신청 테이블 (신규 생성)**

#### **LEC_TBL과 연동되는 수강신청 테이블**
```sql
CREATE TABLE ENROLLMENT_TBL (
    enrollmentIdx BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '수강신청 고유번호',
    lecIdx INT(200) NOT NULL COMMENT '강의 IDX (LEC_TBL.LEC_IDX 참조)',
    studentIdx BIGINT NOT NULL COMMENT '학생 IDX (USER_TBL.userIdx 참조)',
    status VARCHAR(20) NOT NULL DEFAULT 'ENROLLED' COMMENT '상태 (ENROLLED:수강중, CANCELLED:취소, COMPLETED:완료)',
    enrolledAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '수강신청일',
    cancelledAt DATETIME NULL COMMENT '취소일',
    cancelReason VARCHAR(500) COMMENT '취소 사유',
    createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (lecIdx) REFERENCES LEC_TBL(LEC_IDX),
    FOREIGN KEY (studentIdx) REFERENCES USER_TBL(userIdx),
    UNIQUE KEY uk_enrollment (lecIdx, studentIdx)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### **ATTENDANCE_TBL - 출결 테이블**

```sql
CREATE TABLE ATTENDANCE_TBL (
    attendanceIdx BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '출결 고유번호',
    enrollmentIdx BIGINT NOT NULL COMMENT '수강신청 IDX',
    attendanceDate DATE NOT NULL COMMENT '출결 날짜',
    status VARCHAR(20) NOT NULL DEFAULT 'ABSENT' COMMENT '출결 상태 (PRESENT:출석, LATE:지각, ABSENT:결석, EXCUSED:공결)',
    requestReason VARCHAR(500) COMMENT '사유신청 내용',
    requestedAt DATETIME NULL COMMENT '사유신청 시간',
    approvalStatus VARCHAR(20) DEFAULT 'PENDING' COMMENT '승인 상태 (PENDING:대기, APPROVED:승인, REJECTED:거부)',
    approvedBy BIGINT NULL COMMENT '승인자 IDX',
    approvedAt DATETIME NULL COMMENT '승인 시간',
    createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (enrollmentIdx) REFERENCES ENROLLMENT_TBL(enrollmentIdx),
    FOREIGN KEY (approvedBy) REFERENCES USER_TBL(userIdx),
    UNIQUE KEY uk_attendance (enrollmentIdx, attendanceDate)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### **GRADE_TBL - 성적 테이블**

```sql
CREATE TABLE GRADE_TBL (
    gradeIdx BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '성적 고유번호',
    enrollmentIdx BIGINT NOT NULL COMMENT '수강신청 IDX',
    midtermScore DECIMAL(5,2) NULL COMMENT '중간고사 점수',
    finalScore DECIMAL(5,2) NULL COMMENT '기말고사 점수',
    assignmentScore DECIMAL(5,2) NULL COMMENT '과제 점수',
    participationScore DECIMAL(5,2) NULL COMMENT '참여도 점수',
    totalScore DECIMAL(5,2) NULL COMMENT '총점',
    grade VARCHAR(2) NULL COMMENT '학점 (A+, A, B+, B, C+, C, D+, D, F)',
    status VARCHAR(20) NOT NULL DEFAULT 'IN_PROGRESS' COMMENT '상태 (IN_PROGRESS:진행중, FINALIZED:확정)',
    gradedAt DATETIME NULL COMMENT '성적 입력일',
    createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (enrollmentIdx) REFERENCES ENROLLMENT_TBL(enrollmentIdx),
    UNIQUE KEY uk_grade (enrollmentIdx)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### **ASSIGNMENT_TBL - 과제 테이블**

```sql
CREATE TABLE ASSIGNMENT_TBL (
    assignmentIdx BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '과제 고유번호',
    lectureIdx BIGINT NOT NULL COMMENT '강의 IDX',
    title VARCHAR(200) NOT NULL COMMENT '과제 제목',
    description TEXT COMMENT '과제 설명',
    dueDate DATE NOT NULL COMMENT '제출 마감일',
    filePath VARCHAR(500) COMMENT '첨부파일 경로',
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' COMMENT '상태 (ACTIVE:활성, DELETED:삭제)',
    createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (lectureIdx) REFERENCES LECTURE_TBL(lectureIdx)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### **ASSIGNMENT_SUBMISSION_TBL - 과제 제출 테이블**

```sql
CREATE TABLE ASSIGNMENT_SUBMISSION_TBL (
    submissionIdx BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '제출 고유번호',
    assignmentIdx BIGINT NOT NULL COMMENT '과제 IDX',
    studentIdx BIGINT NOT NULL COMMENT '학생 IDX',
    content TEXT COMMENT '제출 내용',
    filePath VARCHAR(500) COMMENT '제출 파일 경로',
    score DECIMAL(5,2) NULL COMMENT '점수',
    feedback TEXT COMMENT '피드백',
    submittedAt DATETIME NULL COMMENT '제출 시간',
    gradedAt DATETIME NULL COMMENT '채점 시간',
    createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (assignmentIdx) REFERENCES ASSIGNMENT_TBL(assignmentIdx),
    FOREIGN KEY (studentIdx) REFERENCES USER_TBL(userIdx),
    UNIQUE KEY uk_submission (assignmentIdx, studentIdx)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### **EVALUATION_ITEM_TBL - 평가 항목 테이블**

```sql
CREATE TABLE EVALUATION_ITEM_TBL (
    itemIdx BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '항목 고유번호',
    itemName VARCHAR(200) NOT NULL COMMENT '항목명',
    itemType VARCHAR(50) NOT NULL COMMENT '항목 유형',
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' COMMENT '상태',
    createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### **EVALUATION_TBL - 강의 평가 테이블**

```sql
CREATE TABLE EVALUATION_TBL (
    evaluationIdx BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '평가 고유번호',
    lectureIdx BIGINT NOT NULL COMMENT '강의 IDX',
    studentIdx BIGINT NOT NULL COMMENT '학생 IDX',
    evaluationData JSON NOT NULL COMMENT '평가 데이터 (JSON)',
    status VARCHAR(20) NOT NULL DEFAULT 'IN_PROGRESS' COMMENT '상태',
    evaluatedAt DATETIME NULL COMMENT '평가 완료 시간',
    createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (lectureIdx) REFERENCES LECTURE_TBL(lectureIdx),
    FOREIGN KEY (studentIdx) REFERENCES USER_TBL(userIdx),
    UNIQUE KEY uk_evaluation (lectureIdx, studentIdx)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### **NOTICE_TBL - 공지사항 테이블**

```sql
CREATE TABLE NOTICE_TBL (
    noticeIdx BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '공지 고유번호',
    lectureIdx BIGINT NOT NULL COMMENT '강의 IDX',
    title VARCHAR(200) NOT NULL COMMENT '제목',
    content TEXT NOT NULL COMMENT '내용',
    filePath VARCHAR(500) COMMENT '첨부파일 경로',
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' COMMENT '상태',
    createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (lectureIdx) REFERENCES LECTURE_TBL(lectureIdx)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### **CHAT_ROOM_TBL - 채팅방 테이블**

```sql
CREATE TABLE CHAT_ROOM_TBL (
    roomIdx BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '채팅방 고유번호',
    lectureIdx BIGINT NOT NULL COMMENT '강의 IDX',
    roomName VARCHAR(100) NOT NULL COMMENT '채팅방 이름',
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' COMMENT '상태',
    createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (lectureIdx) REFERENCES LECTURE_TBL(lectureIdx)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### **CHAT_MESSAGE_TBL - 채팅 메시지 테이블**

```sql
CREATE TABLE CHAT_MESSAGE_TBL (
    messageIdx BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '메시지 고유번호',
    roomIdx BIGINT NOT NULL COMMENT '채팅방 IDX',
    senderIdx BIGINT NOT NULL COMMENT '보낸사람 IDX',
    message TEXT NOT NULL COMMENT '메시지 내용',
    messageType VARCHAR(20) NOT NULL DEFAULT 'TEXT' COMMENT '메시지 유형',
    sentAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '보낸 시간',
    createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (roomIdx) REFERENCES CHAT_ROOM_TBL(roomIdx),
    FOREIGN KEY (senderIdx) REFERENCES USER_TBL(userIdx)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### **DEPARTMENT_REQUIREMENT_TBL - 학과 요구사항 테이블**

```sql
CREATE TABLE DEPARTMENT_REQUIREMENT_TBL (
    requirementIdx BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '요구사항 고유번호',
    departmentCode VARCHAR(20) NOT NULL COMMENT '학과 코드',
    lectureIdx BIGINT NOT NULL COMMENT '강의 IDX',
    requirementType VARCHAR(20) NOT NULL COMMENT '요구사항 유형 (REQUIRED:필수, ELECTIVE:선택)',
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' COMMENT '상태',
    createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (lectureIdx) REFERENCES LECTURE_TBL(lectureIdx)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### **WAITLIST_TBL - 대기열 테이블**

```sql
CREATE TABLE WAITLIST_TBL (
    waitlistIdx BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '대기열 고유번호',
    lectureIdx BIGINT NOT NULL COMMENT '강의 IDX',
    studentIdx BIGINT NOT NULL COMMENT '학생 IDX',
    priority INT NOT NULL DEFAULT 1 COMMENT '우선순위',
    requestedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '신청 시간',
    createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (lectureIdx) REFERENCES LECTURE_TBL(lectureIdx),
    FOREIGN KEY (studentIdx) REFERENCES USER_TBL(userIdx),
    UNIQUE KEY uk_waitlist (lectureIdx, studentIdx)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

---

## 3. 제약조건 및 인덱스

### **주요 제약조건**

```sql
-- 수강신청 인원 제한 체크
DELIMITER //
CREATE TRIGGER check_enrollment_limit
BEFORE INSERT ON ENROLLMENT_TBL
FOR EACH ROW
BEGIN
    DECLARE current_count INT;
    SELECT currentStudents INTO current_count
    FROM LECTURE_TBL
    WHERE lectureIdx = NEW.lectureIdx;

    IF current_count >= (SELECT maxStudents FROM LECTURE_TBL WHERE lectureIdx = NEW.lectureIdx) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '강의 정원이 초과되었습니다.';
    END IF;
END//
DELIMITER ;

-- 성적 범위 체크
DELIMITER //
CREATE TRIGGER check_score_range
BEFORE UPDATE ON GRADE_TBL
FOR EACH ROW
BEGIN
    IF NEW.midtermScore > 100 OR NEW.midtermScore < 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '중간고사 점수는 0-100 사이여야 합니다.';
    END IF;
    IF NEW.finalScore > 100 OR NEW.finalScore < 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '기말고사 점수는 0-100 사이여야 합니다.';
    END IF;
    IF NEW.assignmentScore > 100 OR NEW.assignmentScore < 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '과제 점수는 0-100 사이여야 합니다.';
    END IF;
    IF NEW.participationScore > 100 OR NEW.participationScore < 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '참여도 점수는 0-100 사이여야 합니다.';
    END IF;
END//
DELIMITER ;
```

### **인덱스 설계**

```sql
-- 강의 조회 최적화
CREATE INDEX idx_lecture_professor ON LECTURE_TBL(professorIdx);
CREATE INDEX idx_lecture_year_semester ON LECTURE_TBL(year, semester);
CREATE INDEX idx_lecture_status ON LECTURE_TBL(status);

-- 수강신청 조회 최적화
CREATE INDEX idx_enrollment_student ON ENROLLMENT_TBL(studentIdx);
CREATE INDEX idx_enrollment_lecture ON ENROLLMENT_TBL(lectureIdx);
CREATE INDEX idx_enrollment_status ON ENROLLMENT_TBL(status);

-- 출결 조회 최적화
CREATE INDEX idx_attendance_enrollment ON ATTENDANCE_TBL(enrollmentIdx);
CREATE INDEX idx_attendance_date ON ATTENDANCE_TBL(attendanceDate);
CREATE INDEX idx_attendance_status ON ATTENDANCE_TBL(approvalStatus);

-- 성적 조회 최적화
CREATE INDEX idx_grade_enrollment ON GRADE_TBL(enrollmentIdx);
CREATE INDEX idx_grade_status ON GRADE_TBL(status);

-- 과제 조회 최적화
CREATE INDEX idx_assignment_lecture ON ASSIGNMENT_TBL(lectureIdx);
CREATE INDEX idx_assignment_due_date ON ASSIGNMENT_TBL(dueDate);

-- 채팅 성능 최적화
CREATE INDEX idx_chat_message_room ON CHAT_MESSAGE_TBL(roomIdx);
CREATE INDEX idx_chat_message_sent_at ON CHAT_MESSAGE_TBL(sentAt);
```

---

## 4. 데이터 마이그레이션

### **초기 데이터 삽입**

```sql
-- 평가 항목 초기 데이터
INSERT INTO EVALUATION_ITEM_TBL (itemName, itemType, status) VALUES
('강의 내용의 적절성', 'CONTENT', 'ACTIVE'),
('강의 자료의 유용성', 'MATERIAL', 'ACTIVE'),
('강의 진행 속도', 'PACE', 'ACTIVE'),
('교수의 강의 태도', 'ATTITUDE', 'ACTIVE'),
('전반적인 만족도', 'OVERALL', 'ACTIVE');

-- 샘플 강의 데이터 (기존 LEC_TBL 구조에 맞춘 데이터)
-- 먼저 ALTER TABLE로 필요한 컬럼들을 추가한 후 데이터 삽입

INSERT INTO LEC_TBL (
    LEC_SERIAL, LEC_TIT, LEC_PROF, LEC_PROF_IDX, LEC_POINT, LEC_MAJOR, LEC_MUST,
    LEC_SUMMARY, LEC_TIME, LEC_ROOM, LEC_ASSIGN, LEC_OPEN, LEC_STATUS,
    LEC_MANY, LEC_CURRENT, LEC_MCODE, LEC_MCODE_DEP, LEC_MIN,
    LEC_YEAR, LEC_SEMESTER, LEC_START_DATE, LEC_END_DATE
) VALUES
('CS101', '자바 프로그래밍', '김교수', 1, 3, 1, 1, 
 '자바 기초 프로그래밍을 학습합니다.', '11123334', '공학관 101호', 
 1, 1, 'ACTIVE', 30, 0, 'ENGIN', 'COMP', 2, 
 2025, 1, '2025-03-01', '2025-06-30'),

('CS201', '데이터베이스', '이교수', 2, 3, 1, 1, 
 '관계형 데이터베이스 설계와 SQL을 학습합니다.', '22234242', '공학관 201호', 
 1, 1, 'ACTIVE', 25, 0, 'ENGIN', 'COMP', 4, 
 2025, 1, '2025-03-01', '2025-06-30'),

('CS301', '웹 프로그래밍', '박교수', 3, 3, 1, 0, 
 'HTML, CSS, JavaScript를 활용한 웹 개발', '515667', '공학관 301호', 
 1, 1, 'ACTIVE', 20, 0, 'ENGIN', 'COMP', 6, 
 2025, 1, '2025-03-01', '2025-06-30'),

('GE101', '대학 영어', '최교수', 3, 2, 0, 1, 
 '기초 영어 회화 및 작문', '132456', '인문관 101호', 
 0, 1, 'ACTIVE', 40, 0, 'HUMAN', 'ENGL', 0, 
 2025, 1, '2025-03-01', '2025-06-30');

/*
샘플 데이터 설명:
- 자바 프로그래밍: 전공 필수, 월1,2교시 + 수3,4교시, 2학년 이상
- 데이터베이스: 전공 필수, 화2,3교시 + 목2교시, 4학년 이상  
- 웹 프로그래밍: 전공 선택, 금1교시 + 금6,7교시, 6학년 이상
- 대학 영어: 교양 필수, 월3교시 + 화4교시 + 금5,6교시, 전 학년
*/
```

### **전체 마이그레이션 순서**

#### **1단계: 기존 LEC_TBL 업데이트**
```sql
-- 필요한 컬럼들 추가
ALTER TABLE LEC_TBL ADD COLUMN `LEC_CURRENT` INT(10) NOT NULL DEFAULT '0' COMMENT '현재 수강인원' AFTER `LEC_MANY`;
ALTER TABLE LEC_TBL ADD COLUMN `LEC_YEAR` INT(4) NOT NULL DEFAULT '2025' COMMENT '학년도' AFTER `LEC_MIN`;
ALTER TABLE LEC_TBL ADD COLUMN `LEC_SEMESTER` INT(1) NOT NULL DEFAULT '1' COMMENT '학기' AFTER `LEC_YEAR`;
ALTER TABLE LEC_TBL ADD COLUMN `LEC_START_DATE` DATE NULL COMMENT '강의 시작일' AFTER `LEC_SEMESTER`;
ALTER TABLE LEC_TBL ADD COLUMN `LEC_END_DATE` DATE NULL COMMENT '강의 종료일' AFTER `LEC_START_DATE`;
ALTER TABLE LEC_TBL ADD COLUMN `LEC_ROOM` VARCHAR(50) NULL COMMENT '강의실' AFTER `LEC_TIME`;
ALTER TABLE LEC_TBL ADD COLUMN `LEC_PROF_IDX` BIGINT NULL COMMENT '담당 교수 IDX' AFTER `LEC_PROF`;
ALTER TABLE LEC_TBL ADD COLUMN `LEC_STATUS` VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' COMMENT '강의 상태' AFTER `LEC_OPEN`;
ALTER TABLE LEC_TBL ADD COLUMN `CREATED_AT` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP AFTER `LEC_IP`;
ALTER TABLE LEC_TBL ADD COLUMN `UPDATED_AT` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP AFTER `CREATED_AT`;
```

#### **2단계: 관련 테이블 생성**
```sql
-- 수강신청, 출결, 성적, 과제 등 모든 관련 테이블 생성
-- (위에서 정의한 CREATE TABLE 문들 실행)
```

#### **3단계: 외래키 및 인덱스 추가**
```sql
-- 외래키 제약조건 추가
ALTER TABLE LEC_TBL ADD CONSTRAINT fk_lec_professor 
FOREIGN KEY (LEC_PROF_IDX) REFERENCES USER_TBL(userIdx);

-- 성능 최적화 인덱스 추가
CREATE INDEX idx_lec_prof_idx ON LEC_TBL(LEC_PROF_IDX);
CREATE INDEX idx_lec_year_semester ON LEC_TBL(LEC_YEAR, LEC_SEMESTER);
CREATE INDEX idx_lec_status ON LEC_TBL(LEC_STATUS);
```

#### **4단계: 기존 데이터 정리**
```sql
-- 교수명을 USER_TBL과 매칭
UPDATE LEC_TBL l 
JOIN USER_TBL u ON l.LEC_PROF = u.userName 
SET l.LEC_PROF_IDX = u.userIdx 
WHERE u.userStudent = 1;

-- 기본 학년도/학기 설정
UPDATE LEC_TBL SET 
    LEC_YEAR = 2025,
    LEC_SEMESTER = 1,
    LEC_START_DATE = '2025-03-01',
    LEC_END_DATE = '2025-06-30'
WHERE LEC_YEAR = 2025; -- 기본값이 설정된 경우
```
```

### **데이터 마이그레이션 전략**

1. **기존 데이터 백업**
   ```sql
   mysqldump -u username -p database_name > backup.sql
   ```

2. **테이블 생성 및 제약조건 적용**

3. **데이터 이전**
   ```sql
   -- 기존 USER_TBL에서 교수/학생 데이터 분리 로직
   INSERT INTO LECTURE_TBL (lectureName, lectureCode, ...)
   SELECT ... FROM existing_lecture_table;
   ```

4. **데이터 검증**
   ```sql
   -- 데이터 무결성 체크
   SELECT COUNT(*) FROM LECTURE_TBL;
   SELECT COUNT(*) FROM ENROLLMENT_TBL;
   ```

5. **인덱스 생성 및 최적화**

---

## 📅 강의 시간 포맷 정의

### **lectureTime 필드 규칙**

강의 시간은 `요일+교시` 형태로 2자리씩 반복하여 저장합니다.

#### **요일 코드 (평일만)**
- `1`: 월요일 (Monday)
- `2`: 화요일 (Tuesday)  
- `3`: 수요일 (Wednesday)
- `4`: 목요일 (Thursday)
- `5`: 금요일 (Friday)

#### **교시 코드**
**오전 수업 (1~4교시)**
- `1`: 1교시 (09:00-09:50)
- `2`: 2교시 (10:00-10:50)
- `3`: 3교시 (11:00-11:50)
- `4`: 4교시 (12:00-12:50)

**점심시간: 12:50-13:50 (1시간)**

**오후 수업 (5~8교시)**
- `5`: 5교시 (13:50-14:40)
- `6`: 6교시 (14:50-15:40)
- `7`: 7교시 (15:50-16:40)
- `8`: 8교시 (16:50-17:40)

### **저장 예시**

| 강의 시간 | lectureTime 값 | 설명 |
|-----------|----------------|------|
| 월요일 1,2교시 | `1112` | 월(1) + 1교시(1) + 월(1) + 2교시(2) |
| 월요일 1~4교시 | `11121314` | 월1교시 + 월2교시 + 월3교시 + 월4교시 |
| 월1,2교시 + 수3,4교시 | `11123334` | 월1교시 + 월2교시 + 수3교시 + 수4교시 |
| 화2교시 + 목2교시 | `2242` | 화2교시 + 목2교시 |

### **파싱 로직 (예시)**

```javascript
// JavaScript (프론트엔드)
function parseSchedule(lectureTime) {
  const schedule = [];
  
  // 시간표 정의 (교시별 시작/종료 시간)
  const timeSlots = {
    1: '09:00-09:50', 2: '10:00-10:50', 3: '11:00-11:50', 4: '12:00-12:50',
    5: '13:50-14:40', 6: '14:50-15:40', 7: '15:50-16:40', 8: '16:50-17:40'
  };
  
  for (let i = 0; i < lectureTime.length; i += 2) {
    const dayCode = parseInt(lectureTime[i]);
    const periodCode = parseInt(lectureTime[i + 1]);
    
    // 평일만 유효 (1-5)
    if (dayCode < 1 || dayCode > 5) {
      throw new Error(`유효하지 않은 요일 코드: ${dayCode} (1-5만 허용)`);
    }
    
    schedule.push({
      day: dayCode,
      period: periodCode,
      dayName: ['', '월', '화', '수', '목', '금'][dayCode],
      timeSlot: timeSlots[periodCode],
      isAfternoon: periodCode >= 5
    });
  }
  return schedule;
}

// 사용 예시
const schedule = parseSchedule('11125556');
// 결과: [
//   {day: 1, period: 1, dayName: '월', timeSlot: '09:00-09:50', isAfternoon: false},
//   {day: 1, period: 2, dayName: '월', timeSlot: '10:00-10:50', isAfternoon: false},
//   {day: 5, period: 5, dayName: '금', timeSlot: '13:50-14:40', isAfternoon: true},
//   {day: 5, period: 6, dayName: '금', timeSlot: '14:50-15:40', isAfternoon: true}
// ]
```

```java
// Java (백엔드)
public class ScheduleParser {
    private static final String[] DAY_NAMES = {"", "월", "화", "수", "목", "금"}; // 평일만
    
    // 교시별 시간 매핑
    private static final Map<Integer, LocalTime[]> TIME_SLOTS = Map.of(
        1, new LocalTime[]{LocalTime.of(9, 0), LocalTime.of(9, 50)},   // 1교시
        2, new LocalTime[]{LocalTime.of(10, 0), LocalTime.of(10, 50)}, // 2교시
        3, new LocalTime[]{LocalTime.of(11, 0), LocalTime.of(11, 50)}, // 3교시
        4, new LocalTime[]{LocalTime.of(12, 0), LocalTime.of(12, 50)}, // 4교시
        5, new LocalTime[]{LocalTime.of(13, 50), LocalTime.of(14, 40)}, // 5교시 (점심 후)
        6, new LocalTime[]{LocalTime.of(14, 50), LocalTime.of(15, 40)}, // 6교시
        7, new LocalTime[]{LocalTime.of(15, 50), LocalTime.of(16, 40)}, // 7교시
        8, new LocalTime[]{LocalTime.of(16, 50), LocalTime.of(17, 40)}  // 8교시
    );
    
    public static List<TimeSlot> parseSchedule(String lectureTime) {
        List<TimeSlot> schedule = new ArrayList<>();
        
        for (int i = 0; i < lectureTime.length(); i += 2) {
            int day = Character.getNumericValue(lectureTime.charAt(i));
            int period = Character.getNumericValue(lectureTime.charAt(i + 1));
            
            // 평일만 유효 (1-5)
            if (day < 1 || day > 5) {
                throw new IllegalArgumentException("유효하지 않은 요일 코드: " + day + " (1-5만 허용)");
            }
            
            LocalTime[] times = TIME_SLOTS.get(period);
            
            schedule.add(TimeSlot.builder()
                .day(day)
                .period(period)
                .dayName(DAY_NAMES[day])
                .startTime(times[0])
                .endTime(times[1])
                .isAfternoon(period >= 5)
                .build());
        }
        
        return schedule;
    }
    
    // 시간표 충돌 체크
    public static boolean hasConflict(String schedule1, String schedule2) {
        Set<String> timeSlots1 = extractTimeSlots(schedule1);
        Set<String> timeSlots2 = extractTimeSlots(schedule2);
        
        return timeSlots1.stream().anyMatch(timeSlots2::contains);
    }
    
    private static Set<String> extractTimeSlots(String lectureTime) {
        Set<String> slots = new HashSet<>();
        for (int i = 0; i < lectureTime.length(); i += 2) {
            slots.add(lectureTime.substring(i, i + 2));
        }
        return slots;
    }
}
```

### **데이터 검증 규칙**

1. **길이**: 짝수여야 함 (요일+교시 쌍)
2. **요일**: 1-5 범위 (평일만)
3. **교시**: 1-8 범위
4. **중복**: 동일한 요일+교시 조합 중복 불가

```sql
-- 데이터 검증 트리거 예시
DELIMITER //
CREATE TRIGGER validate_lecture_time
BEFORE INSERT ON LEC_TBL
FOR EACH ROW
BEGIN
    DECLARE schedule_length INT;
    DECLARE i INT DEFAULT 1;
    DECLARE day_code CHAR(1);
    DECLARE period_code CHAR(1);
    
    SET schedule_length = CHAR_LENGTH(NEW.LEC_TIME);
    
    -- 짝수 길이 체크
    IF schedule_length % 2 != 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '강의 시간 형식이 올바르지 않습니다. (짝수 길이 필요)';
    END IF;
    
    -- 각 시간대 검증
    WHILE i <= schedule_length DO
        SET day_code = SUBSTRING(NEW.LEC_TIME, i, 1);
        SET period_code = SUBSTRING(NEW.LEC_TIME, i + 1, 1);
        
        -- 요일 검증 (1-5: 평일만)
        IF day_code NOT REGEXP '^[1-5]$' THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '유효하지 않은 요일 코드입니다. (1-5만 허용)';
        END IF;
        
        -- 교시 검증 (1-8)
        IF period_code NOT REGEXP '^[1-8]$' THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '유효하지 않은 교시 코드입니다. (1-8만 허용)';
        END IF;
        
        SET i = i + 2;
    END WHILE;
END//
DELIMITER ;

-- UPDATE 시에도 동일한 검증 적용
DELIMITER //
CREATE TRIGGER validate_lecture_time_update
BEFORE UPDATE ON LEC_TBL
FOR EACH ROW
BEGIN
    DECLARE schedule_length INT;
    DECLARE i INT DEFAULT 1;
    DECLARE day_code CHAR(1);
    DECLARE period_code CHAR(1);
    
    SET schedule_length = CHAR_LENGTH(NEW.LEC_TIME);
    
    IF schedule_length % 2 != 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '강의 시간 형식이 올바르지 않습니다. (짝수 길이 필요)';
    END IF;
    
    WHILE i <= schedule_length DO
        SET day_code = SUBSTRING(NEW.LEC_TIME, i, 1);
        SET period_code = SUBSTRING(NEW.LEC_TIME, i + 1, 1);
        
        IF day_code NOT REGEXP '^[1-5]$' THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '유효하지 않은 요일 코드입니다. (1-5만 허용)';
        END IF;
        
        IF period_code NOT REGEXP '^[1-8]$' THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '유효하지 않은 교시 코드입니다. (1-8만 허용)';
        END IF;
        
        SET i = i + 2;
    END WHILE;
END//
DELIMITER ;
```

---

## 🎯 설계 완료

데이터베이스 설계가 완료되었습니다. 

### **핵심 특징**

1. **평일 전용 스케줄링**: 월요일(1)부터 금요일(5)까지만 지원하여 실제 대학 운영 환경에 최적화
2. **구조화된 시간 형식**: `day+period` 조합으로 강의 시간을 효율적으로 저장 및 파싱
3. **기존 테이블 호환성**: 현재 `LEC_TBL` 구조를 최대한 활용하여 마이그레이션 부담 최소화
4. **충돌 검사 최적화**: 단순한 문자열 매칭으로 빠른 시간표 충돌 검사 가능
5. **데이터 무결성**: 트리거를 통한 강력한 데이터 검증으로 잘못된 시간 형식 방지

### **주요 제약 조건**

- **요일 코드**: 1-5만 허용 (월~금)
- **교시 코드**: 1-8만 허용 (오전 4교시 + 오후 4교시)
- **시간 형식**: 반드시 짝수 길이 문자열
- **점심시간**: 4교시와 5교시 사이에 자동으로 점심시간 반영

이 설계로 강의 시간 관리가 간단하면서도 효율적으로 구현됩니다.