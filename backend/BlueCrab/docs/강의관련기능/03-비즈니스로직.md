# 03. 비즈니스 로직

> **작성일**: 2025-10-10
> **버전**: 2.1 (명명 규칙 통일 버전)
> **변경사항**: 모든 필드명을 대문자 + 언더스코어 규칙으로 통일

---

## 🎯 비즈니스 로직 개요

강의 관리 시스템의 핵심 비즈니스 로직을 정의합니다. 각 기능별로 처리 흐름, 유효성 검증, 예외 처리 등을 상세히 기술합니다.

---

## 📋 목차

1. [수강신청 로직](#1-수강신청-로직)
2. [출결 관리 로직](#2-출결-관리-로직)
3. [성적 관리 로직](#3-성적-관리-로직)
4. [강의 평가 로직](#4-강의-평가-로직)
5. [보결 순위 로직](#5-보결-순위-로직)
6. [휴강 처리 로직](#6-휴강-처리-로직)

---

## 1. 수강신청 로직

### **1.1 수강 가능 강의 조회**

```java
public List<LectureDTO> getAvailableLectures(Student student, int year, int semester) {
    // 1. 기본 조건 필터링
    List<Lecture> lectures = lectureRepository.findByYearAndSemester(year, semester);

    // 2. 수강 가능 강의 필터링
    return lectures.stream()
        .filter(lecture -> isLectureAvailableForStudent(lecture, student))
        .map(this::convertToDTO)
        .collect(Collectors.toList());
}

private boolean isLectureAvailableForStudent(Lecture lecture, Student student) {
    // 정원 체크
    if (lecture.getCurrentStudents() >= lecture.getMaxStudents()) {
        return false;
    }

    // 대상 학부/학과 체크
    if (!isEligibleDepartment(lecture, student)) {
        return false;
    }

    // 대상 학년 체크
    if (!isEligibleGrade(lecture, student)) {
        return false;
    }

    // 필수/교양 체크 (전공별)
    if (!isEligibleRequirement(lecture, student)) {
        return false;
    }

    return true;
}
```

### **1.2 수강신청 처리**

```java
@Transactional
public EnrollmentResult enrollStudent(int lectureIdx, int studentIdx) {
    // 1. 강의 정보 조회 (락 획득)
    Lecture lecture = lectureRepository.findByIdWithLock(lectureIdx);

    // 2. 수강 가능 여부 검증
    validateEnrollmentEligibility(lecture, studentIdx);

    // 3. 정원 체크 및 증가
    if (lecture.getCurrentStudents() >= lecture.getMaxStudents()) {
        // 보결 순위 등록
        return registerWaitlist(lectureIdx, studentIdx);
    }

    // 4. 수강신청 처리
    Enrollment enrollment = createEnrollment(lecture, studentIdx);
    enrollmentRepository.save(enrollment);

    // 5. 현재 수강인원 증가
    lecture.setCurrentStudents(lecture.getCurrentStudents() + 1);
    lectureRepository.save(lecture);

    return EnrollmentResult.success(enrollment);
}
```

### **1.3 수강신청 취소**

```java
@Transactional
public void cancelEnrollment(int enrollmentIdx) {
    // 1. 수강신청 정보 조회
    Enrollment enrollment = enrollmentRepository.findById(enrollmentIdx);

    // 2. 취소 가능 기간 검증
    validateCancellationPeriod(enrollment);

    // 3. 수강신청 삭제
    enrollmentRepository.delete(enrollment);

    // 4. 강의 현재 수강인원 감소
    Lecture lecture = enrollment.getLecture();
    lecture.setCurrentStudents(lecture.getCurrentStudents() - 1);
    lectureRepository.save(lecture);

    // 5. 보결 순위 승계 처리
    processWaitlistPromotion(lecture);
}
```

---

## 2. 출결 관리 로직

### **2.1 출석 요청 처리**

```java
public AttendanceRequestResult requestAttendance(int enrollmentIdx, LocalDate attendanceDate) {
    // 1. 수강신청 정보 검증
    Enrollment enrollment = enrollmentRepository.findById(enrollmentIdx);
    validateEnrollmentStatus(enrollment);

    // 2. 출석 가능 시간대 검증
    validateAttendanceTime(attendanceDate);

    // 3. 이미 출석 요청했는지 체크
    if (hasExistingRequest(enrollmentIdx, attendanceDate)) {
        return AttendanceRequestResult.duplicate();
    }

    // 4. 출석 요청 생성
    Attendance attendance = Attendance.builder()
        .enrollment(enrollment)
        .attendanceDate(attendanceDate)
        .status(AttendanceStatus.REQUESTED)
        .requestedAt(LocalDateTime.now())
        .build();

    attendanceRepository.save(attendance);

    // 5. 교수 알림 발송
    notifyProfessor(attendance);

    return AttendanceRequestResult.success(attendance);
}
```

### **2.2 출석 승인 처리**

```java
@Transactional
public void approveAttendance(int attendanceIdx, int professorIdx) {
    // 1. 출석 정보 조회
    Attendance attendance = attendanceRepository.findById(attendanceIdx);

    // 2. 권한 검증 (담당 교수인지)
    validateProfessorPermission(attendance, professorIdx);

    // 3. 출석 상태 업데이트
    attendance.setStatus(AttendanceStatus.PRESENT);
    attendance.setApprovedAt(LocalDateTime.now());
    attendance.setApprovedBy(professorIdx);

    attendanceRepository.save(attendance);

    // 4. 학생 알림 발송
    notifyStudent(attendance);

    // 5. 출석률 재계산
    updateAttendanceRate(attendance.getEnrollment());
}
```

---

## 3. 성적 관리 로직

### **3.1 성적 입력 검증**

```java
public void validateGradeInput(GradeInput input) {
    // 1. 점수 범위 검증
    validateScoreRange(input.getMidtermScore(), "중간고사");
    validateScoreRange(input.getFinalScore(), "기말고사");
    validateScoreRange(input.getAssignmentScore(), "과제");
    validateScoreRange(input.getParticipationScore(), "참여도");

    // 2. 총점 계산 및 검증
    double totalScore = calculateTotalScore(input);
    validateTotalScore(totalScore);

    // 3. 학점 변환
    String grade = convertScoreToGrade(totalScore);
    input.setGrade(grade);
}

private void validateScoreRange(Double score, String subject) {
    if (score != null && (score < 0 || score > 100)) {
        throw new InvalidScoreException(subject + " 점수는 0-100 사이여야 합니다.");
    }
}
```

### **3.2 성적 저장 및 업데이트**

```java
@Transactional
public void saveGrades(int lectureIdx, List<GradeInput> gradeInputs) {
    // 1. 강의 권한 검증
    validateProfessorLectureAccess(lectureIdx);

    // 2. 각 성적 처리
    for (GradeInput input : gradeInputs) {
        Enrollment enrollment = enrollmentRepository.findByLectureAndStudent(lectureIdx, input.getStudentIdx());

        // 성적 업데이트
        enrollment.setMidtermScore(input.getMidtermScore());
        enrollment.setFinalScore(input.getFinalScore());
        enrollment.setAssignmentScore(input.getAssignmentScore());
        enrollment.setParticipationScore(input.getParticipationScore());
        enrollment.setTotalScore(calculateTotalScore(input));
        enrollment.setGrade(input.getGrade());
        enrollment.setIsEvaluated(true);

        enrollmentRepository.save(enrollment);
    }

    // 3. 강의 평가 상태 업데이트
    updateLectureEvaluationStatus(lectureIdx);
}
```

---

## 4. 강의 평가 로직

### **4.1 평가 항목 동적 관리**

```java
public List<EvaluationItem> getEvaluationItems(int lectureIdx) {
    // 1. 강의별 평가 항목 조회
    List<EvaluationItem> items = evaluationItemRepository.findByLectureIdx(lectureIdx);

    // 2. 기본 항목이 없으면 생성
    if (items.isEmpty()) {
        items = createDefaultEvaluationItems(lectureIdx);
    }

    return items;
}

private List<EvaluationItem> createDefaultEvaluationItems(int lectureIdx) {
    List<EvaluationItem> defaultItems = Arrays.asList(
        EvaluationItem.builder().lectureIdx(lectureIdx).itemName("강의 내용").build(),
        EvaluationItem.builder().lectureIdx(lectureIdx).itemName("강의 방식").build(),
        EvaluationItem.builder().lectureIdx(lectureIdx).itemName("평가 방법").build(),
        EvaluationItem.builder().lectureIdx(lectureIdx).itemName("학습 효과").build(),
        EvaluationItem.builder().lectureIdx(lectureIdx).itemName("전반적 만족도").build()
    );

    return evaluationItemRepository.saveAll(defaultItems);
}
```

### **4.2 평가 제출 및 통계**

```java
@Transactional
public void submitEvaluation(EvaluationSubmission submission) {
    // 1. 평가 가능 기간 검증
    validateEvaluationPeriod(submission.getLectureIdx());

    // 2. 중복 평가 체크
    if (hasAlreadyEvaluated(submission.getLectureIdx(), submission.getStudentIdx())) {
        throw new DuplicateEvaluationException("이미 평가를 완료했습니다.");
    }

    // 3. 평가 저장
    LectureEvaluation evaluation = convertToEntity(submission);
    evaluationRepository.save(evaluation);

    // 4. 평가 통계 업데이트
    updateEvaluationStatistics(submission.getLectureIdx());
}
```

---

## 5. 보결 순위 로직

### **5.1 보결 등록**

```java
@Transactional
public WaitlistResult registerWaitlist(int lectureIdx, int studentIdx) {
    // 1. 정원 초과 확인
    Lecture lecture = lectureRepository.findById(lectureIdx);
    if (lecture.getCurrentStudents() < lecture.getMaxStudents()) {
        throw new InvalidWaitlistException("정원이 초과되지 않았습니다.");
    }

    // 2. 이미 수강신청했는지 체크
    if (enrollmentRepository.existsByLectureAndStudent(lectureIdx, studentIdx)) {
        throw new InvalidWaitlistException("이미 수강신청했습니다.");
    }

    // 3. 보결 순위 계산 및 등록
    int waitlistOrder = getNextWaitlistOrder(lectureIdx);

    Waitlist waitlist = Waitlist.builder()
        .lectureIdx(lectureIdx)
        .studentIdx(studentIdx)
        .waitlistOrder(waitlistOrder)
        .registeredAt(LocalDateTime.now())
        .build();

    waitlistRepository.save(waitlist);

    return WaitlistResult.success(waitlistOrder);
}
```

### **5.2 보결 승계 처리**

```java
@Transactional
public void processWaitlistPromotion(Lecture lecture) {
    // 1. 빈 자리 수 계산
    int availableSlots = lecture.getMaxStudents() - lecture.getCurrentStudents();
    if (availableSlots <= 0) return;

    // 2. 승계 대상 조회
    List<Waitlist> promotableWaitlists = waitlistRepository
        .findByLectureIdxOrderByWaitlistOrder(lecture.getLectureIdx())
        .stream()
        .limit(availableSlots)
        .collect(Collectors.toList());

    // 3. 승계 처리
    for (Waitlist waitlist : promotableWaitlists) {
        // 수강신청 생성
        Enrollment enrollment = createEnrollment(lecture, waitlist.getStudentIdx());
        enrollmentRepository.save(enrollment);

        // 현재 수강인원 증가
        lecture.setCurrentStudents(lecture.getCurrentStudents() + 1);

        // 보결 목록에서 제거
        waitlistRepository.delete(waitlist);

        // 학생 알림
        notifyWaitlistPromotion(enrollment);
    }

    lectureRepository.save(lecture);
}
```

---

## 6. 휴강 처리 로직

### **6.1 휴강 등록 및 스케줄 조정**

```java
@Transactional
public void registerCancellation(int lectureIdx, LocalDate cancellationDate, String reason) {
    // 1. 강의 권한 검증
    validateProfessorLectureAccess(lectureIdx);

    // 2. 휴강 정보 생성
    LectureCancellation cancellation = LectureCancellation.builder()
        .lectureIdx(lectureIdx)
        .cancellationDate(cancellationDate)
        .reason(reason)
        .registeredAt(LocalDateTime.now())
        .build();

    cancellationRepository.save(cancellation);

    // 3. 스케줄 자동 조정
    adjustLectureSchedule(lectureIdx, cancellationDate);
}

private void adjustLectureSchedule(int lectureIdx, LocalDate cancellationDate) {
    Lecture lecture = lectureRepository.findById(lectureIdx);

    // 원래 스케줄에서 휴강일에 해당하는 시간 찾기
    List<LectureSchedule> affectedSchedules = lectureScheduleRepository
        .findByLectureIdxAndDate(lectureIdx, cancellationDate);

    // 각 스케줄에 대해 다음 가능한 시간으로 이동
    for (LectureSchedule schedule : affectedSchedules) {
        LocalDateTime nextAvailableTime = findNextAvailableTime(schedule);
        schedule.setScheduledTime(nextAvailableTime);
        lectureScheduleRepository.save(schedule);
    }

    // 강의 종료일 연장
    extendLectureEndDate(lecture);
}
```

### **6.2 휴강 보강 처리**

```java
public void scheduleMakeupClass(int lectureIdx, LocalDateTime makeupDateTime) {
    // 1. 휴강 정보 조회
    List<LectureCancellation> cancellations = cancellationRepository
        .findUncompensatedByLectureIdx(lectureIdx);

    if (cancellations.isEmpty()) {
        throw new NoCancellationException("보강할 휴강이 없습니다.");
    }

    // 2. 보강 수업 스케줄 생성
    LectureSchedule makeupSchedule = LectureSchedule.builder()
        .lectureIdx(lectureIdx)
        .scheduledTime(makeupDateTime)
        .isMakeupClass(true)
        .build();

    lectureScheduleRepository.save(makeupSchedule);

    // 3. 휴강 보상 처리
    for (LectureCancellation cancellation : cancellations) {
        cancellation.setCompensated(true);
        cancellation.setMakeupScheduleIdx(makeupSchedule.getScheduleIdx());
        cancellationRepository.save(cancellation);
    }
}
```

---

## 🎯 다음 단계

이 비즈니스 로직을 바탕으로 [관리자 플로우](./04-관리자플로우.md)에서 구체적인 사용자 시나리오를 정의합니다.