# 📚 학부/학과 코드 매핑 가이드

**대상**: 프론트엔드  
**작성**: 2025-10-22

---

## 🎯 개요

**백엔드는 코드만 반환하고, 프론트엔드가 코드를 이름으로 변환합니다**

```json
// 백엔드 응답
{
  "lecMcode": "01",       // 학부 코드
  "lecMcodeDep": "03"     // 학과 코드
}

// 프론트엔드에서 변환
{
  "lecMcode": "01",
  "lecMcodeName": "환경학과",      // ← 프론트가 매핑
  "lecMcodeDep": "03",
  "lecMcodeDepName": "컴퓨터공학과"  // ← 프론트가 매핑
}
```

---

## 📊 매핑 테이블

### FACULTY (학부)

| faculty_id | faculty_code | faculty_name |
|-----------|-------------|-------------|
| 1 | 01 | 환경학과 |
| 1 | 02 | 화학경영학 |
| 1 | 03 | 해군사관 |
| 1 | 04 | 도선학과 |
| 1 | 05 | 해양수산학 |
| 1 | 06 | 조선학과 |
| 2 | 01 | 간호학 |
| 2 | 02 | 자학생 |
| 2 | 03 | 약학과 |
| 2 | 04 | 보건정화학 |
| 3 | 01 | 물리학 |
| 3 | 02 | 수학 |
| 3 | 03 | 물자화학 |
| 4 | 01 | 철학 |
| 4 | 02 | 국어국문 |
| 4 | 03 | 역사학 |
| 4 | 04 | 경영 |
| 4 | 05 | 경제 |
| 4 | 06 | 정치외교 |
| 4 | 07 | 영어영문 |
| 5 | 01 | 컴퓨터공학과 |
| 5 | 02 | 기계공학 |
| 5 | 03 | 전자공학 |
| 5 | 04 | ICT융합 |

### DEPARTMENT (학과)

**⚠️ 중요**: 같은 `dept_code`라도 `faculty_id`가 다르면 다른 학과!

**학부별 학과 구조**:
- Faculty 1 (환경학부): 01, 02, 03, 04, 05, 06
- Faculty 2 (간호학부): 01, 02, 03, 04
- Faculty 3 (물리학부): 01, 02, 03
- Faculty 4 (철학부): 01, 02, 03, 04, 05, 06, 07
- Faculty 5 (공학부): 01, 02, 03, 04

---

## 💻 프론트엔드 구현 예시

### 방법 1: 간단한 객체 매핑

```javascript
// constants/facultyMapping.js
export const FACULTY_MAP = {
  '1': { code: '01', name: '환경학부', depts: {
    '01': '환경학과',
    '02': '화학경영학',
    '03': '해군사관',
    '04': '도선학과',
    '05': '해양수산학',
    '06': '조선학과'
  }},
  '2': { code: '01', name: '간호학부', depts: {
    '01': '간호학',
    '02': '자학생',
    '03': '약학과',
    '04': '보건정화학'
  }},
  '3': { code: '01', name: '물리학부', depts: {
    '01': '물리학',
    '02': '수학',
    '03': '물자화학'
  }},
  '4': { code: '01', name: '철학부', depts: {
    '01': '철학',
    '02': '국어국문',
    '03': '역사학',
    '04': '경영',
    '05': '경제',
    '06': '정치외교',
    '07': '영어영문'
  }},
  '5': { code: '01', name: '공학부', depts: {
    '01': '컴퓨터공학과',
    '02': '기계공학',
    '03': '전자공학',
    '04': 'ICT융합'
  }}
};

// lecMcode와 lecMcodeDep로 이름 찾기
export function getFacultyName(facultyId) {
  return FACULTY_MAP[facultyId]?.name || null;
}

export function getDeptName(facultyId, deptCode) {
  return FACULTY_MAP[facultyId]?.depts[deptCode] || null;
}
```

### 방법 2: API 응답 변환

```javascript
// services/lectureService.js
import { getFacultyName, getDeptName } from '@/constants/facultyMapping';

export async function getEligibleLectures(studentId, page = 0, size = 10) {
  const response = await fetch('/api/lectures/eligible', {
    method: 'POST',
    headers: { 
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ studentId, page, size })
  });
  
  const data = await response.json();
  
  // 학부/학과명 추가
  data.eligibleLectures = data.eligibleLectures.map(lecture => ({
    ...lecture,
    lecMcodeName: getFacultyName(lecture.lecMcode),
    lecMcodeDepName: getDeptName(lecture.lecMcode, lecture.lecMcodeDep)
  }));
  
  return data;
}
```

### 방법 3: 컴포넌트에서 직접 변환

```jsx
// components/LectureList.jsx
import { FACULTY_MAP } from '@/constants/facultyMapping';

function LectureItem({ lecture }) {
  const facultyName = FACULTY_MAP[lecture.lecMcode]?.name;
  const deptName = FACULTY_MAP[lecture.lecMcode]?.depts[lecture.lecMcodeDep];
  
  return (
    <div>
      <h3>{lecture.lecTit}</h3>
      <p>학부: {facultyName || lecture.lecMcode}</p>
      <p>학과: {deptName || lecture.lecMcodeDep}</p>
    </div>
  );
}
```

---

## 🔍 실제 사용 예시

### API 응답 (백엔드)

```json
{
  "eligibleLectures": [
    {
      "lecSerial": "CS101",
      "lecTit": "자료구조",
      "lecMcode": "5",      // 공학부
      "lecMcodeDep": "01"   // 컴퓨터공학과
    },
    {
      "lecSerial": "PHIL201",
      "lecTit": "윤리학",
      "lecMcode": "4",      // 철학부
      "lecMcodeDep": "01"   // 철학과
    }
  ]
}
```

### 프론트엔드 변환 후

```javascript
const lectures = data.eligibleLectures.map(lecture => ({
  ...lecture,
  lecMcodeName: getFacultyName(lecture.lecMcode),
  lecMcodeDepName: getDeptName(lecture.lecMcode, lecture.lecMcodeDep)
}));

console.log(lectures);
// [
//   {
//     "lecSerial": "CS101",
//     "lecTit": "자료구조",
//     "lecMcode": "5",
//     "lecMcodeName": "공학부",
//     "lecMcodeDep": "01",
//     "lecMcodeDepName": "컴퓨터공학과"
//   },
//   {
//     "lecSerial": "PHIL201",
//     "lecTit": "윤리학",
//     "lecMcode": "4",
//     "lecMcodeName": "철학부",
//     "lecMcodeDep": "01",
//     "lecMcodeDepName": "철학"
//   }
// ]
```

---

## ⚠️ 주의사항

### 1. faculty_id와 dept_code 조합

❌ **잘못된 방법**:
```javascript
// dept_code만으로 찾기 (같은 코드가 여러 학부에 있음!)
const deptName = ALL_DEPTS[deptCode];  // 틀림!
```

✅ **올바른 방법**:
```javascript
// faculty_id + dept_code 조합으로 찾기
const deptName = FACULTY_MAP[facultyId].depts[deptCode];  // 맞음!
```

### 2. Null 체크

**코드가 매핑 테이블에 없을 수 있음**
```javascript
const facultyName = getFacultyName(lecture.lecMcode) || '미정';
const deptName = getDeptName(lecture.lecMcode, lecture.lecMcodeDep) || '미정';
```

### 3. 매핑 테이블 업데이트

**학부/학과가 추가되면 매핑 테이블도 업데이트 필요**
- DB의 FACULTY, DEPARTMENT 테이블과 동기화
- 또는 초기 로딩 시 API로 가져와서 사용

---

## 🎯 권장 사항

### Option A: 정적 매핑 (현재)

**장점**:
- 간단하고 빠름
- 추가 API 호출 없음
- 오프라인에서도 동작

**단점**:
- 학부/학과 추가 시 코드 수정 필요
- 프론트엔드 배포 필요

### Option B: 동적 로딩 (향후 개선)

```javascript
// 앱 초기화 시 한 번만 로딩
export async function loadFacultyMapping() {
  const faculties = await fetch('/api/faculties').then(r => r.json());
  const departments = await fetch('/api/departments').then(r => r.json());
  
  // 매핑 테이블 생성
  return buildMappingTable(faculties, departments);
}
```

**장점**:
- DB와 자동 동기화
- 코드 수정 불필요

**단점**:
- 초기 로딩 시간 증가
- API 추가 필요

---

## 📝 요약

1. **백엔드**: `lecMcode`, `lecMcodeDep` 코드만 반환 ✅
2. **프론트엔드**: 매핑 테이블로 코드 → 이름 변환 ✅
3. **주의**: `faculty_id` + `dept_code` 조합으로 학과 식별 ⚠️

---

> **작성**: 2025-10-22  
> **방식**: 프론트엔드 매핑
