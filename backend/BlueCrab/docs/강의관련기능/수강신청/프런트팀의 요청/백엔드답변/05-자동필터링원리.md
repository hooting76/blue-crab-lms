# 🔐 백엔드 자동 필터링 동작 원리

Phase 9 완료 - 학생 인증 및 자동 필터링 시스템

---

## 🎯 핵심 개념

**프론트엔드는 단순히 API만 호출하면 됩니다.**

백엔드가 모든 것을 자동으로 처리합니다:
- ✅ JWT 토큰으로 학생 자동 식별
- ✅ 학생의 학부/학과 자동 조회
- ✅ 0-value rule 자동 적용
- ✅ 전공/부전공 자동 매칭
- ✅ 수강 가능 여부 자동 판단

---

## 🔄 전체 동작 흐름

### 1단계: 프론트엔드 요청

```javascript
// 프론트엔드는 이것만 보내면 됨
fetch('/api/lectures/eligible', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${token}`  // ← JWT 토큰
  },
  body: JSON.stringify({
    studentId: 15,  // ← 학생 ID만 전송
    page: 0,
    size: 10
  })
});
```

### 2단계: 백엔드 자동 처리

```java
// 백엔드에서 자동으로 처리하는 내용

// 1. JWT 토큰 검증 및 사용자 식별
String userEmail = jwtUtils.getEmailFromToken(token);
User user = userRepository.findByUserEmail(userEmail);

// 2. 학생 정보 자동 조회
// studentId로 USER_TBL에서 학생의 학부/학과 코드 조회
String studentMajorFaculty = user.getMajorFacultyCode();  // 예: "01"
String studentMajorDept = user.getMajorDeptCode();        // 예: "001"
String studentMinorFaculty = user.getMinorFacultyCode();  // 예: "02"
String studentMinorDept = user.getMinorDeptCode();        // 예: "002"

// 3. 수강 가능한 강의 자동 필터링
List<Lecture> eligibleLectures = lectureRepository.findAll().stream()
    .filter(lecture -> {
        String lecMcode = lecture.getLecMcode();
        String lecMcodeDep = lecture.getLecMcodeDep();
        
        // 3-1. 0-value rule (모든 학생 허용)
        if ("0".equals(lecMcode) && "0".equals(lecMcodeDep)) {
            return true;  // 교양 과목 - 모든 학생 수강 가능
        }
        
        // 3-2. 학부만 일치 (학과는 0)
        if ("0".equals(lecMcodeDep)) {
            return lecMcode.equals(studentMajorFaculty) 
                || lecMcode.equals(studentMinorFaculty);
        }
        
        // 3-3. 전공 매칭
        boolean majorMatch = lecMcode.equals(studentMajorFaculty) 
                          && lecMcodeDep.equals(studentMajorDept);
        
        // 3-4. 부전공 매칭
        boolean minorMatch = lecMcode.equals(studentMinorFaculty) 
                          && lecMcodeDep.equals(studentMinorDept);
        
        return majorMatch || minorMatch;
    })
    .collect(Collectors.toList());

// 4. 응답 반환
return ResponseEntity.ok(eligibleLectures);
```

### 3단계: 프론트엔드 응답 수신

```javascript
// 이미 필터링된 강의만 받음
const data = await response.json();
console.log(data.eligibleLectures);
// → 해당 학생이 수강 가능한 강의만 포함됨!
```

---

## 🔐 JWT 토큰 자동 처리

### 백엔드가 자동으로 하는 일

```java
// Spring Security + JWT Filter에서 자동 처리

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, ...) {
        // 1. Authorization 헤더에서 토큰 추출
        String token = request.getHeader("Authorization").substring(7);
        
        // 2. 토큰 검증
        if (jwtUtils.validateToken(token)) {
            // 3. 토큰에서 사용자 정보 추출
            String userEmail = jwtUtils.getEmailFromToken(token);
            
            // 4. 사용자 조회 및 인증 설정
            UserDetails userDetails = userService.loadUserByUsername(userEmail);
            Authentication auth = new UsernamePasswordAuthenticationToken(
                userDetails, null, userDetails.getAuthorities()
            );
            SecurityContextHolder.getContext().setAuthentication(auth);
            // → 이제 모든 Controller에서 현재 사용자 정보 사용 가능
        }
    }
}
```

### 프론트엔드 입장

```javascript
// 프론트엔드는 그냥 토큰만 보내면 됨
const token = localStorage.getItem('authToken');

fetch('/api/lectures/eligible', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${token}`  // ← 이것만!
  },
  body: JSON.stringify({
    studentId: 15,
    page: 0,
    size: 10
  })
});

// 백엔드가 알아서:
// - 토큰 검증
// - 사용자 식별
// - 권한 확인
// - 학생 정보 조회
// - 필터링 처리
```

---

## 📊 자동 필터링 예시

### 시나리오: 컴퓨터공학과 2학년 학생

**학생 정보** (백엔드가 자동 조회):
```json
{
  "userIdx": 15,
  "userName": "홍길동",
  "majorFacultyCode": "01",      // 공학부
  "majorDeptCode": "001",         // 컴퓨터공학과
  "minorFacultyCode": "02",      // 자연과학대학
  "minorDeptCode": "003"          // 수학과
}
```

**강의 데이터** (DB에 있는 전체 강의):
```json
[
  {
    "lecSerial": "CS101",
    "lecTit": "자료구조",
    "lecMcode": "01",      // 공학부
    "lecMcodeDep": "001"   // 컴퓨터공학과
  },
  {
    "lecSerial": "MATH201",
    "lecTit": "선형대수학",
    "lecMcode": "02",      // 자연과학대학
    "lecMcodeDep": "003"   // 수학과
  },
  {
    "lecSerial": "ENG101",
    "lecTit": "대학영어",
    "lecMcode": "0",       // 교양
    "lecMcodeDep": "0"
  },
  {
    "lecSerial": "MECH201",
    "lecTit": "기계공학개론",
    "lecMcode": "01",      // 공학부
    "lecMcodeDep": "002"   // 기계공학과 (학생과 안 맞음)
  }
]
```

**백엔드 자동 필터링 결과**:
```json
{
  "eligibleLectures": [
    {
      "lecSerial": "CS101",
      "lecTit": "자료구조",
      "isEligible": true,
      "eligibilityReason": "전공 일치 (01-001)"
    },
    {
      "lecSerial": "MATH201",
      "lecTit": "선형대수학",
      "isEligible": true,
      "eligibilityReason": "부전공 일치 (02-003)"
    },
    {
      "lecSerial": "ENG101",
      "lecTit": "대학영어",
      "isEligible": true,
      "eligibilityReason": "교양 (0-0 전체 허용)"
    }
    // MECH201은 자동으로 제외됨 (기계공학과)
  ]
}
```

---

## ➕ 추가 필터링 (선택사항)

### 프론트엔드에서 추가 필터 가능

기본 필터링은 백엔드가 자동 처리하고,  
**추가 검색 조건은 프론트엔드가 선택**:

```javascript
// 기본 (백엔드 자동 필터링만)
fetch('/api/lectures/eligible', {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${token}` },
  body: JSON.stringify({
    studentId: 15,
    page: 0,
    size: 10
  })
});
// → 학부/학과 기반 필터링된 결과

// 추가 검색 옵션 사용
fetch('/api/lectures/eligible', {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${token}` },
  body: JSON.stringify({
    studentId: 15,
    lecYear: 2,        // ← 추가: 2학년 대상만
    lecSemester: 2,    // ← 추가: 2학기만
    lecMajor: 1,       // ← 추가: 전공만
    name: "알고리즘",   // ← 추가: 과목명 검색
    page: 0,
    size: 10
  })
});
// → 기본 필터링 + 추가 검색 조건 적용
```

---

## 🔒 보안 및 검증

### 백엔드 자동 보안 처리

```java
@PostMapping("/lectures/eligible")
@PreAuthorize("hasRole('STUDENT')")  // ← 학생만 접근 가능
public ResponseEntity<?> getEligibleLectures(
        @RequestBody EligibleLecturesRequest request,
        Authentication authentication) {  // ← Spring이 자동 주입
    
    // 1. JWT에서 추출한 현재 사용자 정보
    String currentUserEmail = authentication.getName();
    User currentUser = userRepository.findByUserEmail(currentUserEmail);
    
    // 2. 요청한 studentId와 현재 사용자 일치 여부 확인
    if (!currentUser.getUserIdx().equals(request.getStudentId())) {
        throw new ForbiddenException("본인의 강의만 조회할 수 있습니다.");
    }
    
    // 3. 필터링 처리
    List<Lecture> lectures = filterLecturesForStudent(currentUser);
    
    return ResponseEntity.ok(lectures);
}
```

### 프론트엔드는 신경 쓸 필요 없음

```javascript
// 그냥 API 호출만 하면 됨
// 백엔드가 알아서:
// - 토큰 검증
// - 권한 확인
// - studentId 일치 여부 확인
// - 필터링 처리
fetch('/api/lectures/eligible', {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${token}` },
  body: JSON.stringify({ studentId: 15, page: 0, size: 10 })
});
```

---

## 💡 핵심 정리

### 프론트엔드가 해야 할 일

```javascript
// 1. 토큰 저장 (로그인 시)
localStorage.setItem('authToken', token);

// 2. API 호출 시 토큰 포함
fetch('/api/lectures/eligible', {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${localStorage.getItem('authToken')}` },
  body: JSON.stringify({ studentId: 15, page: 0, size: 10 })
});

// 3. 응답 처리
const data = await response.json();
displayLectures(data.eligibleLectures);  // 이미 필터링됨!
```

### 백엔드가 자동으로 하는 일

1. ✅ JWT 토큰 검증
2. ✅ 사용자 식별 및 인증
3. ✅ 학생 정보 조회 (학부/학과)
4. ✅ 0-value rule 적용
5. ✅ 전공/부전공 매칭
6. ✅ 수강 가능 강의만 필터링
7. ✅ 권한 검증 (본인 여부)

---

## 📝 요약

**Phase 9 완료 상태**:
- 백엔드가 모든 필터링을 자동 처리
- 프론트엔드는 API만 호출하면 됨
- JWT 토큰으로 학생 자동 식별
- 학부/학과 기반 자동 필터링
- 추가 검색 조건은 선택사항 (프론트가 원하면 추가)

**프론트엔드 입장**:
```javascript
// 이것만 하면 끝!
fetch('/api/lectures/eligible', {
  method: 'POST',
  headers: { 'Authorization': `Bearer ${token}` },
  body: JSON.stringify({ studentId: 15, page: 0, size: 10 })
});
// → 수강 가능한 강의만 받음 (자동 필터링 완료)
```

---

> **테스트 검증**: `lecture-test-2a-student-enrollment.js` (Phase 9)
