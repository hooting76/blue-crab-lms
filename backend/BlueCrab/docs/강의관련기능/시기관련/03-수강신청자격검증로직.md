# 수강신청 자격 검증 로직

> **작성일**: 2025-10-16  
> **버전**: 1.0  
> **목적**: 수강신청 자격 검증의 상세 로직 및 구현 방안  

---

## 📋 **검증 로직 개요**

### **검증 단계**
```
1. 기본 자격 검증 (로그인, 학생 여부)
     ↓
2. 시기 검증 (수강신청 기간 확인)
     ↓  
3. 강의별 자격 검증 (학부/학과/학년)
     ↓
4. 정원 및 중복 검증
     ↓
5. 최종 승인/거부
```

---

## 👤 **기본 자격 검증**

### **A. 로그인 상태 확인**
```java
// JWT 토큰 검증
if (!jwtUtil.validateToken(token)) {
    throw new UnauthorizedException("로그인이 필요합니다");
}

// 사용자 정보 추출
Long userIdx = jwtUtil.getUserIdFromToken(token);
UserEntity user = userRepository.findById(userIdx)
    .orElseThrow(() -> new UserNotFoundException("사용자를 찾을 수 없습니다"));
```

### **B. 학생 자격 확인**
```java
// USER_STUDENT = 0 (학생)인지 확인
if (user.getUserStudent() != 0) {
    throw new ForbiddenException("학생만 수강신청이 가능합니다");
}
```

---

## ⏰ **시기 검증**

### **A. 수강신청 기간 확인**
```java
@Service
public class SemesterService {
    
    public boolean isEnrollmentPeriod() {
        LocalDate today = LocalDate.now();
        
        // 현재 학기의 수강신청 기간 조회
        SemesterPeriod currentPeriod = semesterRepository
            .findCurrentSemesterPeriod(today);
            
        if (currentPeriod == null) {
            return false;
        }
        
        return today.isAfter(currentPeriod.getEnrollmentStartDate().minusDays(1)) 
            && today.isBefore(currentPeriod.getEnrollmentEndDate().plusDays(1));
    }
    
    public PeriodType getCurrentPeriod() {
        LocalDate today = LocalDate.now();
        
        SemesterPeriod period = semesterRepository
            .findCurrentSemesterPeriod(today);
            
        if (period == null) {
            return PeriodType.VACATION;
        }
        
        if (today.isBefore(period.getEnrollmentStartDate())) {
            return PeriodType.VACATION;
        } else if (today.isAfter(period.getEnrollmentEndDate())) {
            return PeriodType.SEMESTER;
        } else {
            return PeriodType.ENROLLMENT;
        }
    }
}
```

### **B. 시기별 접근 제어**
```java
@PreAuthorize("@semesterService.isEnrollmentPeriod()")
@PostMapping("/api/enrollment/enroll")
public ResponseEntity<?> enrollLecture(@RequestBody EnrollRequest request) {
    // 수강신청 처리
}
```

---

## 🎓 **학사 자격 검증**

### **B. 학부/학과 코드 검증**
```java
@Service
public class EnrollmentEligibilityService {
    
    public boolean checkFacultyAndDepartment(UserEntity student, LectureEntity lecture) {
        // 학부 코드 확인 (강의 학부코드가 0이면 제한 없음)
        if (lecture.getFacultyCode() != 0 && 
            !student.getFacultyCode().equals(lecture.getFacultyCode())) {
            return false;
        }
        
        // 학과 코드 확인 (강의 학과코드가 0이면 제한 없음)
        if (lecture.getDepartmentCode() != 0 && 
            !student.getDepartmentCode().equals(lecture.getDepartmentCode())) {
            return false;
        }
        
        return true;
    }
}
```

### **⚠️ 중요: 제한 조건의 0값 규칙**
```
강의 설정값이 0인 경우 = "제한 없음" (누구나 수강 가능)

예시 1) 강의 조건: 학부=01, 학과=0, 최소학년=2
- 학생 A: 학부=01, 학과=02, 학년=2 → ✅ 수강 가능 (학과 제한 없음)
- 학생 B: 학부=02, 학과=01, 학년=2 → ❌ 수강 불가 (학부 불일치)

예시 2) 강의 조건: 학부=0, 학과=0, 최소학년=0  
- 모든 학생 수강 가능 (전체 개방 강의)

예시 3) 강의 조건: 학부=01, 학과=03, 최소학년=3
- 학부=01, 학과=03, 3학년 이상만 수강 가능
```
```

### **C. 학년 검증**
```java
public boolean checkGradeEligibility(UserEntity student, LectureEntity lecture) {
    // 최소 학년 확인 (강의 최소학년이 0이면 제한 없음)
    if (lecture.getMinGrade() != 0 && 
        student.getCurrentGrade() < lecture.getMinGrade()) {
        return false;
    }
    
    // 대상학년은 권장사항이므로 강제하지 않음
    // lecture.getLecYear()는 지침용으로만 사용
    
    return true;
}
```

### **C. 종합 자격 검증**
```java
public EligibilityResult checkEligibility(Long studentId, Long lecIdx) {
    UserEntity student = userRepository.findById(studentId)
        .orElseThrow(() -> new UserNotFoundException("학생 정보 없음"));
        
    LectureEntity lecture = lectureRepository.findById(lecIdx)
        .orElseThrow(() -> new LectureNotFoundException("강의 정보 없음"));
    
    EligibilityResult result = new EligibilityResult();
    
    // 2. 학부/학과 검증 (0값은 제한 없음)
    result.setFacultyMatch(
        lecture.getFacultyCode() == 0 || 
        student.getFacultyCode().equals(lecture.getFacultyCode())
    );
    result.setDepartmentMatch(
        lecture.getDepartmentCode() == 0 || 
        student.getDepartmentCode().equals(lecture.getDepartmentCode())
    );
    
    // 3. 학년 검증 (0값은 제한 없음)
    result.setGradeEligible(
        lecture.getMinGrade() == 0 || 
        student.getCurrentGrade() >= lecture.getMinGrade()
    );
    
    // 3. 정원 확인
    result.setCapacityAvailable(
        lecture.getLecCurrent() < lecture.getLecMany()
    );
    
    // 4. 중복 수강 확인
    boolean alreadyEnrolled = enrollmentRepository
        .existsByStudentIdxAndLecIdx(studentId, lecIdx);
    result.setAlreadyEnrolled(alreadyEnrolled);
    
    // 5. 최종 판정
    result.setEligible(
        result.isFacultyMatch() && 
        result.isDepartmentMatch() && 
        result.isGradeEligible() && 
        result.isCapacityAvailable() && 
        !result.isAlreadyEnrolled()
    );
    
    return result;
}
```

---

## 🔍 **강의 필터링 로직**

### **A. 수강 가능 강의 조회 쿼리**
```sql
SELECT l.*, 
       CASE 
         WHEN l.LEC_CURRENT < l.LEC_MANY 
              AND (l.FACULTY_CODE = 0 OR l.FACULTY_CODE = :studentFacultyCode)
              AND (l.DEPARTMENT_CODE = 0 OR l.DEPARTMENT_CODE = :studentDeptCode)  
              AND (l.MIN_GRADE = 0 OR l.MIN_GRADE <= :studentGrade)
              AND NOT EXISTS (
                  SELECT 1 FROM ENROLLMENT_EXTENDED_TBL e 
                  WHERE e.LEC_IDX = l.LEC_IDX 
                    AND e.STUDENT_IDX = :studentId
              )
         THEN true 
         ELSE false 
       END as IS_ELIGIBLE
FROM LEC_TBL l
WHERE l.LEC_YEAR = :targetYear
  AND l.LEC_SEMESTER = :targetSemester
ORDER BY l.LEC_TIT
```

### **B. 필터링 서비스 구현**
```java
@Service  
public class LectureFilterService {
    
    public List<EligibleLectureDto> getEligibleLectures(Long studentId, Pageable pageable) {
        UserEntity student = userRepository.findById(studentId)
            .orElseThrow(() -> new UserNotFoundException("학생 정보 없음"));
            
        // 현재 학기 정보 조회
        SemesterInfo currentSemester = semesterService.getCurrentSemester();
        
        // 기본 강의 목록 조회
        List<LectureEntity> lectures = lectureRepository
            .findByYearAndSemester(
                currentSemester.getYear(), 
                currentSemester.getSemester(), 
                pageable
            );
        
        // 각 강의별 자격 검증 및 DTO 변환
        return lectures.stream()
            .map(lecture -> {
                EligibilityResult eligibility = checkEligibility(studentId, lecture.getLecIdx());
                return EligibleLectureDto.builder()
                    .lecture(lecture)
                    .eligibility(eligibility)
                    .build();
            })
            .collect(Collectors.toList());
    }
}
```

---

## 📊 **검증 결과 DTO**

### **A. 자격 검증 결과**
```java
@Data
@Builder
public class EligibilityResult {
    private boolean eligible;           // 전체 자격 여부
    private boolean facultyMatch;       // 학부 일치
    private boolean departmentMatch;    // 학과 일치  
    private boolean gradeEligible;      // 학년 자격
    private boolean capacityAvailable;  // 정원 여유
    private boolean alreadyEnrolled;    // 중복 수강
    private List<String> reasons;       // 부적격 사유
    
    public void addReason(String reason) {
        if (this.reasons == null) {
            this.reasons = new ArrayList<>();
        }
        this.reasons.add(reason);
    }
}
```

### **B. 수강 가능 강의 DTO**
```java
@Data
@Builder
public class EligibleLectureDto {
    // 강의 기본 정보
    private Long lecIdx;
    private String lecSerial;
    private String lecTit;
    private String lecProf;
    private String lecProfName;
    private String lecTime;
    private Integer lecMany;
    private Integer lecCurrent;
    private Integer lecYear;
    private Integer lecSemester;
    
    // 자격 검증 정보
    private boolean isEligible;
    private EligibilityResult eligibilityDetails;
    
    // 추가 정보
    private Double occupancyRate;       // 정원 대비 신청률
    private Integer availableSlots;     // 남은 자리
    private String eligibilitySummary;  // 자격 요약
}
```

---

## 🚦 **실시간 정원 관리**

### **A. 동시성 제어**
```java
@Service
@Transactional
public class EnrollmentService {
    
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    public void enrollLecture(Long studentId, Long lecIdx) {
        // 강의 정보 조회 (비관적 락)
        LectureEntity lecture = lectureRepository
            .findByIdWithLock(lecIdx)
            .orElseThrow(() -> new LectureNotFoundException("강의 없음"));
        
        // 정원 확인
        if (lecture.getLecCurrent() >= lecture.getLecMany()) {
            throw new CapacityExceededException("정원 초과");
        }
        
        // 수강신청 처리
        EnrollmentEntity enrollment = EnrollmentEntity.builder()
            .lecIdx(lecIdx)
            .studentIdx(studentId)
            .enrollmentDate(LocalDateTime.now())
            .build();
            
        enrollmentRepository.save(enrollment);
        
        // 현재 인원 증가
        lecture.setLecCurrent(lecture.getLecCurrent() + 1);
        lectureRepository.save(lecture);
    }
}
```

### **B. 대기열 시스템 (향후 확장)**
```java
@Entity
public class EnrollmentWaitingList {
    private Long waitingIdx;
    private Long lecIdx;
    private Long studentIdx;
    private LocalDateTime waitingDate;
    private Integer waitingOrder;
    private WaitingStatus status; // WAITING, ENROLLED, CANCELLED
}
```

---

## 📌 **DB 제약 조건 정책**

### **설계 원칙**
- **DB 레벨**: 최소한의 제약 조건만 설정
  - Primary Key, Foreign Key, NOT NULL 등 기본 무결성
  - 비즈니스 로직 관련 제약은 설정하지 않음
  
- **애플리케이션 레벨**: 모든 비즈니스 검증을 코드로 처리
  - 프론트엔드: 실시간 검증 및 사용자 피드백
  - 백엔드: 최종 검증 및 보안 검증

### **장점**
- 🔄 **유연성**: 비즈니스 규칙 변경 시 코드만 수정
- 🎯 **사용자 경험**: 친화적인 에러 메시지 및 가이드 제공
- ⚡ **성능**: DB 제약 위반 예외 처리 오버헤드 없음
- 🛠 **복잡한 로직**: 0값 제한 없음 같은 조건부 검증 구현 가능

### **구현 방식**
```javascript
// 프론트엔드: 실시간 검증
const validateEnrollment = (student, lecture) => {
  if (lecture.facultyCode !== 0 && student.facultyCode !== lecture.facultyCode) {
    return "학부가 일치하지 않습니다";
  }
  // 기타 검증 로직...
}

// 백엔드: 이중 검증
@Service
public class EnrollmentValidationService {
  // DB 저장 전 최종 검증 및 보안 체크
}
```

---

## ⚠️ **예외 처리**

### **A. 자격 검증 예외**
```java
// 기본 자격 미달
public class EnrollmentNotEligibleException extends BusinessException {
    public EnrollmentNotEligibleException(List<String> reasons) {
        super("수강신청 자격이 없습니다: " + String.join(", ", reasons));
    }
}

// 정원 초과
public class CapacityExceededException extends BusinessException {
    public CapacityExceededException(String lectureName) {
        super(lectureName + " 강의의 정원이 초과되었습니다");
    }
}

// 중복 수강
public class DuplicateEnrollmentException extends BusinessException {
    public DuplicateEnrollmentException(String lectureName) {
        super("이미 " + lectureName + " 강의에 수강신청하셨습니다");
    }
}
```

### **B. 전역 예외 처리**
```java
@RestControllerAdvice
public class EnrollmentExceptionHandler {
    
    @ExceptionHandler(EnrollmentNotEligibleException.class)
    public ResponseEntity<ErrorResponse> handleNotEligible(
            EnrollmentNotEligibleException e) {
        
        ErrorResponse response = ErrorResponse.builder()
            .success(false)
            .message(e.getMessage())
            .errorCode("ENROLLMENT_NOT_ELIGIBLE")
            .timestamp(LocalDateTime.now())
            .build();
            
        return ResponseEntity.badRequest().body(response);
    }
}
```

---

## 🧪 **테스트 시나리오**

### **A. 정상 케이스**
```java
@Test
public void 정상_수강신청_성공() {
    // Given: 자격 충족 학생 + 여유 있는 강의
    Long studentId = 1L;
    Long lecIdx = 1L;
    
    // When: 수강신청 실행
    EnrollmentResult result = enrollmentService.enrollLecture(studentId, lecIdx);
    
    // Then: 성공 확인
    assertThat(result.isSuccess()).isTrue();
    assertThat(result.getEnrollmentIdx()).isNotNull();
}
```

### **B. 예외 케이스**
```java
@Test
public void 학년_미달_수강신청_실패() {
    // Given: 1학년 학생 + 3학년 대상 강의
    Long studentId = 2L; // 1학년
    Long lecIdx = 2L;    // 3학년 대상
    
    // When & Then: 예외 발생 확인
    assertThatThrownBy(() -> 
        enrollmentService.enrollLecture(studentId, lecIdx))
        .isInstanceOf(EnrollmentNotEligibleException.class)
        .hasMessageContaining("최소 학년");
}
```

---

## 📈 **성능 최적화**

### **A. 캐싱 전략**
```java
@Cacheable(value = "eligibleLectures", key = "#studentId + '_' + #pageable.pageNumber")
public List<EligibleLectureDto> getEligibleLectures(Long studentId, Pageable pageable) {
    // 수강 가능 강의 조회 로직
}

@CacheEvict(value = "eligibleLectures", allEntries = true)
public void enrollLecture(Long studentId, Long lecIdx) {
    // 수강신청 처리 (캐시 무효화)
}
```

### **B. 배치 처리**
```java
// 대용량 자격 검증을 위한 배치 처리
@Async
public CompletableFuture<List<EligibilityResult>> checkEligibilityBatch(
        List<Long> studentIds, Long lecIdx) {
    
    return CompletableFuture.supplyAsync(() -> 
        studentIds.parallelStream()
            .map(studentId -> checkEligibility(studentId, lecIdx))
            .collect(Collectors.toList())
    );
}
```

---

**검토 필요**: 동시성 제어 방식, 캐싱 전략 세부 설정