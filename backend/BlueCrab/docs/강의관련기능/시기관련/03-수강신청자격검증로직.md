# ìˆ˜ê°•ì‹ ì²­ ìê²© ê²€ì¦ ë¡œì§

> **ì‘ì„±ì¼**: 2025-10-16  
> **ë²„ì „**: 1.0  
> **ëª©ì **: ìˆ˜ê°•ì‹ ì²­ ìê²© ê²€ì¦ì˜ ìƒì„¸ ë¡œì§ ë° êµ¬í˜„ ë°©ì•ˆ  

---

## ğŸ“‹ **ê²€ì¦ ë¡œì§ ê°œìš”**

### **ê²€ì¦ ë‹¨ê³„**
```
1. ê¸°ë³¸ ìê²© ê²€ì¦ (ë¡œê·¸ì¸, í•™ìƒ ì—¬ë¶€)
     â†“
2. ì‹œê¸° ê²€ì¦ (ìˆ˜ê°•ì‹ ì²­ ê¸°ê°„ í™•ì¸)
     â†“  
3. ê°•ì˜ë³„ ìê²© ê²€ì¦ (í•™ë¶€/í•™ê³¼/í•™ë…„)
     â†“
4. ì •ì› ë° ì¤‘ë³µ ê²€ì¦
     â†“
5. ìµœì¢… ìŠ¹ì¸/ê±°ë¶€
```

---

## ğŸ‘¤ **ê¸°ë³¸ ìê²© ê²€ì¦**

### **A. ë¡œê·¸ì¸ ìƒíƒœ í™•ì¸**
```java
// JWT í† í° ê²€ì¦
if (!jwtUtil.validateToken(token)) {
    throw new UnauthorizedException("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤");
}

// ì‚¬ìš©ì ì •ë³´ ì¶”ì¶œ
Long userIdx = jwtUtil.getUserIdFromToken(token);
UserEntity user = userRepository.findById(userIdx)
    .orElseThrow(() -> new UserNotFoundException("ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"));
```

### **B. í•™ìƒ ìê²© í™•ì¸**
```java
// USER_STUDENT = 0 (í•™ìƒ)ì¸ì§€ í™•ì¸
if (user.getUserStudent() != 0) {
    throw new ForbiddenException("í•™ìƒë§Œ ìˆ˜ê°•ì‹ ì²­ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤");
}
```

---

## â° **ì‹œê¸° ê²€ì¦**

### **A. ìˆ˜ê°•ì‹ ì²­ ê¸°ê°„ í™•ì¸**
```java
@Service
public class SemesterService {
    
    public boolean isEnrollmentPeriod() {
        LocalDate today = LocalDate.now();
        
        // í˜„ì¬ í•™ê¸°ì˜ ìˆ˜ê°•ì‹ ì²­ ê¸°ê°„ ì¡°íšŒ
        SemesterPeriod currentPeriod = semesterRepository
            .findCurrentSemesterPeriod(today);
            
        if (currentPeriod == null) {
            return false;
        }
        
        return today.isAfter(currentPeriod.getEnrollmentStartDate().minusDays(1)) 
            && today.isBefore(currentPeriod.getEnrollmentEndDate().plusDays(1));
    }
    
    public PeriodType getCurrentPeriod() {
        LocalDate today = LocalDate.now();
        
        SemesterPeriod period = semesterRepository
            .findCurrentSemesterPeriod(today);
            
        if (period == null) {
            return PeriodType.VACATION;
        }
        
        if (today.isBefore(period.getEnrollmentStartDate())) {
            return PeriodType.VACATION;
        } else if (today.isAfter(period.getEnrollmentEndDate())) {
            return PeriodType.SEMESTER;
        } else {
            return PeriodType.ENROLLMENT;
        }
    }
}
```

### **B. ì‹œê¸°ë³„ ì ‘ê·¼ ì œì–´**
```java
@PreAuthorize("@semesterService.isEnrollmentPeriod()")
@PostMapping("/api/enrollment/enroll")
public ResponseEntity<?> enrollLecture(@RequestBody EnrollRequest request) {
    // ìˆ˜ê°•ì‹ ì²­ ì²˜ë¦¬
}
```

---

## ğŸ“ **í•™ì‚¬ ìê²© ê²€ì¦**

### **B. í•™ë¶€/í•™ê³¼ ì½”ë“œ ê²€ì¦**
```java
@Service
public class EnrollmentEligibilityService {
    
    public boolean checkFacultyAndDepartment(UserEntity student, LectureEntity lecture) {
        // í•™ë¶€ ì½”ë“œ í™•ì¸ (ê°•ì˜ í•™ë¶€ì½”ë“œê°€ 0ì´ë©´ ì œí•œ ì—†ìŒ)
        if (lecture.getFacultyCode() != 0 && 
            !student.getFacultyCode().equals(lecture.getFacultyCode())) {
            return false;
        }
        
        // í•™ê³¼ ì½”ë“œ í™•ì¸ (ê°•ì˜ í•™ê³¼ì½”ë“œê°€ 0ì´ë©´ ì œí•œ ì—†ìŒ)
        if (lecture.getDepartmentCode() != 0 && 
            !student.getDepartmentCode().equals(lecture.getDepartmentCode())) {
            return false;
        }
        
        return true;
    }
}
```

### **âš ï¸ ì¤‘ìš”: ì œí•œ ì¡°ê±´ì˜ 0ê°’ ê·œì¹™**
```
ê°•ì˜ ì„¤ì •ê°’ì´ 0ì¸ ê²½ìš° = "ì œí•œ ì—†ìŒ" (ëˆ„êµ¬ë‚˜ ìˆ˜ê°• ê°€ëŠ¥)

ì˜ˆì‹œ 1) ê°•ì˜ ì¡°ê±´: í•™ë¶€=01, í•™ê³¼=0, ìµœì†Œí•™ë…„=2
- í•™ìƒ A: í•™ë¶€=01, í•™ê³¼=02, í•™ë…„=2 â†’ âœ… ìˆ˜ê°• ê°€ëŠ¥ (í•™ê³¼ ì œí•œ ì—†ìŒ)
- í•™ìƒ B: í•™ë¶€=02, í•™ê³¼=01, í•™ë…„=2 â†’ âŒ ìˆ˜ê°• ë¶ˆê°€ (í•™ë¶€ ë¶ˆì¼ì¹˜)

ì˜ˆì‹œ 2) ê°•ì˜ ì¡°ê±´: í•™ë¶€=0, í•™ê³¼=0, ìµœì†Œí•™ë…„=0  
- ëª¨ë“  í•™ìƒ ìˆ˜ê°• ê°€ëŠ¥ (ì „ì²´ ê°œë°© ê°•ì˜)

ì˜ˆì‹œ 3) ê°•ì˜ ì¡°ê±´: í•™ë¶€=01, í•™ê³¼=03, ìµœì†Œí•™ë…„=3
- í•™ë¶€=01, í•™ê³¼=03, 3í•™ë…„ ì´ìƒë§Œ ìˆ˜ê°• ê°€ëŠ¥
```
```

### **C. í•™ë…„ ê²€ì¦**
```java
public boolean checkGradeEligibility(UserEntity student, LectureEntity lecture) {
    // ìµœì†Œ í•™ë…„ í™•ì¸ (ê°•ì˜ ìµœì†Œí•™ë…„ì´ 0ì´ë©´ ì œí•œ ì—†ìŒ)
    if (lecture.getMinGrade() != 0 && 
        student.getCurrentGrade() < lecture.getMinGrade()) {
        return false;
    }
    
    // ëŒ€ìƒí•™ë…„ì€ ê¶Œì¥ì‚¬í•­ì´ë¯€ë¡œ ê°•ì œí•˜ì§€ ì•ŠìŒ
    // lecture.getLecYear()ëŠ” ì§€ì¹¨ìš©ìœ¼ë¡œë§Œ ì‚¬ìš©
    
    return true;
}
```

### **C. ì¢…í•© ìê²© ê²€ì¦**
```java
public EligibilityResult checkEligibility(Long studentId, Long lecIdx) {
    UserEntity student = userRepository.findById(studentId)
        .orElseThrow(() -> new UserNotFoundException("í•™ìƒ ì •ë³´ ì—†ìŒ"));
        
    LectureEntity lecture = lectureRepository.findById(lecIdx)
        .orElseThrow(() -> new LectureNotFoundException("ê°•ì˜ ì •ë³´ ì—†ìŒ"));
    
    EligibilityResult result = new EligibilityResult();
    
    // 2. í•™ë¶€/í•™ê³¼ ê²€ì¦ (0ê°’ì€ ì œí•œ ì—†ìŒ)
    result.setFacultyMatch(
        lecture.getFacultyCode() == 0 || 
        student.getFacultyCode().equals(lecture.getFacultyCode())
    );
    result.setDepartmentMatch(
        lecture.getDepartmentCode() == 0 || 
        student.getDepartmentCode().equals(lecture.getDepartmentCode())
    );
    
    // 3. í•™ë…„ ê²€ì¦ (0ê°’ì€ ì œí•œ ì—†ìŒ)
    result.setGradeEligible(
        lecture.getMinGrade() == 0 || 
        student.getCurrentGrade() >= lecture.getMinGrade()
    );
    
    // 3. ì •ì› í™•ì¸
    result.setCapacityAvailable(
        lecture.getLecCurrent() < lecture.getLecMany()
    );
    
    // 4. ì¤‘ë³µ ìˆ˜ê°• í™•ì¸
    boolean alreadyEnrolled = enrollmentRepository
        .existsByStudentIdxAndLecIdx(studentId, lecIdx);
    result.setAlreadyEnrolled(alreadyEnrolled);
    
    // 5. ìµœì¢… íŒì •
    result.setEligible(
        result.isFacultyMatch() && 
        result.isDepartmentMatch() && 
        result.isGradeEligible() && 
        result.isCapacityAvailable() && 
        !result.isAlreadyEnrolled()
    );
    
    return result;
}
```

---

## ğŸ” **ê°•ì˜ í•„í„°ë§ ë¡œì§**

### **A. ìˆ˜ê°• ê°€ëŠ¥ ê°•ì˜ ì¡°íšŒ ì¿¼ë¦¬**
```sql
SELECT l.*, 
       CASE 
         WHEN l.LEC_CURRENT < l.LEC_MANY 
              AND (l.FACULTY_CODE = 0 OR l.FACULTY_CODE = :studentFacultyCode)
              AND (l.DEPARTMENT_CODE = 0 OR l.DEPARTMENT_CODE = :studentDeptCode)  
              AND (l.MIN_GRADE = 0 OR l.MIN_GRADE <= :studentGrade)
              AND NOT EXISTS (
                  SELECT 1 FROM ENROLLMENT_EXTENDED_TBL e 
                  WHERE e.LEC_IDX = l.LEC_IDX 
                    AND e.STUDENT_IDX = :studentId
              )
         THEN true 
         ELSE false 
       END as IS_ELIGIBLE
FROM LEC_TBL l
WHERE l.LEC_YEAR = :targetYear
  AND l.LEC_SEMESTER = :targetSemester
ORDER BY l.LEC_TIT
```

### **B. í•„í„°ë§ ì„œë¹„ìŠ¤ êµ¬í˜„**
```java
@Service  
public class LectureFilterService {
    
    public List<EligibleLectureDto> getEligibleLectures(Long studentId, Pageable pageable) {
        UserEntity student = userRepository.findById(studentId)
            .orElseThrow(() -> new UserNotFoundException("í•™ìƒ ì •ë³´ ì—†ìŒ"));
            
        // í˜„ì¬ í•™ê¸° ì •ë³´ ì¡°íšŒ
        SemesterInfo currentSemester = semesterService.getCurrentSemester();
        
        // ê¸°ë³¸ ê°•ì˜ ëª©ë¡ ì¡°íšŒ
        List<LectureEntity> lectures = lectureRepository
            .findByYearAndSemester(
                currentSemester.getYear(), 
                currentSemester.getSemester(), 
                pageable
            );
        
        // ê° ê°•ì˜ë³„ ìê²© ê²€ì¦ ë° DTO ë³€í™˜
        return lectures.stream()
            .map(lecture -> {
                EligibilityResult eligibility = checkEligibility(studentId, lecture.getLecIdx());
                return EligibleLectureDto.builder()
                    .lecture(lecture)
                    .eligibility(eligibility)
                    .build();
            })
            .collect(Collectors.toList());
    }
}
```

---

## ğŸ“Š **ê²€ì¦ ê²°ê³¼ DTO**

### **A. ìê²© ê²€ì¦ ê²°ê³¼**
```java
@Data
@Builder
public class EligibilityResult {
    private boolean eligible;           // ì „ì²´ ìê²© ì—¬ë¶€
    private boolean facultyMatch;       // í•™ë¶€ ì¼ì¹˜
    private boolean departmentMatch;    // í•™ê³¼ ì¼ì¹˜  
    private boolean gradeEligible;      // í•™ë…„ ìê²©
    private boolean capacityAvailable;  // ì •ì› ì—¬ìœ 
    private boolean alreadyEnrolled;    // ì¤‘ë³µ ìˆ˜ê°•
    private List<String> reasons;       // ë¶€ì ê²© ì‚¬ìœ 
    
    public void addReason(String reason) {
        if (this.reasons == null) {
            this.reasons = new ArrayList<>();
        }
        this.reasons.add(reason);
    }
}
```

### **B. ìˆ˜ê°• ê°€ëŠ¥ ê°•ì˜ DTO**
```java
@Data
@Builder
public class EligibleLectureDto {
    // ê°•ì˜ ê¸°ë³¸ ì •ë³´
    private Long lecIdx;
    private String lecSerial;
    private String lecTit;
    private String lecProf;
    private String lecProfName;
    private String lecTime;
    private Integer lecMany;
    private Integer lecCurrent;
    private Integer lecYear;
    private Integer lecSemester;
    
    // ìê²© ê²€ì¦ ì •ë³´
    private boolean isEligible;
    private EligibilityResult eligibilityDetails;
    
    // ì¶”ê°€ ì •ë³´
    private Double occupancyRate;       // ì •ì› ëŒ€ë¹„ ì‹ ì²­ë¥ 
    private Integer availableSlots;     // ë‚¨ì€ ìë¦¬
    private String eligibilitySummary;  // ìê²© ìš”ì•½
}
```

---

## ğŸš¦ **ì‹¤ì‹œê°„ ì •ì› ê´€ë¦¬**

### **A. ë™ì‹œì„± ì œì–´**
```java
@Service
@Transactional
public class EnrollmentService {
    
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    public void enrollLecture(Long studentId, Long lecIdx) {
        // ê°•ì˜ ì •ë³´ ì¡°íšŒ (ë¹„ê´€ì  ë½)
        LectureEntity lecture = lectureRepository
            .findByIdWithLock(lecIdx)
            .orElseThrow(() -> new LectureNotFoundException("ê°•ì˜ ì—†ìŒ"));
        
        // ì •ì› í™•ì¸
        if (lecture.getLecCurrent() >= lecture.getLecMany()) {
            throw new CapacityExceededException("ì •ì› ì´ˆê³¼");
        }
        
        // ìˆ˜ê°•ì‹ ì²­ ì²˜ë¦¬
        EnrollmentEntity enrollment = EnrollmentEntity.builder()
            .lecIdx(lecIdx)
            .studentIdx(studentId)
            .enrollmentDate(LocalDateTime.now())
            .build();
            
        enrollmentRepository.save(enrollment);
        
        // í˜„ì¬ ì¸ì› ì¦ê°€
        lecture.setLecCurrent(lecture.getLecCurrent() + 1);
        lectureRepository.save(lecture);
    }
}
```

### **B. ëŒ€ê¸°ì—´ ì‹œìŠ¤í…œ (í–¥í›„ í™•ì¥)**
```java
@Entity
public class EnrollmentWaitingList {
    private Long waitingIdx;
    private Long lecIdx;
    private Long studentIdx;
    private LocalDateTime waitingDate;
    private Integer waitingOrder;
    private WaitingStatus status; // WAITING, ENROLLED, CANCELLED
}
```

---

## ğŸ“Œ **DB ì œì•½ ì¡°ê±´ ì •ì±…**

### **ì„¤ê³„ ì›ì¹™**
- **DB ë ˆë²¨**: ìµœì†Œí•œì˜ ì œì•½ ì¡°ê±´ë§Œ ì„¤ì •
  - Primary Key, Foreign Key, NOT NULL ë“± ê¸°ë³¸ ë¬´ê²°ì„±
  - ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê´€ë ¨ ì œì•½ì€ ì„¤ì •í•˜ì§€ ì•ŠìŒ
  
- **ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨**: ëª¨ë“  ë¹„ì¦ˆë‹ˆìŠ¤ ê²€ì¦ì„ ì½”ë“œë¡œ ì²˜ë¦¬
  - í”„ë¡ íŠ¸ì—”ë“œ: ì‹¤ì‹œê°„ ê²€ì¦ ë° ì‚¬ìš©ì í”¼ë“œë°±
  - ë°±ì—”ë“œ: ìµœì¢… ê²€ì¦ ë° ë³´ì•ˆ ê²€ì¦

### **ì¥ì **
- ğŸ”„ **ìœ ì—°ì„±**: ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ë³€ê²½ ì‹œ ì½”ë“œë§Œ ìˆ˜ì •
- ğŸ¯ **ì‚¬ìš©ì ê²½í—˜**: ì¹œí™”ì ì¸ ì—ëŸ¬ ë©”ì‹œì§€ ë° ê°€ì´ë“œ ì œê³µ
- âš¡ **ì„±ëŠ¥**: DB ì œì•½ ìœ„ë°˜ ì˜ˆì™¸ ì²˜ë¦¬ ì˜¤ë²„í—¤ë“œ ì—†ìŒ
- ğŸ›  **ë³µì¡í•œ ë¡œì§**: 0ê°’ ì œí•œ ì—†ìŒ ê°™ì€ ì¡°ê±´ë¶€ ê²€ì¦ êµ¬í˜„ ê°€ëŠ¥

### **êµ¬í˜„ ë°©ì‹**
```javascript
// í”„ë¡ íŠ¸ì—”ë“œ: ì‹¤ì‹œê°„ ê²€ì¦
const validateEnrollment = (student, lecture) => {
  if (lecture.facultyCode !== 0 && student.facultyCode !== lecture.facultyCode) {
    return "í•™ë¶€ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤";
  }
  // ê¸°íƒ€ ê²€ì¦ ë¡œì§...
}

// ë°±ì—”ë“œ: ì´ì¤‘ ê²€ì¦
@Service
public class EnrollmentValidationService {
  // DB ì €ì¥ ì „ ìµœì¢… ê²€ì¦ ë° ë³´ì•ˆ ì²´í¬
}
```

---

## âš ï¸ **ì˜ˆì™¸ ì²˜ë¦¬**

### **A. ìê²© ê²€ì¦ ì˜ˆì™¸**
```java
// ê¸°ë³¸ ìê²© ë¯¸ë‹¬
public class EnrollmentNotEligibleException extends BusinessException {
    public EnrollmentNotEligibleException(List<String> reasons) {
        super("ìˆ˜ê°•ì‹ ì²­ ìê²©ì´ ì—†ìŠµë‹ˆë‹¤: " + String.join(", ", reasons));
    }
}

// ì •ì› ì´ˆê³¼
public class CapacityExceededException extends BusinessException {
    public CapacityExceededException(String lectureName) {
        super(lectureName + " ê°•ì˜ì˜ ì •ì›ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤");
    }
}

// ì¤‘ë³µ ìˆ˜ê°•
public class DuplicateEnrollmentException extends BusinessException {
    public DuplicateEnrollmentException(String lectureName) {
        super("ì´ë¯¸ " + lectureName + " ê°•ì˜ì— ìˆ˜ê°•ì‹ ì²­í•˜ì…¨ìŠµë‹ˆë‹¤");
    }
}
```

### **B. ì „ì—­ ì˜ˆì™¸ ì²˜ë¦¬**
```java
@RestControllerAdvice
public class EnrollmentExceptionHandler {
    
    @ExceptionHandler(EnrollmentNotEligibleException.class)
    public ResponseEntity<ErrorResponse> handleNotEligible(
            EnrollmentNotEligibleException e) {
        
        ErrorResponse response = ErrorResponse.builder()
            .success(false)
            .message(e.getMessage())
            .errorCode("ENROLLMENT_NOT_ELIGIBLE")
            .timestamp(LocalDateTime.now())
            .build();
            
        return ResponseEntity.badRequest().body(response);
    }
}
```

---

## ğŸ§ª **í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤**

### **A. ì •ìƒ ì¼€ì´ìŠ¤**
```java
@Test
public void ì •ìƒ_ìˆ˜ê°•ì‹ ì²­_ì„±ê³µ() {
    // Given: ìê²© ì¶©ì¡± í•™ìƒ + ì—¬ìœ  ìˆëŠ” ê°•ì˜
    Long studentId = 1L;
    Long lecIdx = 1L;
    
    // When: ìˆ˜ê°•ì‹ ì²­ ì‹¤í–‰
    EnrollmentResult result = enrollmentService.enrollLecture(studentId, lecIdx);
    
    // Then: ì„±ê³µ í™•ì¸
    assertThat(result.isSuccess()).isTrue();
    assertThat(result.getEnrollmentIdx()).isNotNull();
}
```

### **B. ì˜ˆì™¸ ì¼€ì´ìŠ¤**
```java
@Test
public void í•™ë…„_ë¯¸ë‹¬_ìˆ˜ê°•ì‹ ì²­_ì‹¤íŒ¨() {
    // Given: 1í•™ë…„ í•™ìƒ + 3í•™ë…„ ëŒ€ìƒ ê°•ì˜
    Long studentId = 2L; // 1í•™ë…„
    Long lecIdx = 2L;    // 3í•™ë…„ ëŒ€ìƒ
    
    // When & Then: ì˜ˆì™¸ ë°œìƒ í™•ì¸
    assertThatThrownBy(() -> 
        enrollmentService.enrollLecture(studentId, lecIdx))
        .isInstanceOf(EnrollmentNotEligibleException.class)
        .hasMessageContaining("ìµœì†Œ í•™ë…„");
}
```

---

## ğŸ“ˆ **ì„±ëŠ¥ ìµœì í™”**

### **A. ìºì‹± ì „ëµ**
```java
@Cacheable(value = "eligibleLectures", key = "#studentId + '_' + #pageable.pageNumber")
public List<EligibleLectureDto> getEligibleLectures(Long studentId, Pageable pageable) {
    // ìˆ˜ê°• ê°€ëŠ¥ ê°•ì˜ ì¡°íšŒ ë¡œì§
}

@CacheEvict(value = "eligibleLectures", allEntries = true)
public void enrollLecture(Long studentId, Long lecIdx) {
    // ìˆ˜ê°•ì‹ ì²­ ì²˜ë¦¬ (ìºì‹œ ë¬´íš¨í™”)
}
```

### **B. ë°°ì¹˜ ì²˜ë¦¬**
```java
// ëŒ€ìš©ëŸ‰ ìê²© ê²€ì¦ì„ ìœ„í•œ ë°°ì¹˜ ì²˜ë¦¬
@Async
public CompletableFuture<List<EligibilityResult>> checkEligibilityBatch(
        List<Long> studentIds, Long lecIdx) {
    
    return CompletableFuture.supplyAsync(() -> 
        studentIds.parallelStream()
            .map(studentId -> checkEligibility(studentId, lecIdx))
            .collect(Collectors.toList())
    );
}
```

---

**ê²€í†  í•„ìš”**: ë™ì‹œì„± ì œì–´ ë°©ì‹, ìºì‹± ì „ëµ ì„¸ë¶€ ì„¤ì •