# 05. 교수 권한 검증

> 🔒 교수가 담당 강의의 출석 승인 권한을 가지는지 검증하는 메커니즘

---

## 개요

### 목적

교수 출석 승인 시, **해당 교수가 실제로 그 강의의 담당 교수인지** 확인하는 보안 메커니즘입니다.

### 핵심 검증 조건

```
LEC_PROF (LEC_TBL) = professorIdx (JWT 토큰)
```

- **LEC_PROF**: `LEC_TBL.LEC_PROF` 필드 (문자열 타입)
- **professorIdx**: JWT 토큰에서 추출한 교수 USER_IDX (정수 타입)

---

## 데이터베이스 스키마

### LEC_TBL (강의 테이블)

| 컬럼명 | 타입 | 설명 | 예시 |
|--------|------|------|------|
| `LEC_SERIAL` | VARCHAR(20) | 강의 코드 (PK) | `'ETH201'` |
| `LEC_PROF` | VARCHAR(10) | 담당 교수 USER_IDX (문자열) | `'25'` |
| `LEC_NAME` | VARCHAR(100) | 강의명 | `'윤리학개론'` |
| `LEC_YEAR` | INT | 개설 연도 | `2025` |
| `LEC_SEMESTER` | VARCHAR(10) | 학기 | `'2학기'` |

### 중요 포인트

#### LEC_PROF는 문자열 타입

```sql
LEC_PROF VARCHAR(10)
```

- DB 스키마 상 문자열로 저장
- 실제 값: `'25'`, `'42'`, `'7'` (문자열)

#### USER_IDX는 정수 타입

```java
Integer professorIdx = extractUserIdFromToken(userDetails);
// professorIdx = 25 (정수)
```

- JWT 토큰에서 추출한 값은 정수
- 실제 값: `25`, `42`, `7` (정수)

#### 타입 불일치 해결

**문제**:
```java
// ❌ 타입 불일치로 비교 실패
WHERE e.lecTbl.lecProf = :professorIdx
// '25' (문자열) ≠ 25 (정수)
```

**해결책**:
```java
// ✅ CAST를 사용하여 타입 일치
WHERE e.lecTbl.lecProf = CAST(:professorIdx AS string)
// '25' (문자열) = '25' (문자열)
```

---

## Repository 쿼리

### findByLecSerialAndProfessorIdx

```java
@Query("SELECT e FROM EnrollmentExtendedTbl e " +
       "WHERE e.lecTbl.lecSerial = :lecSerial " +
       "AND e.lecTbl.lecProf = CAST(:professorIdx AS string)")
Optional<EnrollmentExtendedTbl> findByLecSerialAndProfessorIdx(
    @Param("lecSerial") String lecSerial, 
    @Param("professorIdx") Integer professorIdx
);
```

### 쿼리 구조 분석

#### 1. 테이블 조인

```java
FROM EnrollmentExtendedTbl e
```

- `ENROLLMENT_EXTENDED_TBL` 테이블 사용
- `e.lecTbl`: `LEC_TBL`과의 연관관계 (ManyToOne)

#### 2. 강의 코드 조건

```java
WHERE e.lecTbl.lecSerial = :lecSerial
```

- 파라미터: `lecSerial` (예: `'ETH201'`)
- 조건: 해당 강의 코드의 수강생 찾기

#### 3. 교수 권한 조건 (핵심)

```java
AND e.lecTbl.lecProf = CAST(:professorIdx AS string)
```

- 파라미터: `professorIdx` (예: `25`)
- CAST: 정수 `25`를 문자열 `'25'`로 변환
- 조건: LEC_PROF 필드와 일치하는지 확인

#### 4. 반환 타입

```java
Optional<EnrollmentExtendedTbl>
```

- 조건에 맞는 수강생 1명이라도 있으면: `Optional.of(enrollment)`
- 조건에 맞는 수강생이 없으면: `Optional.empty()`

### 검증 로직

```java
Optional<EnrollmentExtendedTbl> enrollment = 
    enrollmentRepository.findByLecSerialAndProfessorIdx(
        "ETH201", 
        25
    );

if (!enrollment.isPresent()) {
    // 담당 교수가 아니거나, 수강생이 없음
    throw new ForbiddenException("해당 강의의 담당 교수가 아닙니다.");
}

// 검증 통과: 교수가 해당 강의를 담당하고 있음
```

---

## 실행 예시

### 성공 케이스

#### 시나리오

- **강의**: ETH201
- **LEC_PROF**: `'25'` (문자열)
- **JWT 토큰**: `professorIdx = 25` (정수)

#### SQL 실행

```sql
SELECT e.* 
FROM ENROLLMENT_EXTENDED_TBL e
INNER JOIN LEC_TBL l ON e.LEC_SERIAL = l.LEC_SERIAL
WHERE l.LEC_SERIAL = 'ETH201'
  AND l.LEC_PROF = '25'  -- CAST(25 AS string) = '25'
LIMIT 1;
```

#### 결과

```
+--------+------------+-----------+------------------+
| ENR_NO | LEC_SERIAL | USER_IDX  | ENROLLMENT_DATA  |
+--------+------------+-----------+------------------+
| 1      | ETH201     | 6         | {"summary":...}  |
+--------+------------+-----------+------------------+
```

- **해석**: ETH201 강의에 수강생(USER_IDX=6)이 존재
- **결론**: 교수 25는 ETH201의 담당 교수 ✅

### 실패 케이스 1: 타 교수

#### 시나리오

- **강의**: ETH201
- **LEC_PROF**: `'25'` (문자열)
- **JWT 토큰**: `professorIdx = 42` (정수) ❌

#### SQL 실행

```sql
SELECT e.* 
FROM ENROLLMENT_EXTENDED_TBL e
INNER JOIN LEC_TBL l ON e.LEC_SERIAL = l.LEC_SERIAL
WHERE l.LEC_SERIAL = 'ETH201'
  AND l.LEC_PROF = '42'  -- CAST(42 AS string) = '42'
LIMIT 1;
```

#### 결과

```
Empty set (0 rows)
```

- **해석**: LEC_PROF='25'이므로 조건 불일치
- **결론**: 교수 42는 ETH201의 담당 교수가 아님 ❌
- **응답**: 403 Forbidden

### 실패 케이스 2: 수강생 없음

#### 시나리오

- **강의**: ETH999 (존재하지만 수강생 0명)
- **LEC_PROF**: `'25'` (문자열)
- **JWT 토큰**: `professorIdx = 25` (정수)

#### SQL 실행

```sql
SELECT e.* 
FROM ENROLLMENT_EXTENDED_TBL e
INNER JOIN LEC_TBL l ON e.LEC_SERIAL = l.LEC_SERIAL
WHERE l.LEC_SERIAL = 'ETH999'
  AND l.LEC_PROF = '25'
LIMIT 1;
```

#### 결과

```
Empty set (0 rows)
```

- **해석**: 강의는 존재하지만 수강생이 없음
- **결론**: 수강생이 없는 강의는 출석 관리 불필요
- **응답**: 403 Forbidden (또는 404 Not Found)

---

## Service 구현

### approveAttendance 메서드

```java
@Transactional
public int approveAttendance(
    Integer professorIdx,
    String lecSerial,
    Integer sessionNumber,
    List<AttendanceApprovalRecordDto> attendanceRecords
) {
    // 1. 교수 권한 검증
    Optional<EnrollmentExtendedTbl> enrollment = 
        enrollmentRepository.findByLecSerialAndProfessorIdx(
            lecSerial, 
            professorIdx
        );
    
    if (!enrollment.isPresent()) {
        throw new ForbiddenException(
            "해당 강의의 담당 교수가 아닙니다."
        );
    }
    
    // 2. 권한 검증 통과 → 승인 처리
    int successCount = 0;
    
    for (AttendanceApprovalRecordDto record : attendanceRecords) {
        try {
            // 각 학생별 승인 처리
            approveForStudent(
                lecSerial, 
                sessionNumber, 
                record.getStudentIdx(), 
                record.getStatus(),
                professorIdx
            );
            successCount++;
        } catch (Exception e) {
            log.error("승인 실패: studentIdx={}", 
                      record.getStudentIdx(), e);
        }
    }
    
    return successCount;
}
```

### 검증 시점

```
API 호출 → JWT 토큰 파싱 → Service 호출 → 교수 권한 검증 → 승인 처리
                                              ↑
                                         이 단계에서 검증
```

- **위치**: Service 메서드 최상단
- **시점**: 승인 처리 전에 반드시 검증
- **실패 시**: 403 Forbidden 예외 발생

---

## Controller 구현

### approveAttendance 엔드포인트

```java
@PostMapping("/approve")
public ResponseEntity<?> approveAttendance(
    @Valid @RequestBody AttendanceApproveRequestDto request,
    @AuthenticationPrincipal UserDetails userDetails
) {
    // 1. JWT에서 professorIdx 추출
    Integer professorIdx = extractUserIdFromToken(userDetails);
    
    // 2. Service 호출 (내부에서 권한 검증)
    try {
        int successCount = attendanceService.approveAttendance(
            professorIdx,  // ← 이 값이 LEC_PROF와 비교됨
            request.getLecSerial(),
            request.getSessionNumber(),
            request.getAttendanceRecords()
        );
        
        int totalCount = request.getAttendanceRecords().size();
        String message = String.format(
            "출석 승인이 완료되었습니다. (%d/%d)", 
            successCount, 
            totalCount
        );
        
        return ResponseEntity.ok(
            AttendanceResponseDto.success(message, null)
        );
        
    } catch (ForbiddenException e) {
        return ResponseEntity.status(HttpStatus.FORBIDDEN)
            .body(AttendanceResponseDto.error(e.getMessage(), "FORBIDDEN"));
    }
}
```

### JWT 토큰 추출

```java
private Integer extractUserIdFromToken(UserDetails userDetails) {
    if (userDetails == null) {
        throw new UnauthorizedException("인증이 필요합니다.");
    }
    
    // UserDetails에서 username 추출 (실제로는 USER_IDX)
    String username = userDetails.getUsername();
    
    // 문자열 → 정수 변환
    try {
        return Integer.parseInt(username);
    } catch (NumberFormatException e) {
        throw new UnauthorizedException("유효하지 않은 토큰입니다.");
    }
}
```

---

## 보안 고려사항

### 1. JWT 토큰 검증

```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(
        HttpServletRequest request,
        HttpServletResponse response,
        FilterChain filterChain
    ) throws ServletException, IOException {
        
        // Authorization 헤더 추출
        String header = request.getHeader("Authorization");
        
        if (header != null && header.startsWith("Bearer ")) {
            String token = header.substring(7);
            
            // 토큰 유효성 검증
            if (jwtTokenProvider.validateToken(token)) {
                // UserDetails 생성
                Authentication auth = 
                    jwtTokenProvider.getAuthentication(token);
                SecurityContextHolder.getContext()
                    .setAuthentication(auth);
            }
        }
        
        filterChain.doFilter(request, response);
    }
}
```

### 2. 토큰 위조 방지

- **서명 검증**: HS256 알고리즘으로 토큰 서명
- **만료 시간**: 액세스 토큰 30분, 리프레시 토큰 7일
- **비밀 키**: 환경변수로 관리 (노출 금지)

```properties
# application.properties
jwt.secret=${JWT_SECRET}
jwt.access-token-validity=1800000   # 30분
jwt.refresh-token-validity=604800000 # 7일
```

### 3. SQL 인젝션 방지

```java
// ✅ JPQL 파라미터 바인딩 사용
@Query("... WHERE e.lecTbl.lecSerial = :lecSerial ...")
// Spring Data JPA가 자동으로 이스케이프 처리

// ❌ 문자열 연결 (절대 금지)
@Query("... WHERE e.lecTbl.lecSerial = '" + lecSerial + "' ...")
```

### 4. 권한 계층

```
1. JWT 인증: 유효한 사용자인가?
2. 역할 확인: ROLE_PROFESSOR 또는 ROLE_ADMIN?
3. 담당 확인: LEC_PROF = professorIdx?
```

- **3단계 검증**을 모두 통과해야 승인 가능

---

## 에러 처리

### ForbiddenException

```java
@ResponseStatus(HttpStatus.FORBIDDEN)
public class ForbiddenException extends RuntimeException {
    public ForbiddenException(String message) {
        super(message);
    }
}
```

### 에러 응답

```json
{
  "success": false,
  "message": "해당 강의의 담당 교수가 아닙니다.",
  "errorCode": "FORBIDDEN",
  "timestamp": "2025-10-23T15:45:00.123456789Z"
}
```

### 프론트엔드 처리

```javascript
async function approveAttendance(lecSerial, sessionNumber, records) {
    try {
        const response = await fetch('/api/attendance/approve', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${getToken()}`
            },
            body: JSON.stringify({
                lecSerial,
                sessionNumber,
                attendanceRecords: records
            })
        });
        
        const data = await response.json();
        
        if (response.status === 403) {
            alert('권한 오류: ' + data.message);
            // 담당 강의 목록 페이지로 이동
            window.location.href = '/professor/lectures';
        } else if (data.success) {
            alert('승인 완료: ' + data.message);
        }
        
    } catch (error) {
        console.error('네트워크 오류:', error);
    }
}
```

---

## 테스트 예시

### 브라우저 콘솔 테스트

#### 1. 정상 케이스 (담당 교수)

```javascript
// prof.octopus@univ.edu (USER_IDX=25, ETH201 담당)
const token = window.authToken;

const response = await fetch(
    'https://bluecrab.chickenkiller.com/BlueCrab-1.0.0/api/attendance/approve',
    {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
            lecSerial: 'ETH201',
            sessionNumber: 1,
            attendanceRecords: [
                { studentIdx: 6, status: '출' }
            ]
        })
    }
);

const data = await response.json();
console.log(data);
// ✅ { success: true, message: "출석 승인이 완료되었습니다. (1/1)" }
```

#### 2. 권한 오류 케이스 (타 교수)

```javascript
// 다른 교수로 로그인한 후
const token = window.authToken; // professorIdx = 42

const response = await fetch(
    'https://bluecrab.chickenkiller.com/BlueCrab-1.0.0/api/attendance/approve',
    {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
            lecSerial: 'ETH201', // prof.octopus(25)의 강의
            sessionNumber: 1,
            attendanceRecords: [
                { studentIdx: 6, status: '출' }
            ]
        })
    }
);

const data = await response.json();
console.log(data);
// ❌ { success: false, message: "해당 강의의 담당 교수가 아닙니다.", errorCode: "FORBIDDEN" }
```

---

## 성능 최적화

### 1. 인덱스 추가

```sql
-- LEC_PROF 컬럼에 인덱스 (빠른 검색)
CREATE INDEX idx_lec_prof ON LEC_TBL(LEC_PROF);

-- 복합 인덱스 (더 빠른 검색)
CREATE INDEX idx_lec_serial_prof 
ON LEC_TBL(LEC_SERIAL, LEC_PROF);
```

### 2. 쿼리 캐싱

```java
@Cacheable(value = "professorLectures", key = "#professorIdx")
public List<String> getProfessorLectures(Integer professorIdx) {
    return lecTblRepository.findByLecProf(
        String.valueOf(professorIdx)
    ).stream()
     .map(LecTbl::getLecSerial)
     .collect(Collectors.toList());
}
```

### 3. 검증 결과 캐싱

```java
// 요청당 1회만 검증 (중복 호출 방지)
private final Map<String, Boolean> verificationCache = new HashMap<>();

private boolean isAuthorized(Integer professorIdx, String lecSerial) {
    String cacheKey = professorIdx + ":" + lecSerial;
    
    return verificationCache.computeIfAbsent(cacheKey, k -> {
        return enrollmentRepository
            .findByLecSerialAndProfessorIdx(lecSerial, professorIdx)
            .isPresent();
    });
}
```

---

## 확장 가능성

### 1. 부교수 추가

현재는 1개의 `LEC_PROF` 필드만 지원하지만, 부교수를 추가하려면:

```sql
-- 새 테이블 생성
CREATE TABLE LEC_PROFESSORS (
    LEC_SERIAL VARCHAR(20),
    PROF_IDX INT,
    ROLE VARCHAR(20), -- 'main', 'assistant'
    PRIMARY KEY (LEC_SERIAL, PROF_IDX)
);
```

```java
// 쿼리 수정
@Query("SELECT e FROM EnrollmentExtendedTbl e " +
       "WHERE e.lecTbl.lecSerial = :lecSerial " +
       "AND EXISTS (" +
       "  SELECT lp FROM LecProfessors lp " +
       "  WHERE lp.lecSerial = :lecSerial " +
       "  AND lp.profIdx = :professorIdx" +
       ")")
```

### 2. 역할 기반 권한

```java
public enum ProfessorRole {
    MAIN,      // 주담당 교수 (모든 권한)
    ASSISTANT, // 부담당 교수 (조회 + 승인)
    OBSERVER   // 참관 교수 (조회만)
}
```

---

## 주의사항

### 백엔드 개발자

1. **CAST 필수**
   - `LEC_PROF`는 문자열, `professorIdx`는 정수
   - 반드시 `CAST(:professorIdx AS string)` 사용

2. **검증 시점**
   - Service 메서드 최상단에서 검증
   - 승인 처리 전에 반드시 검증 완료

3. **예외 처리**
   - `ForbiddenException` 명확히 구분
   - 404(Not Found)와 403(Forbidden) 구분

### 프론트엔드 개발자

1. **403 에러 처리**
   - 권한 없음 메시지 표시
   - 담당 강의 목록으로 자동 이동

2. **사전 검증**
   - 담당 강의 목록만 표시
   - 타 교수 강의는 UI에서 숨김

---

## 다음 단계

- **[04. 교수 출석 승인](./04_교수_출석_승인.md)**: 승인 API 전체 흐름
- **[06. 자동 승인 메커니즘](./06_자동_승인_메커니즘.md)**: 7일 경과 시 자동 승인
- **[09. 예외 처리 및 확장](./09_예외_처리_및_확장.md)**: 전체 예외 처리 전략

---

**📚 [목차로 돌아가기](./README.md)**
