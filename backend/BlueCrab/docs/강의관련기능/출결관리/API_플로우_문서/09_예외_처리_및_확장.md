# 09. 예외 처리 및 확장

> 🛡️ 출결 관리 시스템의 예외 처리 전략과 향후 확장 가능성

---

## 개요

출결 관리 시스템의 안정성을 보장하기 위한 예외 처리 전략과 향후 확장 계획을 다룹니다.

---

## 예외 처리 전략

### 예외 계층 구조

```
RuntimeException
├── UnauthorizedException (401)
├── ForbiddenException (403)
├── NotFoundException (404)
├── ConflictException (409)
└── BadRequestException (400)
```

### 커스텀 예외 클래스

#### 1. UnauthorizedException (401)

```java
@ResponseStatus(HttpStatus.UNAUTHORIZED)
public class UnauthorizedException extends RuntimeException {
    public UnauthorizedException(String message) {
        super(message);
    }
}
```

**사용 시나리오**:
- JWT 토큰이 없음
- JWT 토큰이 만료됨
- JWT 토큰이 유효하지 않음

**예시**:
```java
if (token == null || token.isEmpty()) {
    throw new UnauthorizedException("인증이 필요합니다.");
}
```

#### 2. ForbiddenException (403)

```java
@ResponseStatus(HttpStatus.FORBIDDEN)
public class ForbiddenException extends RuntimeException {
    public ForbiddenException(String message) {
        super(message);
    }
}
```

**사용 시나리오**:
- 담당 교수가 아닌 경우
- 권한이 없는 리소스 접근

**예시**:
```java
if (!enrollment.isPresent()) {
    throw new ForbiddenException("해당 강의의 담당 교수가 아닙니다.");
}
```

#### 3. NotFoundException (404)

```java
@ResponseStatus(HttpStatus.NOT_FOUND)
public class NotFoundException extends RuntimeException {
    public NotFoundException(String message) {
        super(message);
    }
}
```

**사용 시나리오**:
- 수강생을 찾을 수 없음
- 강의를 찾을 수 없음
- 대기 중인 요청을 찾을 수 없음

**예시**:
```java
EnrollmentExtendedTbl enrollment = enrollmentRepository
    .findByLecSerialAndStudentIdx(lecSerial, studentIdx)
    .orElseThrow(() -> new NotFoundException("수강생을 찾을 수 없습니다."));
```

#### 4. ConflictException (409)

```java
@ResponseStatus(HttpStatus.CONFLICT)
public class ConflictException extends RuntimeException {
    public ConflictException(String message) {
        super(message);
    }
}
```

**사용 시나리오**:
- 이미 승인된 회차에 중복 요청
- 이미 확정된 세션에 수정 시도

**예시**:
```java
boolean alreadyApproved = sessions.stream()
    .anyMatch(s -> s.getSessionNumber().equals(sessionNumber));

if (alreadyApproved) {
    throw new ConflictException("이미 승인된 회차입니다.");
}
```

#### 5. BadRequestException (400)

```java
@ResponseStatus(HttpStatus.BAD_REQUEST)
public class BadRequestException extends RuntimeException {
    public BadRequestException(String message) {
        super(message);
    }
}
```

**사용 시나리오**:
- 잘못된 파라미터 값
- 유효하지 않은 회차 번호
- 유효하지 않은 출석 상태

**예시**:
```java
if (sessionNumber < 1 || sessionNumber > 80) {
    throw new BadRequestException("회차 번호는 1에서 80 사이여야 합니다.");
}
```

---

## 글로벌 예외 핸들러

### @RestControllerAdvice 구현

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    // 401 Unauthorized
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<AttendanceResponseDto> handleUnauthorized(
        UnauthorizedException e
    ) {
        log.warn("Unauthorized: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
            .body(AttendanceResponseDto.error(e.getMessage(), "UNAUTHORIZED"));
    }

    // 403 Forbidden
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<AttendanceResponseDto> handleForbidden(
        ForbiddenException e
    ) {
        log.warn("Forbidden: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.FORBIDDEN)
            .body(AttendanceResponseDto.error(e.getMessage(), "FORBIDDEN"));
    }

    // 404 Not Found
    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<AttendanceResponseDto> handleNotFound(
        NotFoundException e
    ) {
        log.warn("Not Found: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(AttendanceResponseDto.error(e.getMessage(), "NOT_FOUND"));
    }

    // 409 Conflict
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<AttendanceResponseDto> handleConflict(
        ConflictException e
    ) {
        log.warn("Conflict: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.CONFLICT)
            .body(AttendanceResponseDto.error(e.getMessage(), "CONFLICT"));
    }

    // 400 Bad Request (Validation)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<AttendanceResponseDto> handleValidation(
        MethodArgumentNotValidException e
    ) {
        String message = e.getBindingResult().getAllErrors().stream()
            .map(DefaultMessageSourceResolvable::getDefaultMessage)
            .collect(Collectors.joining(", "));
        
        log.warn("Validation Error: {}", message);
        return ResponseEntity.badRequest()
            .body(AttendanceResponseDto.error(message, "VALIDATION_ERROR"));
    }

    // 500 Internal Server Error
    @ExceptionHandler(Exception.class)
    public ResponseEntity<AttendanceResponseDto> handleGeneral(Exception e) {
        log.error("Internal Server Error", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(AttendanceResponseDto.error(
                "서버 오류가 발생했습니다. 관리자에게 문의하세요.",
                "INTERNAL_ERROR"
            ));
    }
}
```

### 에러 응답 구조

```java
@Data
@Builder
public class AttendanceResponseDto {
    private Boolean success;
    private String message;
    private Object data;
    private String timestamp;
    private String errorCode;

    public static AttendanceResponseDto error(String message, String errorCode) {
        return AttendanceResponseDto.builder()
            .success(false)
            .message(message)
            .data(null)
            .timestamp(LocalDateTime.now().toString())
            .errorCode(errorCode)
            .build();
    }
}
```

---

## 예외 처리 케이스별 가이드

### 케이스 1: JWT 토큰 관련

| 상황 | 예외 | HTTP | 메시지 |
|-----|------|------|--------|
| 토큰 없음 | UnauthorizedException | 401 | "인증이 필요합니다." |
| 토큰 만료 | UnauthorizedException | 401 | "토큰이 만료되었습니다." |
| 토큰 무효 | UnauthorizedException | 401 | "유효하지 않은 토큰입니다." |

**프론트엔드 처리**:
```javascript
if (response.status === 401) {
    // 로그인 페이지로 리다이렉트
    localStorage.removeItem('accessToken');
    window.location.href = '/login';
}
```

### 케이스 2: 권한 관련

| 상황 | 예외 | HTTP | 메시지 |
|-----|------|------|--------|
| 담당 교수 아님 | ForbiddenException | 403 | "해당 강의의 담당 교수가 아닙니다." |
| 수강생 아님 | NotFoundException | 404 | "수강생을 찾을 수 없습니다." |

**프론트엔드 처리**:
```javascript
if (response.status === 403) {
    alert('권한이 없습니다. 담당 강의 목록으로 이동합니다.');
    window.location.href = '/professor/lectures';
}
```

### 케이스 3: 데이터 검증

| 상황 | 예외 | HTTP | 메시지 |
|-----|------|------|--------|
| 회차 범위 초과 | BadRequestException | 400 | "회차 번호는 1에서 80 사이여야 합니다." |
| 잘못된 상태 값 | BadRequestException | 400 | "출석 상태는 '출', '지', '결' 중 하나여야 합니다." |
| 사유 길이 초과 | BadRequestException | 400 | "요청 사유는 최대 200자까지 입력 가능합니다." |

**프론트엔드 처리**:
```javascript
if (response.status === 400) {
    // 입력 필드 하이라이트
    const data = await response.json();
    showValidationError(data.message);
}
```

### 케이스 4: 중복 데이터

| 상황 | 예외 | HTTP | 메시지 |
|-----|------|------|--------|
| 이미 승인됨 | ConflictException | 409 | "이미 승인된 회차입니다." |
| 이미 요청됨 | - | 200 | "기존 요청을 업데이트했습니다." |

**비즈니스 로직**:
```java
// 이미 승인된 경우: 409 에러
if (isInSessions(sessionNumber)) {
    throw new ConflictException("이미 승인된 회차입니다.");
}

// 이미 요청 중인 경우: 업데이트 (에러 아님)
if (isInPendingRequests(sessionNumber)) {
    updateExistingRequest(sessionNumber, newReason);
    return "기존 요청을 업데이트했습니다.";
}
```

---

## 로깅 전략

### 로그 레벨별 사용

```java
@Slf4j
public class AttendanceService {
    
    public void requestAttendance(...) {
        // INFO: 정상 동작
        log.info("출석 요청: lecSerial={}, studentIdx={}, sessionNumber={}", 
                 lecSerial, studentIdx, sessionNumber);
        
        try {
            // 비즈니스 로직
        } catch (NotFoundException e) {
            // WARN: 예상 가능한 에러
            log.warn("수강생을 찾을 수 없음: studentIdx={}", studentIdx);
            throw e;
        } catch (Exception e) {
            // ERROR: 예상 못한 에러
            log.error("출석 요청 처리 중 오류 발생", e);
            throw new RuntimeException("출석 요청 처리 실패", e);
        }
    }
}
```

### 로그 레벨 가이드

| 레벨 | 용도 | 예시 |
|-----|------|------|
| **TRACE** | 상세 디버깅 | 변수 값, 메서드 진입/종료 |
| **DEBUG** | 개발 디버깅 | JSON 파싱 결과, 쿼리 파라미터 |
| **INFO** | 정상 동작 | API 호출, 승인 완료 |
| **WARN** | 예상 가능한 에러 | 권한 없음, 데이터 없음 |
| **ERROR** | 심각한 에러 | 예외 발생, DB 오류 |

### 로그 설정

```properties
# application.properties
logging.level.com.bluecrab.attendance=INFO
logging.level.com.bluecrab.attendance.scheduler=DEBUG

# 파일 출력
logging.file.name=logs/attendance.log
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
```

---

## 트랜잭션 관리

### @Transactional 적용

```java
@Service
@Transactional(readOnly = true)
public class AttendanceService {
    
    // 읽기 전용 (기본)
    public AttendanceDataDto getStudentAttendance(...) {
        // readOnly = true (성능 최적화)
    }
    
    // 쓰기 트랜잭션
    @Transactional
    public void requestAttendance(...) {
        // readOnly = false (데이터 변경)
    }
    
    // 트랜잭션 전파
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logAttendanceChange(...) {
        // 독립적인 트랜잭션 (부모 롤백해도 커밋)
    }
}
```

### 롤백 전략

```java
@Transactional(rollbackFor = Exception.class)
public void approveAttendance(...) {
    try {
        // 1. 데이터 검증
        validateData();
        
        // 2. 출석 승인 처리
        processApproval();
        
        // 3. 알림 전송 (실패해도 롤백 안 함)
        sendNotification(); // @Transactional(propagation = REQUIRES_NEW)
        
    } catch (Exception e) {
        log.error("승인 처리 실패: 롤백 수행", e);
        throw e; // 롤백 트리거
    }
}
```

---

## 동시성 제어

### 낙관적 잠금 (Optimistic Locking)

```java
@Entity
@Table(name = "ENROLLMENT_EXTENDED_TBL")
public class EnrollmentExtendedTbl {
    
    @Version
    @Column(name = "VERSION")
    private Long version; // JPA가 자동으로 증가
    
    // 기타 필드...
}
```

**동작 원리**:
```sql
-- 읽기
SELECT * FROM ENROLLMENT_EXTENDED_TBL WHERE ENR_NO = 1 AND VERSION = 5;

-- 쓰기 (버전 확인)
UPDATE ENROLLMENT_EXTENDED_TBL 
SET ENROLLMENT_DATA = ?, VERSION = 6
WHERE ENR_NO = 1 AND VERSION = 5;

-- 버전이 다르면 OptimisticLockException 발생
```

**처리 방법**:
```java
@Transactional
public void requestAttendance(...) {
    try {
        EnrollmentExtendedTbl enrollment = 
            enrollmentRepository.findById(enrNo).orElseThrow();
        
        // 데이터 수정
        enrollment.setEnrollmentData(updatedJson);
        enrollmentRepository.save(enrollment);
        
    } catch (OptimisticLockException e) {
        log.warn("동시성 충돌: 재시도 필요");
        throw new ConflictException("다른 사용자가 수정 중입니다. 다시 시도해주세요.");
    }
}
```

### 비관적 잠금 (Pessimistic Locking)

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT e FROM EnrollmentExtendedTbl e WHERE e.enrNo = :enrNo")
Optional<EnrollmentExtendedTbl> findByIdWithLock(@Param("enrNo") Integer enrNo);
```

**사용 시나리오**:
- 충돌이 빈번한 경우
- 데이터 정합성이 매우 중요한 경우

---

## 성능 최적화

### 1. 인덱스 추가

```sql
-- 강의 코드 + 학생 조회 최적화
CREATE INDEX idx_enrollment_lec_student 
ON ENROLLMENT_EXTENDED_TBL(LEC_SERIAL, USER_IDX);

-- 강의 코드 + 교수 조회 최적화 (조인)
CREATE INDEX idx_lec_serial_prof 
ON LEC_TBL(LEC_SERIAL, LEC_PROF);
```

### 2. 쿼리 최적화

```java
// ❌ N+1 문제
List<EnrollmentExtendedTbl> enrollments = 
    enrollmentRepository.findAllByLecSerial(lecSerial);

for (EnrollmentExtendedTbl enrollment : enrollments) {
    UserTbl user = enrollment.getUserTbl(); // 추가 쿼리 발생
}

// ✅ Fetch Join 사용
@Query("SELECT e FROM EnrollmentExtendedTbl e " +
       "JOIN FETCH e.userTbl " +
       "WHERE e.lecTbl.lecSerial = :lecSerial")
List<EnrollmentExtendedTbl> findAllByLecSerialWithUser(
    @Param("lecSerial") String lecSerial
);
```

### 3. 캐싱

```java
@Cacheable(value = "attendance", key = "#lecSerial + ':' + #studentIdx")
public AttendanceDataDto getStudentAttendance(
    String lecSerial, 
    Integer studentIdx
) {
    // 캐시에서 먼저 확인, 없으면 DB 조회
}

@CacheEvict(value = "attendance", key = "#lecSerial + ':' + #studentIdx")
public void requestAttendance(...) {
    // 캐시 무효화
}
```

---

## 향후 확장 가능성

### 1. 실시간 알림 시스템

**WebSocket 연동**:
```java
@Service
public class AttendanceNotificationService {
    
    @Autowired
    private SimpMessagingTemplate messagingTemplate;
    
    public void notifyApproval(Integer studentIdx, Integer sessionNumber) {
        messagingTemplate.convertAndSendToUser(
            studentIdx.toString(),
            "/queue/attendance",
            "회차 " + sessionNumber + " 출석이 승인되었습니다."
        );
    }
}
```

### 2. 출석 패턴 분석

**머신러닝 연동**:
```java
@Service
public class AttendanceAnalyticsService {
    
    public Map<String, Object> analyzeAttendancePattern(
        String lecSerial, 
        Integer studentIdx
    ) {
        // 출석율 추이 분석
        // 지각 패턴 분석
        // 예측 모델 적용
        return analysis;
    }
}
```

### 3. QR 코드 출석 체크

**모바일 앱 연동**:
```java
@PostMapping("/attendance/qr-checkin")
public ResponseEntity<?> qrCheckIn(@RequestBody QrCheckInRequest request) {
    // QR 코드 검증
    // 위치 기반 검증 (GPS)
    // 시간 기반 검증 (수업 시간)
    // 자동 출석 처리
}
```

### 4. 부모/보호자 알림

**SMS/이메일 연동**:
```java
@Service
public class ParentNotificationService {
    
    @Async
    public void notifyParent(Integer studentIdx, String message) {
        // 학생의 보호자 정보 조회
        // SMS 또는 이메일 전송
        // 알림 이력 저장
    }
}
```

### 5. 출석 데이터 export

**엑셀/CSV 다운로드**:
```java
@GetMapping("/attendance/export")
public ResponseEntity<byte[]> exportAttendance(
    @RequestParam String lecSerial
) {
    // 출석 데이터 조회
    // Excel 파일 생성 (Apache POI)
    // 다운로드 응답
}
```

### 6. 통계 대시보드

**집계 쿼리**:
```java
@Query("SELECT " +
       "l.lecSerial, " +
       "AVG(CAST(JSON_EXTRACT(e.enrollmentData, '$.attendance.summary.attendanceRate') AS DOUBLE)) as avgRate " +
       "FROM EnrollmentExtendedTbl e " +
       "JOIN e.lecTbl l " +
       "GROUP BY l.lecSerial")
List<Object[]> getAttendanceStatistics();
```

---

## 보안 강화

### 1. Rate Limiting

```java
@Component
public class RateLimitInterceptor implements HandlerInterceptor {
    
    private final Map<String, AtomicInteger> requestCounts = new ConcurrentHashMap<>();
    
    @Override
    public boolean preHandle(
        HttpServletRequest request, 
        HttpServletResponse response, 
        Object handler
    ) {
        String clientId = extractClientId(request);
        AtomicInteger count = requestCounts.computeIfAbsent(
            clientId, 
            k -> new AtomicInteger(0)
        );
        
        if (count.incrementAndGet() > 100) { // 분당 100회 제한
            response.setStatus(429); // Too Many Requests
            return false;
        }
        
        return true;
    }
}
```

### 2. IP 화이트리스트

```java
@Component
public class IpWhitelistFilter implements Filter {
    
    private final Set<String> whitelist = Set.of(
        "192.168.1.0/24",
        "10.0.0.0/8"
    );
    
    @Override
    public void doFilter(
        ServletRequest request, 
        ServletResponse response, 
        FilterChain chain
    ) throws IOException, ServletException {
        String clientIp = request.getRemoteAddr();
        
        if (!isWhitelisted(clientIp)) {
            ((HttpServletResponse) response).setStatus(403);
            return;
        }
        
        chain.doFilter(request, response);
    }
}
```

### 3. 감사 로그 (Audit Log)

```java
@Aspect
@Component
@Slf4j
public class AuditLogAspect {
    
    @Around("@annotation(com.bluecrab.annotation.Auditable)")
    public Object logAudit(ProceedingJoinPoint joinPoint) throws Throwable {
        String method = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        
        log.info("감사 로그: method={}, args={}, timestamp={}", 
                 method, args, LocalDateTime.now());
        
        Object result = joinPoint.proceed();
        
        log.info("감사 로그: method={}, result={}", method, result);
        
        return result;
    }
}
```

---

## 테스트 전략

### 단위 테스트 (Unit Test)

```java
@SpringBootTest
@Transactional
public class AttendanceServiceTest {
    
    @Autowired
    private AttendanceService attendanceService;
    
    @Test
    public void testRequestAttendance_Success() {
        // Given
        String lecSerial = "ETH201";
        Integer studentIdx = 6;
        Integer sessionNumber = 1;
        
        // When
        attendanceService.requestAttendance(lecSerial, studentIdx, sessionNumber, null);
        
        // Then
        AttendanceDataDto data = attendanceService.getStudentAttendance(lecSerial, studentIdx);
        assertEquals(1, data.getPendingRequests().size());
    }
    
    @Test
    public void testRequestAttendance_AlreadyApproved() {
        // Given: 이미 승인된 회차
        
        // When & Then
        assertThrows(ConflictException.class, () -> {
            attendanceService.requestAttendance(lecSerial, studentIdx, sessionNumber, null);
        });
    }
}
```

### 통합 테스트 (Integration Test)

```java
@SpringBootTest
@AutoConfigureMockMvc
public class AttendanceControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    public void testApproveAttendance_Success() throws Exception {
        String token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...";
        
        mockMvc.perform(post("/api/attendance/approve")
                .header("Authorization", "Bearer " + token)
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"lecSerial\":\"ETH201\",\"sessionNumber\":1,\"attendanceRecords\":[{\"studentIdx\":6,\"status\":\"출\"}]}"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.success").value(true));
    }
}
```

---

## 모니터링

### 1. 헬스 체크

```java
@RestController
public class HealthController {
    
    @GetMapping("/health")
    public Map<String, Object> health() {
        return Map.of(
            "status", "UP",
            "timestamp", LocalDateTime.now()
        );
    }
}
```

### 2. 메트릭 수집

```java
@Component
public class AttendanceMetrics {
    
    private final Counter requestCounter = 
        Counter.builder("attendance.requests")
               .description("출석 요청 수")
               .register(meterRegistry);
    
    public void incrementRequestCount() {
        requestCounter.increment();
    }
}
```

---

## 다음 단계

- **[10. 성적 관리 시스템 연동](./10_성적_연동_가이드.md)**: 출석율을 성적 점수로 변환
- **[README.md](./README.md)**: 전체 문서 목차
- **[02. API 엔드포인트](./02_API_엔드포인트.md)**: API 명세 참고

---

**📚 [목차로 돌아가기](./README.md)**
