# 03. 학생 출석 요청

> 👨‍🎓 학생이 출석을 요청하는 API 상세 가이드

---

## API 개요

### 기본 정보
- **엔드포인트**: `POST /api/attendance/request`
- **권한**: 학생 (authenticated)
- **설명**: 학생이 수강 중인 강의의 특정 회차 출석을 요청하는 API

### 주요 기능
- ✅ 수강 중인 강의의 특정 회차 출석 요청
- ✅ 요청 사유 입력 가능 (선택사항)
- ✅ 즉시 임시 승인 상태로 저장 (`tempApproved=true`)
- ✅ 7일 후 자동 확정 또는 교수의 수동 승인
- ✅ 실시간 출석 현황 응답

---

## 요청 조건

### 필수 조건

1. **인증 토큰 필수**
   - JWT Bearer 토큰 필요
   - `studentIdx`는 토큰에서 자동 추출

2. **수강 중인 강의만 가능**
   - 해당 학생이 등록된 강의만 요청 가능
   - 서버에서 `ENROLLMENT_EXTENDED_TBL` 조회로 검증

3. **유효한 회차 번호**
   - 1~80 범위 내의 회차
   - 프론트엔드에서 사전 필터링 권장

### 제약 사항

1. **중복 요청**
   - 동일 회차에 대한 재요청 시 기존 요청 업데이트
   - `pendingRequests`에서 기존 항목을 덮어씀

2. **이미 확정된 출석**
   - `sessions`에 이미 존재하는 회차는 요청 불가
   - 409 Conflict 응답

3. **강의 종료 후 제한**
   - 강의 종료 후 일정 기간(예: 1개월)까지만 요청 가능
   - 프론트엔드에서 처리 권장

---

## 요청 명세

### HTTP 요청

```http
POST /api/attendance/request HTTP/1.1
Host: bluecrab.chickenkiller.com
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

{
  "lecSerial": "ETH201",
  "sessionNumber": 1,
  "requestReason": "교통체증으로 지각"
}
```

### 요청 파라미터

| 필드 | 타입 | 필수 | 설명 | 제약 조건 |
|-----|------|------|------|----------|
| `lecSerial` | String | ✅ 필수 | 강의 코드 | 영문/숫자, 최대 20자 |
| `sessionNumber` | Integer | ✅ 필수 | 회차 번호 | 1~80 범위 |
| `requestReason` | String | ⬜ 선택 | 요청 사유 | 최대 200자 |

### 파라미터 상세

#### 1. lecSerial (강의 코드)
```json
"lecSerial": "ETH201"
```
- **형식**: 강의 코드 문자열
- **예시**: "CS101", "ETH201", "MATH301"
- **검증**: 
  - 서버에서 `LEC_TBL` 존재 여부 확인
  - 학생의 수강 여부 확인 (`ENROLLMENT_EXTENDED_TBL`)

#### 2. sessionNumber (회차 번호)
```json
"sessionNumber": 1
```
- **형식**: 1~80 사이의 정수
- **의미**: 강의 회차 (예: 16주 강의 × 주 5회 = 최대 80회)
- **검증**:
  - `@Min(1)`, `@Max(80)` 어노테이션
  - 이미 `sessions`에 존재하는 회차인지 확인

#### 3. requestReason (요청 사유) - 선택
```json
"requestReason": "교통체증으로 지각"
```
- **형식**: 최대 200자 문자열
- **예시**:
  - "교통체증으로 지각"
  - "버스 지연"
  - "가족 사정"
  - "병원 진료"
- **생략 가능**: null 또는 필드 자체 생략 가능

---

## 응답 명세

### 성공 응답 (200 OK)

```json
{
  "success": true,
  "message": "출석 요청이 접수되었습니다.",
  "data": {
    "summary": {
      "attended": 10,
      "late": 2,
      "absent": 1,
      "totalSessions": 14,
      "attendanceRate": 71.4,
      "updatedAt": "2025-10-23 15:30:00"
    },
    "sessions": [
      {
        "sessionNumber": 1,
        "status": "출",
        "requestDate": "2025-10-15 10:00:00",
        "approvedDate": "2025-10-15 10:30:00",
        "approvedBy": 25,
        "tempApproved": false
      },
      {
        "sessionNumber": 2,
        "status": "지",
        "requestDate": "2025-10-16 14:00:00",
        "approvedDate": "2025-10-16 14:15:00",
        "approvedBy": 25,
        "tempApproved": false
      }
      // ... 더 많은 확정된 출석 기록
    ],
    "pendingRequests": [
      {
        "sessionNumber": 14,
        "requestDate": "2025-10-23 15:30:00",
        "expiresAt": "2025-10-30 00:00:00",
        "requestReason": "교통체증으로 지각",
        "tempApproved": true
      }
    ]
  },
  "timestamp": "2025-10-23T15:30:00.123456789Z",
  "errorCode": null
}
```

### 응답 데이터 구조

#### 1. summary (출석 통계)
```json
{
  "attended": 10,        // 출석 횟수
  "late": 2,             // 지각 횟수
  "absent": 1,           // 결석 횟수
  "totalSessions": 14,   // 전체 회차 (attended + late + absent + pending)
  "attendanceRate": 71.4, // 출석률 (attended / totalSessions * 100)
  "updatedAt": "2025-10-23 15:30:00"
}
```

**계산 로직**:
- `totalSessions` = `sessions.length` + `pendingRequests.length`
- `attendanceRate` = (`attended` / `totalSessions`) × 100
- 소수점 첫째 자리까지 표시

#### 2. sessions (확정된 출석 기록)
```json
[
  {
    "sessionNumber": 1,              // 회차 번호
    "status": "출",                  // 출석 상태 ("출", "지", "결")
    "requestDate": "2025-10-15 10:00:00",  // 요청 일시
    "approvedDate": "2025-10-15 10:30:00", // 승인 일시
    "approvedBy": 25,                // 승인한 교수 USER_IDX
    "tempApproved": false            // 자동 승인 여부
  }
]
```

**필드 설명**:
- `status`: "출"(출석), "지"(지각), "결"(결석)
- `approvedBy`: 교수의 USER_IDX, 자동 승인 시에도 저장
- `tempApproved`: `true`면 7일 자동 승인, `false`면 교수 수동 승인

#### 3. pendingRequests (대기 중인 요청)
```json
[
  {
    "sessionNumber": 14,             // 회차 번호
    "requestDate": "2025-10-23 15:30:00",    // 요청 일시
    "expiresAt": "2025-10-30 00:00:00",      // 만료 일시 (7일 후 자정)
    "requestReason": "교통체증으로 지각",     // 요청 사유 (선택)
    "tempApproved": true             // 임시 승인 상태 (항상 true)
  }
]
```

**필드 설명**:
- `expiresAt`: 요청일 + 7일의 00:00:00 (날짜 기준)
- `requestReason`: 사용자가 입력한 사유 (없으면 null)
- `tempApproved`: 항상 `true` (임시 승인 상태)

---

## 처리 흐름

### 1. 요청 수신 및 검증

```java
@PostMapping("/request")
public ResponseEntity<?> requestAttendance(
    @Valid @RequestBody AttendanceRequestRequestDto request,
    @AuthenticationPrincipal UserDetails userDetails
) {
    // 1. JWT에서 studentIdx 추출
    Integer studentIdx = extractUserIdFromToken(userDetails);
    
    // 2. 요청 데이터 검증
    // - lecSerial 존재 여부
    // - sessionNumber 범위 (1~80)
    // - requestReason 길이 (최대 200자)
    
    // 3. Service 호출
    AttendanceDataDto result = attendanceService.requestAttendance(
        studentIdx,
        request.getLecSerial(),
        request.getSessionNumber(),
        request.getRequestReason()
    );
    
    return ResponseEntity.ok(result);
}
```

### 2. 수강 여부 확인

```java
// Repository에서 학생의 수강 정보 조회
Optional<EnrollmentExtendedTbl> enrollment = 
    enrollmentRepository.findByLecSerialAndStudentIdx(
        lecSerial, 
        studentIdx
    );

if (!enrollment.isPresent()) {
    throw new NotFoundException("수강 중인 강의가 아닙니다.");
}
```

### 3. 중복 확인

```java
// sessions에 이미 존재하는지 확인
boolean alreadyApproved = attendanceData.getSessions().stream()
    .anyMatch(s -> s.getSessionNumber() == sessionNumber);

if (alreadyApproved) {
    throw new ConflictException("이미 승인된 회차입니다.");
}

// pendingRequests에 이미 존재하면 업데이트, 없으면 추가
Optional<AttendancePendingRequestDto> existing = 
    attendanceData.getPendingRequests().stream()
        .filter(r -> r.getSessionNumber() == sessionNumber)
        .findFirst();

if (existing.isPresent()) {
    // 기존 요청 업데이트
    existing.get().setRequestDate(LocalDateTime.now());
    existing.get().setExpiresAt(calculateExpiresAt());
    existing.get().setRequestReason(requestReason);
} else {
    // 새로운 요청 추가
    attendanceData.getPendingRequests().add(newRequest);
}
```

### 4. 만료 날짜 계산

```java
// 요청일 + 7일의 00:00:00
LocalDateTime expiresAt = LocalDateTime.now()
    .plusDays(7)
    .withHour(0)
    .withMinute(0)
    .withSecond(0)
    .withNano(0);

// 예: 2025-10-23 15:30:00 요청
//  → 2025-10-30 00:00:00 만료
```

### 5. pendingRequests에 추가

```java
AttendancePendingRequestDto newRequest = AttendancePendingRequestDto.builder()
    .sessionNumber(sessionNumber)
    .requestDate(LocalDateTime.now())
    .expiresAt(expiresAt)
    .requestReason(requestReason)
    .tempApproved(true)
    .build();

attendanceData.getPendingRequests().add(newRequest);
```

### 6. summary 재계산

```java
// totalSessions = sessions + pendingRequests
int totalSessions = attendanceData.getSessions().size() 
                  + attendanceData.getPendingRequests().size();

// attendanceRate 재계산
double attendanceRate = totalSessions > 0 
    ? (attended * 100.0) / totalSessions 
    : 0.0;

attendanceData.getSummary().setTotalSessions(totalSessions);
attendanceData.getSummary().setAttendanceRate(attendanceRate);
attendanceData.getSummary().setUpdatedAt(LocalDateTime.now());
```

### 7. JSON 직렬화 및 저장

```java
// AttendanceDataDto → JSON 문자열
String updatedJson = objectMapper.writeValueAsString(attendanceData);

// ENROLLMENT_DATA 필드 업데이트
enrollment.setEnrollmentData(updatedJson);
enrollmentRepository.save(enrollment);
```

---

## 에러 케이스

### 1. 인증 실패 (401)

**원인**: JWT 토큰 없음 또는 만료

```json
{
  "success": false,
  "message": "인증이 필요합니다.",
  "errorCode": "UNAUTHORIZED"
}
```

### 2. 수강 중인 강의 아님 (404)

**원인**: 학생이 해당 강의를 수강하지 않음

```json
{
  "success": false,
  "message": "수강 중인 강의가 아닙니다.",
  "errorCode": "NOT_FOUND"
}
```

### 3. 유효하지 않은 회차 (400)

**원인**: sessionNumber가 1~80 범위를 벗어남

```json
{
  "success": false,
  "message": "회차 번호는 1에서 80 사이여야 합니다.",
  "errorCode": "VALIDATION_ERROR"
}
```

### 4. 이미 승인된 회차 (409)

**원인**: 해당 회차가 이미 `sessions`에 존재

```json
{
  "success": false,
  "message": "이미 승인된 회차입니다.",
  "errorCode": "CONFLICT"
}
```

### 5. 강의를 찾을 수 없음 (404)

**원인**: lecSerial이 DB에 존재하지 않음

```json
{
  "success": false,
  "message": "해당 강의를 찾을 수 없습니다.",
  "errorCode": "NOT_FOUND"
}
```

---

## 사용 예시

### JavaScript (브라우저)

```javascript
async function requestAttendance(lecSerial, sessionNumber, requestReason) {
    const token = window.authToken || 
                  localStorage.getItem('accessToken');
    
    const response = await fetch(
        'https://bluecrab.chickenkiller.com/BlueCrab-1.0.0/api/attendance/request',
        {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
                lecSerial: lecSerial,
                sessionNumber: sessionNumber,
                requestReason: requestReason
            })
        }
    );
    
    const data = await response.json();
    
    if (data.success) {
        console.log('출석 요청 성공!');
        console.log('출석률:', data.data.summary.attendanceRate + '%');
        console.log('대기 중인 요청:', data.data.pendingRequests.length + '건');
    } else {
        console.error('출석 요청 실패:', data.message);
    }
    
    return data;
}

// 사용 예
requestAttendance('ETH201', 14, '교통체증으로 지각');
```

### React 예시

```jsx
import { useState } from 'react';

function AttendanceRequestForm({ lecSerial }) {
    const [sessionNumber, setSessionNumber] = useState(1);
    const [requestReason, setRequestReason] = useState('');
    const [loading, setLoading] = useState(false);
    
    const handleSubmit = async (e) => {
        e.preventDefault();
        setLoading(true);
        
        try {
            const token = window.authToken || localStorage.getItem('accessToken');
            const response = await fetch('/api/attendance/request', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({
                    lecSerial,
                    sessionNumber,
                    requestReason
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                alert('출석 요청이 접수되었습니다!');
                // 출석 현황 UI 업데이트
            } else {
                alert('오류: ' + data.message);
            }
        } catch (error) {
            alert('네트워크 오류: ' + error.message);
        } finally {
            setLoading(false);
        }
    };
    
    return (
        <form onSubmit={handleSubmit}>
            <label>
                회차:
                <input
                    type="number"
                    min="1"
                    max="80"
                    value={sessionNumber}
                    onChange={(e) => setSessionNumber(e.target.value)}
                    required
                />
            </label>
            
            <label>
                요청 사유 (선택):
                <textarea
                    maxLength="200"
                    value={requestReason}
                    onChange={(e) => setRequestReason(e.target.value)}
                    placeholder="출석 요청 사유를 입력하세요"
                />
            </label>
            
            <button type="submit" disabled={loading}>
                {loading ? '요청 중...' : '출석 요청'}
            </button>
        </form>
    );
}
```

---

## 주의사항

### 프론트엔드 개발자

1. **회차 필터링**
   - `sessions`에 이미 있는 회차는 요청 불가능하도록 UI에서 비활성화
   - `pendingRequests`에 있는 회차는 "대기 중" 표시

2. **토큰 관리**
   - 토큰 우선순위: `window.authToken` > `localStorage` > `sessionStorage`
   - 토큰 만료 시 자동 로그아웃 또는 갱신

3. **에러 처리**
   - 401: 로그인 페이지로 리다이렉트
   - 404: "수강 중인 강의가 아닙니다" 메시지 표시
   - 409: "이미 처리된 회차입니다" 메시지 표시

### 백엔드 개발자

1. **트랜잭션 관리**
   - JSON 파싱/직렬화 과정에서 예외 발생 시 롤백
   - DB 저장 실패 시 롤백

2. **동시성 처리**
   - 같은 학생이 동시에 여러 요청을 보낼 경우 대비
   - Optimistic Locking 또는 비관적 잠금 고려

3. **성능 최적화**
   - JSON 파싱 캐싱
   - Repository 쿼리 최적화 (JOIN FETCH)

---

## 다음 단계

- **[04. 교수 출석 승인](./04_교수_출석_승인.md)**: 교수가 요청을 승인하는 방법
- **[06. 자동 승인 메커니즘](./06_자동_승인_메커니즘.md)**: 7일 후 자동 처리 로직
- **[07. 데이터 구조](./07_데이터_구조.md)**: JSON 데이터 구조 상세

---

**📚 [목차로 돌아가기](./README.md)**
