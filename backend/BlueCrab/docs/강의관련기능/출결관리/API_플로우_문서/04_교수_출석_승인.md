# 04. 교수 출석 승인

> 👨‍🏫 교수가 학생의 출석 요청을 승인하는 API 상세 가이드

---

## API 개요

### 기본 정보
- **엔드포인트**: `POST /api/attendance/approve`
- **권한**: 교수, 관리자
- **설명**: 교수가 담당 강의의 학생 출석 요청을 승인/지각/결석으로 처리하는 API

### 주요 기능
- ✅ 학생 출석 요청을 승인/지각/결석 처리
- ✅ 일괄 승인 (여러 학생 동시 처리 가능)
- ✅ 교수 권한 자동 검증 (LEC_PROF = professorIdx)
- ✅ pendingRequests → sessions 자동 이동
- ✅ 출석율 자동 재계산

---

## 요청 조건

### 필수 조건

1. **인증 토큰 필수**
   - JWT Bearer 토큰 필요
   - `professorIdx`는 토큰에서 자동 추출

2. **담당 강의만 가능**
   - 해당 교수가 담당하는 강의만 승인 가능
   - `LEC_PROF = professorIdx` 검증

3. **유효한 회차 및 학생**
   - sessionNumber: 1~80 범위
   - studentIdx: 실제 수강생이어야 함

### 제약 사항

1. **권한 검증**
   - 타 교수의 강의는 승인 불가
   - 403 Forbidden 응답

2. **중복 승인**
   - 이미 `sessions`에 존재하는 회차는 재승인 불가
   - 409 Conflict 응답 (프론트엔드에서 사전 필터링 권장)

3. **최소 1명 이상**
   - `attendanceRecords` 배열에 최소 1개 이상의 레코드 필요

---

## 요청 명세

### HTTP 요청

```http
POST /api/attendance/approve HTTP/1.1
Host: bluecrab.chickenkiller.com
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

{
  "lecSerial": "ETH201",
  "sessionNumber": 1,
  "attendanceRecords": [
    {
      "studentIdx": 6,
      "status": "출"
    },
    {
      "studentIdx": 7,
      "status": "지"
    },
    {
      "studentIdx": 8,
      "status": "결"
    }
  ]
}
```

### 요청 파라미터

| 필드 | 타입 | 필수 | 설명 | 제약 조건 |
|-----|------|------|------|----------|
| `lecSerial` | String | ✅ 필수 | 강의 코드 | 영문/숫자, 최대 20자 |
| `sessionNumber` | Integer | ✅ 필수 | 회차 번호 | 1~80 범위 |
| `attendanceRecords` | Array | ✅ 필수 | 승인 레코드 배열 | 최소 1개 이상 |
| `attendanceRecords[].studentIdx` | Integer | ✅ 필수 | 학생 USER_IDX | 양수 |
| `attendanceRecords[].status` | String | ✅ 필수 | 출석 상태 | "출", "지", "결" |

### 파라미터 상세

#### 1. lecSerial (강의 코드)
```json
"lecSerial": "ETH201"
```
- **형식**: 강의 코드 문자열
- **검증**:
  - 서버에서 `LEC_TBL` 존재 여부 확인
  - 교수의 담당 여부 확인 (`LEC_PROF = professorIdx`)

#### 2. sessionNumber (회차 번호)
```json
"sessionNumber": 1
```
- **형식**: 1~80 사이의 정수
- **의미**: 승인할 회차
- **검증**: `@Min(1)`, `@Max(80)` 어노테이션

#### 3. attendanceRecords (승인 레코드 배열)
```json
"attendanceRecords": [
  {
    "studentIdx": 6,
    "status": "출"
  }
]
```
- **형식**: 객체 배열
- **제약**: 최소 1개 이상 필요
- **일괄 처리**: 여러 학생을 한 번에 승인 가능

#### 4. studentIdx (학생 USER_IDX)
```json
"studentIdx": 6
```
- **형식**: 양의 정수
- **의미**: 승인할 학생의 USER_IDX
- **검증**:
  - 해당 강의의 수강생인지 확인
  - `ENROLLMENT_EXTENDED_TBL` 조회

#### 5. status (출석 상태)
```json
"status": "출"
```
- **형식**: "출", "지", "결" 중 하나
- **의미**:
  - **"출"**: 출석 (Attended)
  - **"지"**: 지각 (Late)
  - **"결"**: 결석 (Absent)
- **검증**: `@Pattern` 어노테이션으로 값 제한

---

## 응답 명세

### 성공 응답 (200 OK)

```json
{
  "success": true,
  "message": "출석 승인이 완료되었습니다. (3/3)",
  "data": null,
  "timestamp": "2025-10-23T15:45:00.123456789Z",
  "errorCode": null
}
```

### 응답 필드

| 필드 | 타입 | 설명 |
|-----|------|------|
| `success` | Boolean | 성공 여부 (항상 `true`) |
| `message` | String | 성공 메시지 (처리된 건수 포함) |
| `data` | null | 승인 API는 데이터 반환 없음 |
| `timestamp` | String | 응답 시각 (ISO 8601) |
| `errorCode` | null | 에러 코드 (성공 시 null) |

### 메시지 형식

```
출석 승인이 완료되었습니다. ({성공 건수}/{전체 건수})
```

**예시**:
- `"출석 승인이 완료되었습니다. (3/3)"` - 3명 모두 성공
- `"출석 승인이 완료되었습니다. (2/3)"` - 3명 중 2명 성공 (1명 실패)

**부분 성공 처리**:
- 일부 학생만 성공해도 200 OK 응답
- 실패한 학생은 로그에 기록 (프론트엔드에는 전달 안 함)
- 전체 실패 시에만 에러 응답

---

## 처리 흐름

### 1. 요청 수신 및 검증

```java
@PostMapping("/approve")
public ResponseEntity<?> approveAttendance(
    @Valid @RequestBody AttendanceApproveRequestDto request,
    @AuthenticationPrincipal UserDetails userDetails
) {
    // 1. JWT에서 professorIdx 추출
    Integer professorIdx = extractUserIdFromToken(userDetails);
    
    // 2. 요청 데이터 검증
    // - lecSerial 존재 여부
    // - sessionNumber 범위 (1~80)
    // - attendanceRecords 최소 1개 이상
    // - status 값 ("출", "지", "결")
    
    // 3. Service 호출
    int successCount = attendanceService.approveAttendance(
        professorIdx,
        request.getLecSerial(),
        request.getSessionNumber(),
        request.getAttendanceRecords()
    );
    
    int totalCount = request.getAttendanceRecords().size();
    String message = String.format(
        "출석 승인이 완료되었습니다. (%d/%d)", 
        successCount, 
        totalCount
    );
    
    return ResponseEntity.ok(
        AttendanceResponseDto.success(message, null)
    );
}
```

### 2. 교수 권한 검증

```java
// Repository 쿼리 (LEC_PROF = professorIdx)
Optional<EnrollmentExtendedTbl> enrollment = 
    enrollmentRepository.findByLecSerialAndProfessorIdx(
        lecSerial, 
        professorIdx
    );

if (!enrollment.isPresent()) {
    throw new ForbiddenException("해당 강의의 담당 교수가 아닙니다.");
}
```

**Repository 쿼리**:
```java
@Query("SELECT e FROM EnrollmentExtendedTbl e " +
       "WHERE e.lecTbl.lecSerial = :lecSerial " +
       "AND e.lecTbl.lecProf = CAST(:professorIdx AS string)")
Optional<EnrollmentExtendedTbl> findByLecSerialAndProfessorIdx(
    @Param("lecSerial") String lecSerial, 
    @Param("professorIdx") Integer professorIdx
);
```

**검증 흐름**:
1. JWT 토큰에서 `professorIdx` 추출 (예: `25`)
2. `LEC_TBL`에서 `lecSerial` 조회
3. `LEC_PROF` 필드와 `CAST(professorIdx AS string)` 비교
   - `LEC_PROF = '25'` (문자열)
   - `CAST(25 AS string) = '25'` ✅
4. 일치하면 권한 확인 완료, 불일치하면 403 Forbidden

### 3. 각 학생별 처리 (반복)

```java
int successCount = 0;

for (AttendanceApprovalRecordDto record : attendanceRecords) {
    try {
        // 1. 해당 학생의 ENROLLMENT_DATA 조회
        EnrollmentExtendedTbl studentEnrollment = 
            enrollmentRepository.findByLecSerialAndStudentIdx(
                lecSerial, 
                record.getStudentIdx()
            ).orElseThrow(() -> 
                new NotFoundException("수강생을 찾을 수 없습니다.")
            );
        
        // 2. JSON 파싱
        AttendanceDataDto attendanceData = 
            parseAttendanceData(studentEnrollment.getEnrollmentData());
        
        // 3. pendingRequests에서 해당 회차 찾기
        Optional<AttendancePendingRequestDto> pendingRequest = 
            attendanceData.getPendingRequests().stream()
                .filter(r -> r.getSessionNumber() == sessionNumber)
                .findFirst();
        
        if (!pendingRequest.isPresent()) {
            log.warn("대기 중인 요청이 없습니다: studentIdx={}, session={}", 
                     record.getStudentIdx(), sessionNumber);
            continue; // 다음 학생으로
        }
        
        // 4. sessions로 이동
        AttendanceSessionDto session = AttendanceSessionDto.builder()
            .sessionNumber(sessionNumber)
            .status(record.getStatus()) // "출", "지", "결"
            .requestDate(pendingRequest.get().getRequestDate())
            .approvedDate(LocalDateTime.now())
            .approvedBy(professorIdx)
            .tempApproved(false) // 교수가 수동 승인
            .build();
        
        attendanceData.getSessions().add(session);
        
        // 5. pendingRequests에서 제거
        attendanceData.getPendingRequests().remove(pendingRequest.get());
        
        // 6. summary 재계산
        recalculateSummary(attendanceData);
        
        // 7. JSON 직렬화 및 저장
        String updatedJson = objectMapper.writeValueAsString(attendanceData);
        studentEnrollment.setEnrollmentData(updatedJson);
        enrollmentRepository.save(studentEnrollment);
        
        successCount++;
        
    } catch (Exception e) {
        log.error("출석 승인 실패: studentIdx={}", 
                  record.getStudentIdx(), e);
        // 계속 진행 (부분 성공 허용)
    }
}

return successCount;
```

### 4. summary 재계산

```java
private void recalculateSummary(AttendanceDataDto attendanceData) {
    int attended = 0;
    int late = 0;
    int absent = 0;
    
    // sessions 배열 순회하며 카운트
    for (AttendanceSessionDto session : attendanceData.getSessions()) {
        switch (session.getStatus()) {
            case "출": attended++; break;
            case "지": late++; break;
            case "결": absent++; break;
        }
    }
    
    // totalSessions = sessions + pendingRequests
    int totalSessions = attendanceData.getSessions().size() 
                      + attendanceData.getPendingRequests().size();
    
    // 출석율 계산
    double attendanceRate = totalSessions > 0 
        ? (attended * 100.0) / totalSessions 
        : 0.0;
    
    // summary 업데이트
    AttendanceSummaryDto summary = attendanceData.getSummary();
    summary.setAttended(attended);
    summary.setLate(late);
    summary.setAbsent(absent);
    summary.setTotalSessions(totalSessions);
    summary.setAttendanceRate(attendanceRate);
    summary.setUpdatedAt(LocalDateTime.now());
}
```

---

## 에러 케이스

### 1. 인증 실패 (401)

**원인**: JWT 토큰 없음 또는 만료

```json
{
  "success": false,
  "message": "인증이 필요합니다.",
  "errorCode": "UNAUTHORIZED"
}
```

### 2. 담당 교수 아님 (403)

**원인**: 교수가 해당 강의의 담당 교수가 아님

```json
{
  "success": false,
  "message": "해당 강의의 담당 교수가 아닙니다.",
  "errorCode": "FORBIDDEN"
}
```

### 3. 유효하지 않은 회차 (400)

**원인**: sessionNumber가 1~80 범위를 벗어남

```json
{
  "success": false,
  "message": "회차 번호는 1에서 80 사이여야 합니다.",
  "errorCode": "VALIDATION_ERROR"
}
```

### 4. 유효하지 않은 상태 (400)

**원인**: status가 "출", "지", "결"이 아님

```json
{
  "success": false,
  "message": "출석 상태는 '출', '지', '결' 중 하나여야 합니다.",
  "errorCode": "VALIDATION_ERROR"
}
```

### 5. 수강생을 찾을 수 없음 (404)

**원인**: studentIdx에 해당하는 수강생이 없음

```json
{
  "success": false,
  "message": "수강생을 찾을 수 없습니다.",
  "errorCode": "NOT_FOUND"
}
```

### 6. 강의를 찾을 수 없음 (404)

**원인**: lecSerial이 DB에 존재하지 않음

```json
{
  "success": false,
  "message": "해당 강의를 찾을 수 없습니다.",
  "errorCode": "NOT_FOUND"
}
```

### 7. 빈 승인 레코드 (400)

**원인**: attendanceRecords 배열이 비어있음

```json
{
  "success": false,
  "message": "최소 1명 이상의 학생을 선택해야 합니다.",
  "errorCode": "VALIDATION_ERROR"
}
```

---

## 사용 예시

### JavaScript (브라우저)

```javascript
async function approveAttendance(lecSerial, sessionNumber, students) {
    const token = window.authToken || 
                  localStorage.getItem('accessToken');
    
    // students: [{ studentIdx: 6, status: "출" }, ...]
    const response = await fetch(
        'https://bluecrab.chickenkiller.com/BlueCrab-1.0.0/api/attendance/approve',
        {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
                lecSerial: lecSerial,
                sessionNumber: sessionNumber,
                attendanceRecords: students
            })
        }
    );
    
    const data = await response.json();
    
    if (data.success) {
        console.log('✅ 출석 승인 완료:', data.message);
    } else {
        console.error('❌ 출석 승인 실패:', data.message);
    }
    
    return data;
}

// 사용 예
approveAttendance('ETH201', 1, [
    { studentIdx: 6, status: '출' },
    { studentIdx: 7, status: '지' },
    { studentIdx: 8, status: '결' }
]);
```

### React 예시

```jsx
import { useState, useEffect } from 'react';

function AttendanceApprovalPage({ lecSerial, sessionNumber }) {
    const [students, setStudents] = useState([]);
    const [selectedStudents, setSelectedStudents] = useState([]);
    const [loading, setLoading] = useState(false);
    
    // 대기 중인 학생 목록 가져오기
    useEffect(() => {
        fetchPendingStudents();
    }, [lecSerial, sessionNumber]);
    
    const fetchPendingStudents = async () => {
        // 교수 출석 조회 API 호출
        const response = await fetch('/api/attendance/professor/view', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${getToken()}`
            },
            body: JSON.stringify({ lecSerial })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // sessionNumber에 대기 중인 요청이 있는 학생만 필터링
            const pending = data.data.filter(student => 
                student.attendanceData.pendingRequests.some(
                    req => req.sessionNumber === sessionNumber
                )
            );
            setStudents(pending);
        }
    };
    
    const handleApprove = async () => {
        if (selectedStudents.length === 0) {
            alert('최소 1명 이상 선택해야 합니다.');
            return;
        }
        
        setLoading(true);
        
        try {
            const response = await fetch('/api/attendance/approve', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${getToken()}`
                },
                body: JSON.stringify({
                    lecSerial,
                    sessionNumber,
                    attendanceRecords: selectedStudents
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                alert(data.message);
                fetchPendingStudents(); // 목록 새로고침
                setSelectedStudents([]);
            } else {
                alert('오류: ' + data.message);
            }
        } catch (error) {
            alert('네트워크 오류: ' + error.message);
        } finally {
            setLoading(false);
        }
    };
    
    const handleStatusChange = (studentIdx, status) => {
        setSelectedStudents(prev => {
            const exists = prev.find(s => s.studentIdx === studentIdx);
            if (exists) {
                return prev.map(s => 
                    s.studentIdx === studentIdx 
                        ? { ...s, status } 
                        : s
                );
            } else {
                return [...prev, { studentIdx, status }];
            }
        });
    };
    
    return (
        <div>
            <h2>{lecSerial} - {sessionNumber}회차 출석 승인</h2>
            
            <table>
                <thead>
                    <tr>
                        <th>학번</th>
                        <th>이름</th>
                        <th>요청일</th>
                        <th>사유</th>
                        <th>승인</th>
                    </tr>
                </thead>
                <tbody>
                    {students.map(student => {
                        const request = student.attendanceData.pendingRequests
                            .find(r => r.sessionNumber === sessionNumber);
                        
                        return (
                            <tr key={student.studentIdx}>
                                <td>{student.studentCode}</td>
                                <td>{student.studentName}</td>
                                <td>{request.requestDate}</td>
                                <td>{request.requestReason || '-'}</td>
                                <td>
                                    <select
                                        onChange={(e) => handleStatusChange(
                                            student.studentIdx, 
                                            e.target.value
                                        )}
                                        defaultValue=""
                                    >
                                        <option value="" disabled>선택</option>
                                        <option value="출">출석</option>
                                        <option value="지">지각</option>
                                        <option value="결">결석</option>
                                    </select>
                                </td>
                            </tr>
                        );
                    })}
                </tbody>
            </table>
            
            <button 
                onClick={handleApprove} 
                disabled={loading || selectedStudents.length === 0}
            >
                {loading ? '승인 중...' : `승인 (${selectedStudents.length}명)`}
            </button>
        </div>
    );
}
```

---

## 주의사항

### 프론트엔드 개발자

1. **대기 중인 요청만 표시**
   - 교수 출석 조회 API로 `pendingRequests`가 있는 학생만 필터링
   - 이미 `sessions`에 있는 회차는 재승인 불가

2. **일괄 승인 UX**
   - 체크박스로 여러 학생 선택
   - "전체 출석", "전체 지각", "전체 결석" 버튼 제공

3. **부분 성공 처리**
   - 응답 메시지에서 "(2/3)" 형식 파싱
   - 일부 실패 시 경고 메시지 표시

### 백엔드 개발자

1. **트랜잭션 범위**
   - 각 학생별로 독립적인 트랜잭션 처리
   - 한 학생 실패 시 다른 학생은 계속 처리

2. **예외 처리**
   - 부분 실패는 로그만 남기고 계속 진행
   - 전체 실패 시에만 에러 응답

3. **성능 최적화**
   - Batch 처리 고려 (대량 승인 시)
   - JSON 파싱 캐싱

---

## 다음 단계

- **[05. 교수 권한 검증](./05_교수_권한_검증.md)**: LEC_PROF 검증 로직 상세
- **[07. 데이터 구조](./07_데이터_구조.md)**: sessions, pendingRequests 구조
- **[08. 시퀀스 다이어그램](./08_시퀀스_다이어그램.md)**: 전체 흐름 시각화

---

**📚 [목차로 돌아가기](./README.md)**
