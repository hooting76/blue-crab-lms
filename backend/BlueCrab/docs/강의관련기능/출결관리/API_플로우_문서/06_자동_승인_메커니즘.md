# 06. 자동 승인 메커니즘

> ⏰ 7일 경과 시 학생 출석 요청을 자동으로 승인하는 스케줄러 시스템

---

## 개요

### 목적

교수가 7일 동안 승인하지 않은 학생의 출석 요청을 **자동으로 "출석"으로 승인**하는 메커니즘입니다.

### 핵심 원리

```
expiresAt ≤ 현재 날짜 → 자동 승인
```

- **expiresAt**: 요청일 + 7일 (시간은 00:00:00으로 정규화)
- **현재 날짜**: 스케줄러 실행 시점 (날짜만 비교, 시간 무시)

### 주요 특징

- ✅ **날짜 기반 비교**: 시간은 무시하고 날짜만 비교
- ✅ **자동 "출석" 처리**: status = "출"로 고정
- ✅ **tempApproved 플래그**: 교수 승인(false)과 구분(true)
- ✅ **매일 자정 실행**: 00:00:00에 스케줄러 작동
- ✅ **일괄 처리**: 모든 강의의 모든 학생 일괄 확인

---

## expiresAt 계산

### 요청 시점 계산

```java
// 학생이 출석 요청을 보낼 때
LocalDateTime requestDate = LocalDateTime.now();
// 예: 2025-10-23T14:30:15

LocalDateTime expiresAt = requestDate
    .plusDays(7)              // 7일 추가
    .withHour(0)              // 시간 0시
    .withMinute(0)            // 분 0분
    .withSecond(0)            // 초 0초
    .withNano(0);             // 나노초 0

// 결과: 2025-10-30T00:00:00
```

### 예시

| 요청 일시 | expiresAt | 설명 |
|----------|-----------|------|
| 2025-10-23T14:30:15 | 2025-10-30T00:00:00 | 7일 후 자정 |
| 2025-10-23T23:59:59 | 2025-10-30T00:00:00 | 같은 날이어도 동일 |
| 2025-10-23T00:00:01 | 2025-10-30T00:00:00 | 시간 무관 |

### 중요 포인트

#### 1. 시간 정규화

```java
.withHour(0).withMinute(0).withSecond(0).withNano(0)
```

- **목적**: 날짜만 비교하기 위해 시간 제거
- **효과**: 같은 날은 항상 같은 expiresAt

#### 2. 7일 추가

```java
.plusDays(7)
```

- **의미**: 요청일 + 7일
- **예시**: 10월 23일 요청 → 10월 30일 만료

---

## 스케줄러 구현

### AutoApprovalScheduler

```java
@Component
@Slf4j
public class AutoApprovalScheduler {
    
    @Autowired
    private EnrollmentExtendedRepository enrollmentRepository;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    // 매일 자정 00:00:00에 실행
    @Scheduled(cron = "0 0 0 * * *")
    public void autoApproveExpiredRequests() {
        log.info("========================================");
        log.info("자동 승인 스케줄러 시작: {}", LocalDateTime.now());
        log.info("========================================");
        
        try {
            // 1. 모든 수강생 조회
            List<EnrollmentExtendedTbl> allEnrollments = 
                enrollmentRepository.findAll();
            
            log.info("전체 수강생 수: {}", allEnrollments.size());
            
            int totalProcessed = 0;
            int totalApproved = 0;
            
            // 2. 각 수강생별 처리
            for (EnrollmentExtendedTbl enrollment : allEnrollments) {
                try {
                    int approvedCount = processEnrollment(enrollment);
                    if (approvedCount > 0) {
                        totalProcessed++;
                        totalApproved += approvedCount;
                    }
                } catch (Exception e) {
                    log.error("수강생 처리 실패: ENR_NO={}", 
                              enrollment.getEnrNo(), e);
                }
            }
            
            log.info("========================================");
            log.info("자동 승인 완료: 처리 학생={}, 승인 건수={}", 
                     totalProcessed, totalApproved);
            log.info("========================================");
            
        } catch (Exception e) {
            log.error("자동 승인 스케줄러 오류", e);
        }
    }
    
    private int processEnrollment(EnrollmentExtendedTbl enrollment) 
            throws Exception {
        
        String enrollmentData = enrollment.getEnrollmentData();
        
        if (enrollmentData == null || enrollmentData.isEmpty()) {
            return 0;
        }
        
        // JSON 파싱
        AttendanceDataDto attendanceData = 
            objectMapper.readValue(enrollmentData, AttendanceDataDto.class);
        
        List<AttendancePendingRequestDto> pendingRequests = 
            attendanceData.getPendingRequests();
        
        if (pendingRequests.isEmpty()) {
            return 0; // 대기 중인 요청 없음
        }
        
        // 만료된 요청 필터링
        LocalDate today = LocalDate.now();
        List<AttendancePendingRequestDto> expiredRequests = 
            pendingRequests.stream()
                .filter(req -> isExpired(req.getExpiresAt(), today))
                .collect(Collectors.toList());
        
        if (expiredRequests.isEmpty()) {
            return 0; // 만료된 요청 없음
        }
        
        log.info("만료된 요청 발견: ENR_NO={}, 강의={}, 학생={}, 건수={}", 
                 enrollment.getEnrNo(),
                 enrollment.getLecTbl().getLecSerial(),
                 enrollment.getUserTbl().getUserIdx(),
                 expiredRequests.size());
        
        // 만료된 요청 자동 승인
        for (AttendancePendingRequestDto request : expiredRequests) {
            autoApproveRequest(attendanceData, request);
        }
        
        // 만료된 요청 제거
        pendingRequests.removeAll(expiredRequests);
        
        // summary 재계산
        recalculateSummary(attendanceData);
        
        // JSON 직렬화 및 저장
        String updatedJson = objectMapper.writeValueAsString(attendanceData);
        enrollment.setEnrollmentData(updatedJson);
        enrollmentRepository.save(enrollment);
        
        return expiredRequests.size();
    }
    
    private boolean isExpired(LocalDateTime expiresAt, LocalDate today) {
        // 날짜만 비교 (시간 무시)
        LocalDate expiryDate = expiresAt.toLocalDate();
        return !expiryDate.isAfter(today); // expiryDate ≤ today
    }
    
    private void autoApproveRequest(
        AttendanceDataDto attendanceData,
        AttendancePendingRequestDto request
    ) {
        // sessions로 이동
        AttendanceSessionDto session = AttendanceSessionDto.builder()
            .sessionNumber(request.getSessionNumber())
            .status("출") // 자동 승인은 항상 "출석"
            .requestDate(request.getRequestDate())
            .approvedDate(LocalDateTime.now())
            .approvedBy(null) // 교수가 아닌 시스템 승인
            .tempApproved(true) // 자동 승인 플래그
            .build();
        
        attendanceData.getSessions().add(session);
    }
    
    private void recalculateSummary(AttendanceDataDto attendanceData) {
        int attended = 0;
        int late = 0;
        int absent = 0;
        
        for (AttendanceSessionDto session : attendanceData.getSessions()) {
            switch (session.getStatus()) {
                case "출": attended++; break;
                case "지": late++; break;
                case "결": absent++; break;
            }
        }
        
        int totalSessions = attendanceData.getSessions().size() 
                          + attendanceData.getPendingRequests().size();
        
        double attendanceRate = totalSessions > 0 
            ? (attended * 100.0) / totalSessions 
            : 0.0;
        
        AttendanceSummaryDto summary = attendanceData.getSummary();
        summary.setAttended(attended);
        summary.setLate(late);
        summary.setAbsent(absent);
        summary.setTotalSessions(totalSessions);
        summary.setAttendanceRate(attendanceRate);
        summary.setUpdatedAt(LocalDateTime.now());
    }
}
```

---

## 날짜 비교 로직

### isExpired 메서드

```java
private boolean isExpired(LocalDateTime expiresAt, LocalDate today) {
    // 1. expiresAt에서 날짜만 추출
    LocalDate expiryDate = expiresAt.toLocalDate();
    // 예: 2025-10-30T00:00:00 → 2025-10-30
    
    // 2. 날짜 비교 (시간 무시)
    return !expiryDate.isAfter(today);
    // expiryDate ≤ today → true (만료됨)
    // expiryDate > today → false (아직 유효)
}
```

### 비교 예시

| expiresAt | today | expiryDate | isAfter? | isExpired? | 결과 |
|----------|-------|------------|---------|-----------|------|
| 2025-10-30T00:00:00 | 2025-10-29 | 2025-10-30 | true | false | 아직 유효 |
| 2025-10-30T00:00:00 | 2025-10-30 | 2025-10-30 | false | true | ✅ 만료 |
| 2025-10-30T00:00:00 | 2025-10-31 | 2025-10-30 | false | true | ✅ 만료 |
| 2025-10-30T00:00:00 | 2025-11-01 | 2025-10-30 | false | true | ✅ 만료 |

### 핵심 로직

```java
!expiryDate.isAfter(today)
```

**분해**:
- `expiryDate.isAfter(today)`: expiryDate > today
- `!`: 부정 (NOT)
- 결과: `expiryDate ≤ today`

**의미**:
- 만료일이 오늘 이전이거나 오늘이면 → 만료됨 (true)
- 만료일이 오늘 이후면 → 아직 유효 (false)

---

## 실행 시나리오

### 시나리오 1: 정상 자동 승인

#### 초기 상태 (10월 23일)

**학생 A의 pendingRequests**:
```json
{
  "pendingRequests": [
    {
      "sessionNumber": 1,
      "requestDate": "2025-10-16T14:30:00",
      "expiresAt": "2025-10-23T00:00:00",
      "requestReason": "병원 진료"
    }
  ],
  "sessions": []
}
```

#### 스케줄러 실행 (10월 23일 00:00:00)

1. **날짜 비교**
   ```java
   expiryDate = 2025-10-23
   today = 2025-10-23
   
   expiryDate.isAfter(today)? → false
   !false → true (만료됨)
   ```

2. **자동 승인**
   ```json
   {
     "sessionNumber": 1,
     "status": "출",
     "requestDate": "2025-10-16T14:30:00",
     "approvedDate": "2025-10-23T00:00:00",
     "approvedBy": null,
     "tempApproved": true
   }
   ```

3. **최종 상태**
   ```json
   {
     "pendingRequests": [],
     "sessions": [
       {
         "sessionNumber": 1,
         "status": "출",
         "requestDate": "2025-10-16T14:30:00",
         "approvedDate": "2025-10-23T00:00:00",
         "approvedBy": null,
         "tempApproved": true
       }
     ],
     "summary": {
       "attended": 1,
       "late": 0,
       "absent": 0,
       "totalSessions": 1,
       "attendanceRate": 100.0
     }
   }
   ```

### 시나리오 2: 부분 자동 승인

#### 초기 상태 (10월 25일)

**학생 B의 pendingRequests**:
```json
{
  "pendingRequests": [
    {
      "sessionNumber": 1,
      "requestDate": "2025-10-18T10:00:00",
      "expiresAt": "2025-10-25T00:00:00",
      "requestReason": null
    },
    {
      "sessionNumber": 2,
      "requestDate": "2025-10-23T15:00:00",
      "expiresAt": "2025-10-30T00:00:00",
      "requestReason": "가족 행사"
    }
  ],
  "sessions": []
}
```

#### 스케줄러 실행 (10월 25일 00:00:00)

1. **회차 1 검사**
   ```java
   expiryDate = 2025-10-25
   today = 2025-10-25
   isExpired? → true ✅ (자동 승인)
   ```

2. **회차 2 검사**
   ```java
   expiryDate = 2025-10-30
   today = 2025-10-25
   isExpired? → false ❌ (아직 유효)
   ```

3. **최종 상태**
   ```json
   {
     "pendingRequests": [
       {
         "sessionNumber": 2,
         "requestDate": "2025-10-23T15:00:00",
         "expiresAt": "2025-10-30T00:00:00",
         "requestReason": "가족 행사"
       }
     ],
     "sessions": [
       {
         "sessionNumber": 1,
         "status": "출",
         "requestDate": "2025-10-18T10:00:00",
         "approvedDate": "2025-10-25T00:00:00",
         "approvedBy": null,
         "tempApproved": true
       }
     ],
     "summary": {
       "attended": 1,
       "late": 0,
       "absent": 0,
       "totalSessions": 2,
       "attendanceRate": 50.0
     }
   }
   ```

### 시나리오 3: 교수 승인 후 자동 승인 없음

#### 초기 상태 (10월 20일)

**학생 C의 pendingRequests**:
```json
{
  "pendingRequests": [
    {
      "sessionNumber": 1,
      "requestDate": "2025-10-16T09:00:00",
      "expiresAt": "2025-10-23T00:00:00",
      "requestReason": null
    }
  ],
  "sessions": []
}
```

#### 교수 승인 (10월 20일 14:00:00)

교수가 수동으로 "지각" 승인:
```json
{
  "pendingRequests": [],
  "sessions": [
    {
      "sessionNumber": 1,
      "status": "지",
      "requestDate": "2025-10-16T09:00:00",
      "approvedDate": "2025-10-20T14:00:00",
      "approvedBy": 25,
      "tempApproved": false
    }
  ]
}
```

#### 스케줄러 실행 (10월 23일 00:00:00)

- `pendingRequests`가 비어있음 → 처리할 요청 없음
- 교수가 이미 승인한 데이터는 유지

---

## tempApproved 플래그

### 목적

교수의 수동 승인과 시스템의 자동 승인을 구분하기 위한 플래그입니다.

### 값의 의미

| tempApproved | 의미 | approvedBy | status |
|--------------|------|-----------|--------|
| `false` | 교수 수동 승인 | professorIdx (예: 25) | "출", "지", "결" |
| `true` | 시스템 자동 승인 | null | "출" (고정) |

### 사용 예시

#### 1. 교수 수동 승인

```json
{
  "sessionNumber": 1,
  "status": "지",
  "requestDate": "2025-10-16T14:30:00",
  "approvedDate": "2025-10-20T10:00:00",
  "approvedBy": 25,
  "tempApproved": false
}
```

- **해석**: 교수 25가 10월 20일에 "지각"으로 승인

#### 2. 시스템 자동 승인

```json
{
  "sessionNumber": 1,
  "status": "출",
  "requestDate": "2025-10-16T14:30:00",
  "approvedDate": "2025-10-23T00:00:00",
  "approvedBy": null,
  "tempApproved": true
}
```

- **해석**: 시스템이 10월 23일에 자동으로 "출석" 승인

### 프론트엔드 표시

```jsx
function AttendanceStatusBadge({ session }) {
    if (session.tempApproved) {
        return (
            <span className="badge badge-warning">
                자동 승인 (출석)
            </span>
        );
    } else {
        const statusLabel = {
            '출': '출석',
            '지': '지각',
            '결': '결석'
        };
        
        return (
            <span className="badge badge-success">
                교수 승인 ({statusLabel[session.status]})
            </span>
        );
    }
}
```

---

## 스케줄러 설정

### Cron 표현식

```java
@Scheduled(cron = "0 0 0 * * *")
```

**의미**:
```
초 분 시 일 월 요일
0  0  0  *  *  *

초: 0초
분: 0분
시: 0시 (자정)
일: 매일
월: 매월
요일: 매주 모든 요일
```

**결과**: 매일 자정 00:00:00에 실행

### 다른 Cron 예시

```java
// 매일 오전 1시
@Scheduled(cron = "0 0 1 * * *")

// 매주 월요일 자정
@Scheduled(cron = "0 0 0 * * MON")

// 매월 1일 자정
@Scheduled(cron = "0 0 0 1 * *")

// 30분마다
@Scheduled(cron = "0 */30 * * * *")
```

### 스케줄러 활성화

```java
@Configuration
@EnableScheduling
public class SchedulerConfig {
    // 스케줄러 활성화
}
```

---

## 로그 출력

### 실행 로그 예시

```
2025-10-23 00:00:00.001 [pool-1-thread-1] INFO  AutoApprovalScheduler
========================================
자동 승인 스케줄러 시작: 2025-10-23T00:00:00.001
========================================

2025-10-23 00:00:00.123 [pool-1-thread-1] INFO  AutoApprovalScheduler
전체 수강생 수: 150

2025-10-23 00:00:00.234 [pool-1-thread-1] INFO  AutoApprovalScheduler
만료된 요청 발견: ENR_NO=1, 강의=ETH201, 학생=6, 건수=1

2025-10-23 00:00:00.245 [pool-1-thread-1] INFO  AutoApprovalScheduler
만료된 요청 발견: ENR_NO=5, 강의=ETH201, 학생=7, 건수=2

2025-10-23 00:00:00.789 [pool-1-thread-1] INFO  AutoApprovalScheduler
========================================
자동 승인 완료: 처리 학생=2, 승인 건수=3
========================================
```

### 로그 레벨 설정

```properties
# application.properties
logging.level.com.bluecrab.scheduler=INFO
logging.level.com.bluecrab.scheduler.AutoApprovalScheduler=DEBUG
```

---

## 성능 최적화

### 1. 배치 처리

```java
@Transactional
public void autoApproveExpiredRequests() {
    // 모든 수강생 한 번에 조회
    List<EnrollmentExtendedTbl> allEnrollments = 
        enrollmentRepository.findAll();
    
    // 메모리에서 일괄 처리
    List<EnrollmentExtendedTbl> updatedEnrollments = 
        new ArrayList<>();
    
    for (EnrollmentExtendedTbl enrollment : allEnrollments) {
        if (processEnrollment(enrollment) > 0) {
            updatedEnrollments.add(enrollment);
        }
    }
    
    // 한 번에 저장
    enrollmentRepository.saveAll(updatedEnrollments);
}
```

### 2. 쿼리 최적화

```java
// 만료된 요청이 있는 수강생만 조회
@Query("SELECT e FROM EnrollmentExtendedTbl e " +
       "WHERE e.enrollmentData LIKE '%expiresAt%' " +
       "AND e.enrollmentData LIKE '%pendingRequests%'")
List<EnrollmentExtendedTbl> findEnrollmentsWithPendingRequests();
```

### 3. 비동기 처리

```java
@Async
@Scheduled(cron = "0 0 0 * * *")
public void autoApproveExpiredRequests() {
    // 비동기 실행 (메인 스레드 블록 방지)
}
```

---

## 예외 처리

### try-catch 구조

```java
for (EnrollmentExtendedTbl enrollment : allEnrollments) {
    try {
        int approvedCount = processEnrollment(enrollment);
        if (approvedCount > 0) {
            totalProcessed++;
            totalApproved += approvedCount;
        }
    } catch (Exception e) {
        // 한 학생 실패해도 다른 학생 계속 처리
        log.error("수강생 처리 실패: ENR_NO={}", 
                  enrollment.getEnrNo(), e);
    }
}
```

**원칙**:
- 한 학생의 처리 실패가 전체 스케줄러를 중단시키지 않음
- 실패한 학생은 로그에 기록 후 다음 학생 처리
- 다음 날 스케줄러 실행 시 재시도

---

## 테스트

### 수동 테스트 (개발 환경)

```java
@SpringBootTest
public class AutoApprovalSchedulerTest {
    
    @Autowired
    private AutoApprovalScheduler scheduler;
    
    @Test
    public void testAutoApproval() {
        // 스케줄러 수동 실행
        scheduler.autoApproveExpiredRequests();
        
        // 결과 확인
        // 로그 출력 확인
    }
}
```

### Cron 표현식 테스트

```java
@Test
public void testCronExpression() {
    CronExpression cron = new CronExpression("0 0 0 * * *");
    
    LocalDateTime now = LocalDateTime.of(2025, 10, 23, 0, 0, 0);
    LocalDateTime next = cron.next(now);
    
    assertEquals(LocalDateTime.of(2025, 10, 24, 0, 0, 0), next);
}
```

---

## 주의사항

### 백엔드 개발자

1. **날짜만 비교**
   - 시간은 무시하고 날짜만 비교
   - `toLocalDate()`로 날짜 추출

2. **트랜잭션 범위**
   - 전체 스케줄러를 하나의 트랜잭션으로 처리
   - 또는 각 학생별로 독립 트랜잭션

3. **예외 처리**
   - 한 학생 실패 시 다른 학생 계속 처리
   - 실패 로그 명확히 기록

4. **성능**
   - 수강생 수가 많을 경우 배치 처리
   - 비동기 실행 고려

### 프론트엔드 개발자

1. **tempApproved 표시**
   - 자동 승인과 교수 승인 구분 표시
   - UI에서 "자동 승인" 배지 추가

2. **출석율 업데이트**
   - 자정 이후 출석율 변경 가능
   - 페이지 새로고침 유도

---

## 다음 단계

- **[03. 학생 출석 요청](./03_학생_출석_요청.md)**: expiresAt 계산 로직
- **[04. 교수 출석 승인](./04_교수_출석_승인.md)**: 교수 수동 승인 vs 자동 승인
- **[07. 데이터 구조](./07_데이터_구조.md)**: pendingRequests, sessions 구조

---

**📚 [목차로 돌아가기](./README.md)**
