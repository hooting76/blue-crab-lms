# 📊 Blue Crab LMS 성적 관리 시스템 구현 가이드

> **작성일**: 2025-10-18  
> **목적**: JSON 기반 성적 관리 시스템 구현 및 개발 가이드  
> **대상**: 백엔드 개발자

---

## 📋 개요

Blue Crab LMS의 성적 관리 시스템은 **ENROLLMENT_EXTENDED_TBL의 ENROLLMENT_DATA (JSON 컬럼)**을 활용하여 유연하고 확장 가능한 성적 관리를 제공합니다.

### 🎯 설계 원칙
1. **JSON 기반 저장**: 유연한 데이터 구조로 확장성 확보
2. **이벤트 기반 자동 계산**: 출석, 과제 점수 변경 시 자동 집계
3. **POST 방식 통일**: 기존 시스템과의 일관성 유지
4. **백분위 등급 배정**: 상대평가 기준 등급 산출

---

## 🗃️ 데이터 구조

### ENROLLMENT_DATA JSON 스키마

```json
{
  "grade": {
    "attendance": {
      "maxScore": 20,
      "currentScore": 18.5,
      "rate": 92.5
    },
    "assignments": [
      {
        "name": "과제1",
        "score": 9,
        "maxScore": 10
      },
      {
        "name": "중간고사",
        "score": 85,
        "maxScore": 100
      },
      {
        "name": "기말고사",
        "score": 92,
        "maxScore": 100
      }
    ],
    "total": {
      "score": 204.5,
      "maxScore": 230,
      "percentage": 88.9
    },
    "letterGrade": "A"
  }
}
```

### 데이터 구성 요소

| 구분 | 설명 | 계산 방식 |
|------|------|-----------|
| **출석 점수** | 출석율 기반 자동 계산 | `출석율 × 지정 만점` |
| **과제 점수** | 개별 과제별 점수 관리 | `ASSIGNMENT_TBL`에서 집계 |
| **중간/기말고사** | 과제의 특수 형태 | 과제명으로 구분 |
| **합계 점수** | 전체 점수 총합 | 이벤트 기반 자동 계산 |
| **등급** | 백분위 기준 등급 | A, B, C, D, F |

---

## 🔧 API 설계

### 1. 성적 구성 설정

**엔드포인트**: `POST /api/enrollments/grade-config`

```javascript
// 요청 예시
{
  "lecIdx": 1,
  "attendanceMaxScore": 20,
  "assignmentTotalScore": 50,
  "examTotalScore": 30,
  "gradeDistribution": {
    "A": 30,  // 상위 30%
    "B": 40,  // 30~70%
    "C": 20,  // 70~90%
    "D": 10   // 나머지
  },
  "action": "set-config"
}

// 응답 예시
{
  "success": true,
  "message": "성적 구성이 설정되었습니다.",
  "data": {
    "lecIdx": 1,
    "gradeConfig": { ... }
  }
}
```

### 2. 개별 성적 조회

**엔드포인트**: `POST /api/enrollments/grade-info`

```javascript
// 요청 예시 (학생 본인 조회)
{
  "lecIdx": 1,
  "studentIdx": 100,
  "action": "get-grade"
}

// 요청 예시 (교수용 조회)
{
  "lecIdx": 1,
  "studentIdx": 100,
  "professorIdx": 22,
  "action": "professor-view"
}

// 응답 예시
{
  "success": true,
  "data": {
    "studentInfo": {
      "studentIdx": 100,
      "studentName": "홍길동",
      "studentId": "STU001"
    },
    "grade": {
      "attendance": {
        "maxScore": 20,
        "currentScore": 18.5,
        "rate": 92.5
      },
      "assignments": [ ... ],
      "total": {
        "score": 204.5,
        "maxScore": 230,
        "percentage": 88.9
      },
      "letterGrade": "A",
      "rank": 3,
      "totalStudents": 45
    }
  }
}
```

### 3. 전체 수강생 성적 목록

**엔드포인트**: `POST /api/enrollments/grade-list`

```javascript
// 요청 예시
{
  "lecIdx": 1,
  "page": 0,
  "size": 20,
  "sortBy": "percentage",  // percentage, name, studentId
  "sortOrder": "desc",     // asc, desc
  "action": "list-all"
}

// 응답 예시
{
  "success": true,
  "data": {
    "content": [
      {
        "studentIdx": 100,
        "studentName": "홍길동",
        "studentId": "STU001",
        "attendance": { ... },
        "assignments": [ ... ],
        "total": { ... },
        "letterGrade": "A",
        "rank": 1
      }
    ],
    "totalElements": 45,
    "totalPages": 3,
    "currentPage": 0
  }
}
```

### 4. 최종 등급 배정

**엔드포인트**: `POST /api/enrollments/grade-finalize`

```javascript
// 요청 예시
{
  "lecIdx": 1,
  "passingThreshold": 60,  // 합격 기준 (60%)
  "gradeDistribution": {
    "A": 30,  // 합격자 중 상위 30%
    "B": 40,  // 합격자 중 30~70%
    "C": 20,  // 합격자 중 70~90%
    "D": 10   // 합격자 중 나머지 10%
  },
  "action": "finalize"
}

// 응답 예시
{
  "success": true,
  "message": "최종 등급이 배정되었습니다.",
  "data": {
    "gradeStats": {
      "A": 2,   // 2명 (합격자 중 상위)
      "B": 0,   // 0명
      "C": 0,   // 0명  
      "D": 0,   // 0명
      "F": 18   // 18명 (60% 미만 + 중도포기)
    },
    "totalStudents": 20,
    "passingStudents": 2,    // 합격자 수
    "failingStudents": 18,   // 낙제자 수
    "averageScore": 45.2     // 전체 평균
  }
}
```

---

## 🏗️ 백엔드 구현

### EnrollmentController 확장

```java
@RestController
@RequestMapping("/api/enrollments")
public class EnrollmentController {

    @Autowired
    private EnrollmentService enrollmentService;

    @PostMapping("/grade-config")
    public ResponseEntity<?> setGradeConfig(@RequestBody Map<String, Object> request) {
        try {
            String action = (String) request.get("action");
            
            if ("set-config".equals(action)) {
                return handleGradeConfig(request);
            }
            
            return ResponseEntity.badRequest()
                .body(createErrorResponse("지원하지 않는 액션입니다."));
                
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(createErrorResponse("성적 구성 설정 중 오류가 발생했습니다."));
        }
    }

    @PostMapping("/grade-info")
    public ResponseEntity<?> getGradeInfo(@RequestBody Map<String, Object> request) {
        try {
            String action = (String) request.get("action");
            
            switch (action) {
                case "get-grade":
                    return handleStudentGradeInfo(request);
                case "professor-view":
                    return handleProfessorGradeView(request);
                default:
                    return ResponseEntity.badRequest()
                        .body(createErrorResponse("지원하지 않는 액션입니다."));
            }
            
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(createErrorResponse("성적 조회 중 오류가 발생했습니다."));
        }
    }

    @PostMapping("/grade-list")
    public ResponseEntity<?> getGradeList(@RequestBody Map<String, Object> request) {
        try {
            String action = (String) request.get("action");
            
            if ("list-all".equals(action)) {
                return handleGradeList(request);
            }
            
            return ResponseEntity.badRequest()
                .body(createErrorResponse("지원하지 않는 액션입니다."));
                
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(createErrorResponse("성적 목록 조회 중 오류가 발생했습니다."));
        }
    }

    @PostMapping("/grade-finalize")
    public ResponseEntity<?> finalizeGrades(@RequestBody Map<String, Object> request) {
        try {
            String action = (String) request.get("action");
            
            if ("finalize".equals(action)) {
                return handleGradeFinalize(request);
            }
            
            return ResponseEntity.badRequest()
                .body(createErrorResponse("지원하지 않는 액션입니다."));
                
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(createErrorResponse("등급 배정 중 오류가 발생했습니다."));
        }
    }
}
```

### EnrollmentService 구현

```java
@Service
@Transactional
public class EnrollmentService {

    @Autowired
    private EnrollmentExtendedRepository enrollmentExtendedRepository;
    
    @Autowired
    private AttendanceRepository attendanceRepository;
    
    @Autowired
    private AssignmentRepository assignmentRepository;

    /**
     * 성적 구성 설정
     */
    public ResponseEntity<?> setGradeConfig(Map<String, Object> request) {
        Integer lecIdx = (Integer) request.get("lecIdx");
        
        // 강의별 성적 구성 설정 로직
        // ENROLLMENT_DATA JSON 업데이트
        
        return ResponseEntity.ok(createSuccessResponse("성적 구성이 설정되었습니다."));
    }

    /**
     * 개별 학생 성적 계산 및 조회
     */
    public ResponseEntity<?> getStudentGradeInfo(Map<String, Object> request) {
        Integer lecIdx = (Integer) request.get("lecIdx");
        Integer studentIdx = (Integer) request.get("studentIdx");
        
        // 1. 출석 점수 계산
        Double attendanceScore = calculateAttendanceScore(lecIdx, studentIdx);
        
        // 2. 과제 점수 집계
        List<AssignmentScore> assignmentScores = calculateAssignmentScores(lecIdx, studentIdx);
        
        // 3. 총점 계산
        GradeInfo gradeInfo = calculateTotalScore(attendanceScore, assignmentScores);
        
        // 4. ENROLLMENT_DATA 업데이트
        updateEnrollmentGradeData(lecIdx, studentIdx, gradeInfo);
        
        return ResponseEntity.ok(createSuccessResponse(gradeInfo));
    }

    /**
     * 출석 점수 계산
     */
    private Double calculateAttendanceScore(Integer lecIdx, Integer studentIdx) {
        // ATTENDANCE_TBL에서 출석율 계산
        // 출석율 × 지정 만점 = 출석 점수
        return attendanceRepository.calculateAttendanceScore(lecIdx, studentIdx);
    }

    /**
     * 과제 점수 집계
     */
    private List<AssignmentScore> calculateAssignmentScores(Integer lecIdx, Integer studentIdx) {
        // ASSIGNMENT_TBL에서 해당 강의의 모든 과제 점수 조회
        return assignmentRepository.getStudentAssignmentScores(lecIdx, studentIdx);
    }

    /**
     * 최종 등급 배정 (60% 기준 + 상대평가)
     */
    public ResponseEntity<?> finalizeGrades(Map<String, Object> request) {
        Integer lecIdx = (Integer) request.get("lecIdx");
        Double passingThreshold = (Double) request.get("passingThreshold"); // 기본값: 60.0
        Map<String, Integer> gradeDistribution = (Map<String, Integer>) request.get("gradeDistribution");
        
        // 1. 전체 수강생 성적 조회
        List<StudentGrade> allGrades = getAllStudentGrades(lecIdx);
        
        // 2. 합격/불합격 분류 (60% 기준)
        List<StudentGrade> passingStudents = new ArrayList<>();
        List<StudentGrade> failingStudents = new ArrayList<>();
        
        for (StudentGrade grade : allGrades) {
            if (grade.getPercentage() >= passingThreshold) {
                passingStudents.add(grade);
            } else {
                failingStudents.add(grade);
                grade.setLetterGrade("F"); // 60% 미만은 무조건 F
            }
        }
        
        // 3. 합격자들만 성적순 정렬 후 상대평가
        if (!passingStudents.isEmpty()) {
            passingStudents.sort((a, b) -> Double.compare(b.getPercentage(), a.getPercentage()));
            assignRelativeGrades(passingStudents, gradeDistribution);
        }
        
        // 4. ENROLLMENT_DATA 업데이트
        updateFinalGrades(allGrades);
        
        // 5. 통계 생성
        GradeStatistics stats = generateGradeStatistics(allGrades);
        
        return ResponseEntity.ok(createSuccessResponse("등급 배정이 완료되었습니다.", stats));
    }

    /**
     * 60점 미만자가 하위 등급을 차지하는 방식으로 등급 배정
     */
    private void assignRelativeGrades(List<StudentGrade> allGrades, Map<String, Integer> distribution, 
                                     List<StudentGrade> passingStudents, int totalStudents) {
        
        int passingCount = passingStudents.size();
        int failingCount = totalStudents - passingCount;
        
        // 기본 비율 계산 (전체 학생 수 기준)
        int originalA = (int) Math.ceil(totalStudents * distribution.get("A") / 100.0);
        int originalB = (int) Math.ceil(totalStudents * distribution.get("B") / 100.0);
        int originalC = (int) Math.ceil(totalStudents * distribution.get("C") / 100.0);
        int originalD = (int) Math.ceil(totalStudents * distribution.get("D") / 100.0);
        
        // 60점 미만자가 하위 등급부터 차지
        int actualA = originalA;
        int actualB = originalB;
        int actualC = originalC;
        int actualD = originalD;
        
        // F등급자가 D, C, B 순서로 자리 차지
        if (failingCount > 0) {
            if (failingCount >= originalD) {
                actualD = 0;
                failingCount -= originalD;
                
                if (failingCount >= originalC) {
                    actualC = 0;
                    failingCount -= originalC;
                    
                    if (failingCount >= originalB) {
                        actualB = 0;
                        failingCount -= originalB;
                        
                        // A등급도 침범하는 경우
                        if (failingCount > 0) {
                            actualA = Math.max(0, originalA - failingCount);
                        }
                    } else {
                        actualB = originalB - failingCount;
                    }
                } else {
                    actualC = originalC - failingCount;
                }
            } else {
                actualD = originalD - failingCount;
            }
        }
        
        // 합격자들을 성적순으로 정렬하여 등급 배정
        passingStudents.sort((a, b) -> Double.compare(b.getPercentage(), a.getPercentage()));
        
        int currentIndex = 0;
        
        // A등급 배정
        for (int i = 0; i < actualA && currentIndex < passingCount; i++) {
            passingStudents.get(currentIndex++).setLetterGrade("A");
        }
        
        // B등급 배정
        for (int i = 0; i < actualB && currentIndex < passingCount; i++) {
            passingStudents.get(currentIndex++).setLetterGrade("B");
        }
        
        // C등급 배정
        for (int i = 0; i < actualC && currentIndex < passingCount; i++) {
            passingStudents.get(currentIndex++).setLetterGrade("C");
        }
        
        // D등급 배정
        for (int i = 0; i < actualD && currentIndex < passingCount; i++) {
            passingStudents.get(currentIndex++).setLetterGrade("D");
        }
        
        // 낙제자가 하위등급을 다 차지한 경우: 남은 합격자들은 자연스럽게 상위등급에 배치
        while (currentIndex < passingCount) {
            passingStudents.get(currentIndex++).setLetterGrade("A");
        }
    }
}
```

---

## 📝 성적 관리 프로세스

### 1️⃣ 성적 구성 설정
- 교수가 강의별 성적 비율 설정
- 출석, 과제, 시험 배점 결정
- 등급 분포 기준 설정

### 2️⃣ 출석/과제 점수 입력
- 출석 점수: ATTENDANCE_TBL에서 자동 계산
- 과제 점수: ASSIGNMENT_TBL에서 자동 집계
- 이벤트 기반 자동 반영 및 업데이트

### 3️⃣ 이벤트 기반 합계 계산
- JSON 데이터 선별적 자동 업데이트
- 백분율 계산
- 순위 산정

### 4️⃣ 최종 등급 배정 (교수 수동 실행)
- **60% 기준 분류**: 점수/만점 비율 60% 미만은 무조건 F
- **상대평가**: 60% 이상 합격자들만 A, B, C, D로 배정
- **하위 침범 방식**: 낙제자가 D→C→B→A 순서로 하위등급 자리 차지
- **자연스러운 결과**: 낙제자가 많으면 합격자들이 상대적으로 상위등급에 배치됨

## 🎯 최종 등급 배정 특별 로직

### 등급 배정 알고리즘

#### 1단계: 합격/불합격 분류
```
60% 이상 → 합격 (상대평가 대상)
60% 미만 → F등급 확정
```

#### 2단계: 등급 배정 알고리즘
```
기본 비율: A(30%), B(40%), C(20%), D(10%)
60점 미만자가 하위 등급부터 대체하는 방식
```

#### 3단계: 실제 등급 배정 사례
```java
// 예시 1: 100명 수강, 모두 60점 이상
총 수강생: 100명
- A등급: 30명 (상위 30%)
- B등급: 40명 (30~70%)
- C등급: 20명 (70~90%)
- D등급: 10명 (90~100%)
- F등급: 0명

// 예시 2: 100명 수강, 15명이 60점 미만
총 수강생: 100명
- A등급: 30명 (상위 30%)
- B등급: 40명 (30~70%)
- C등급: 15명 (70~85%) ← D 10명 + C 일부가 C로
- D등급: 0명 ← 60점 미만자가 D 자리 차지
- F등급: 15명 (60점 미만)

// 예시 3: 100명 수강, 75명이 60점 미만
총 수강생: 100명
- A등급: 25명 (상위 25%) ← 합격자 중 상위만
- B등급: 0명 ← 60점 미만자가 B, C, D 자리 모두 차지
- C등급: 0명
- D등급: 0명
- F등급: 75명 (60점 미만)

// 예시 4: 20명 수강, 18명이 60점 미만
총 수강생: 20명
- A등급: 2명 (합격자 전부) ← 낙제자가 하위등급 다 차지해서 자연스럽게 상위등급만 남음
- B등급: 0명
- C등급: 0명  
- D등급: 0명
- F등급: 18명 (60점 미만)
```

### JSON 데이터 구조 (등급 배정 전후)

#### 등급 배정 전
```json
{
  "grade": {
    "total": {
      "score": 204.5,
      "maxScore": 230,
      "percentage": 88.9
    },
    "letterGrade": null,  // ← 공란 상태
    "finalized": false
  }
}
```

#### 등급 배정 후
```json
{
  "grade": {
    "total": {
      "score": 204.5,
      "maxScore": 230,
      "percentage": 88.9
    },
    "letterGrade": "A",   // ← 등급 확정
    "finalized": true,
    "finalizedDate": "2025-10-18T15:30:00Z",
    "rank": 1,
    "totalStudents": 20,
    "passingStudents": 2
  }
}
```

---

## 🎯 이벤트 기반 자동 계산 시스템

### 이벤트 트리거 포인트

#### 1️⃣ 출석 이벤트
```java
// AttendanceController에서 출석 체크 시
@PostMapping("/mark")
public ResponseEntity<?> markAttendance(@RequestBody AttendanceRequest request) {
    // 1. 출석 데이터 저장
    attendanceService.markAttendance(request);
    
    // 2. 🔥 성적 재계산 이벤트 발생
    applicationEventPublisher.publishEvent(
        new GradeUpdateEvent(request.getLecIdx(), request.getStudentIdx(), "ATTENDANCE")
    );
    
    return ResponseEntity.ok("출석 처리 완료");
}
```

#### 2️⃣ 과제 채점 이벤트
```java
// AssignmentController에서 과제 채점 시
@PutMapping("/{assignmentIdx}/grade")
public ResponseEntity<?> gradeAssignment(@RequestBody GradeRequest request) {
    // 1. 과제 점수 저장
    assignmentService.gradeAssignment(request);
    
    // 2. 🔥 성적 재계산 이벤트 발생
    applicationEventPublisher.publishEvent(
        new GradeUpdateEvent(request.getLecIdx(), request.getStudentIdx(), "ASSIGNMENT")
    );
    
    return ResponseEntity.ok("채점 완료");
}
```

### 이벤트 리스너 구현

```java
@Component
public class GradeUpdateEventListener {
    
    @Autowired
    private EnrollmentService enrollmentService;
    
    @EventListener
    @Async
    public void handleGradeUpdate(GradeUpdateEvent event) {
        try {
            // 해당 학생의 성적만 선별적으로 재계산
            enrollmentService.recalculateStudentGrade(
                event.getLecIdx(), 
                event.getStudentIdx(),
                event.getUpdateType()
            );
            
            log.info("성적 업데이트 완료: 강의={}, 학생={}, 타입={}", 
                event.getLecIdx(), event.getStudentIdx(), event.getUpdateType());
                
        } catch (Exception e) {
            log.error("성적 업데이트 실패", e);
        }
    }
}
```

### 선별적 재계산 로직

```java
/**
 * 특정 학생의 성적만 재계산 (전체가 아닌 변경 부분만)
 */
public void recalculateStudentGrade(Integer lecIdx, Integer studentIdx, String updateType) {
    // 1. 기존 JSON 데이터 조회
    EnrollmentExtended enrollment = findEnrollment(lecIdx, studentIdx);
    JSONObject gradeData = getGradeData(enrollment);
    
    // 2. 업데이트 타입에 따른 선별적 계산
    switch (updateType) {
        case "ATTENDANCE":
            updateAttendanceScore(gradeData, lecIdx, studentIdx); // 출석 점수만
            break;
        case "ASSIGNMENT":
            updateAssignmentScores(gradeData, lecIdx, studentIdx); // 과제 점수만
            break;
    }
    
    // 3. 총점 재계산 및 JSON 업데이트
    updateTotalScore(gradeData);
    saveEnrollmentData(enrollment, gradeData);
}
```

### 성능 최적화 특징

- **선별적 업데이트**: 전체 재계산이 아닌 변경된 부분만 처리
- **비동기 처리**: 백그라운드에서 처리하여 사용자 응답 속도에 영향 없음
- **중복 방지**: 같은 학생의 연속 이벤트 시 마지막 것만 처리
- **투명한 처리**: 사용자는 별도 새로고침 액션 불필요

---

## ✨ 주요 특징

### 🔄 이벤트 기반 자동 계산
- **자동 트리거**: 출석 체크, 과제 채점 시 즉시 재계산
- **선별적 업데이트**: 해당 학생의 성적만 업데이트
- **투명한 처리**: 사용자는 별도 액션 불필요
- **성능 최적화**: 변경된 데이터만 처리

### 📊 JSON 기반 유연성
- 확장 가능한 데이터 구조
- 동적 성적 구성 지원
- 복잡한 계산 로직 단순화

### 🎯 백분위 등급 배정
- 상대평가 기준 등급 산출
- 유연한 등급 분포 설정
- 공정한 성적 평가 보장

### 👨‍🏫 교수 전용 관리
- 교수별 권한 관리
- 강의별 독립적 성적 관리
- 직관적인 인터페이스 제공

---

## 🔧 개발 우선순위

### 1단계: 핵심 성적 관리 (2주)
- ✅ EnrollmentController 확장
- ✅ 성적 구성 설정 API
- ✅ 개별 성적 조회 API
- ✅ **이벤트 기반 자동 계산 로직 구현**
- ✅ AttendanceController에 이벤트 연동
- ✅ AssignmentController에 이벤트 연동

### 2단계: 고급 기능 (1주)
- ✅ 전체 성적 목록 API
- ✅ 최종 등급 배정 API
- ✅ 백분위 계산 로직

### 3단계: 최적화 (1주)
- ✅ 성능 최적화
- ✅ 오류 처리 강화
- ✅ 테스트 코드 작성

---

## 📋 체크리스트

### 백엔드 구현
- [ ] **EnrollmentController 확장**
- [ ] **EnrollmentService 구현**  
- [ ] **이벤트 리스너 구현** (GradeUpdateEventListener)
- [ ] **AttendanceController에 이벤트 발생 로직 추가**
- [ ] **AssignmentController에 이벤트 발생 로직 추가**
- [ ] **JSON 데이터 처리 로직**
- [ ] **성적 계산 알고리즘** (선별적 업데이트)
- [ ] **백분위 등급 배정 로직**
- [ ] **오류 처리 및 검증**

### 데이터베이스
- [ ] ENROLLMENT_EXTENDED_TBL 활용
- [ ] JSON 스키마 정의
- [ ] 인덱스 최적화
- [ ] 성능 튜닝

### 테스트
- [ ] 단위 테스트 작성
- [ ] 통합 테스트 작성  
- [ ] 브라우저 콘솔 테스트 스크립트
- [ ] 성능 테스트

---

## 🎯 결론

JSON 기반 성적 관리 시스템을 통해:

✅ **유연성**: 동적 성적 구성 및 확장 가능  
✅ **효율성**: 실시간 자동 계산으로 관리 부담 감소  
✅ **공정성**: 백분위 기준 객관적 등급 배정  
✅ **일관성**: 기존 POST 방식과 통합된 설계  

**다음 단계**: EnrollmentController 확장 개발 시작

---

> **참고 문서**  
> - [성적관리시스템_설계안_수정.drawio](./성적관리시스템_설계안_수정.drawio)  
> - [미구현기능_POST방식_통일가이드.md](../미구현기능_POST방식_통일가이드.md)