# 🐛 수강생 목록 조회 API 버그 리포트

**작성일**: 2025-10-28  
**버그 발견**: 성적 관리 시스템 테스트 중  
**심각도**: 🔴 Critical (핵심 기능 작동 불가)  
**상태**: ✅ 해결됨

---

## 📋 목차
1. [문제 요약](#문제-요약)
2. [증상](#증상)
3. [원인 분석](#원인-분석)
4. [해결 방법](#해결-방법)
5. [테스트 결과](#테스트-결과)
6. [관련 파일](#관련-파일)

---

## 문제 요약

**강의별 수강생 목록을 조회하는 API가 0명을 반환하는 문제**

- **API 엔드포인트**: `POST /api/enrollments/list`
- **요청 파라미터**: `lecSerial: 'ETH201'`
- **예상 결과**: 25명의 수강생 목록
- **실제 결과**: `totalElements: 0` (빈 목록)
- **데이터베이스 상태**: `ENROLLMENT_EXTENDED_TBL`에 `LEC_IDX=48` (ETH201)로 등록된 학생 25명 존재 확인

---

## 증상

### 1. API 응답
```javascript
// 요청
await enrollmentListTest.list()
// 요청 데이터: { lecSerial: 'ETH201', studentIdx: null, page: 0, size: 100 }

// 응답 (문제 발생 시)
{
  content: [],
  totalElements: 0,
  totalPages: 0,
  number: 0
}
```

### 2. 데이터베이스 확인
```sql
SELECT COUNT(*) FROM ENROLLMENT_EXTENDED_TBL WHERE LEC_IDX = 48;
-- 결과: 25명 (studentIdx: 1, 6, 33-55)

SELECT LEC_SERIAL FROM LEC_TBL WHERE LEC_IDX = 48;
-- 결과: 'ETH201'
```

### 3. 서버 로그 분석
```
JWT에서 studentIdx 자동 추출: 25
강의별 수강생 조회 요청 - lecSerial: ETH201, studentIdx: 25
조회 결과: 0건
```

**핵심 문제점**: JWT에서 자동 추출된 `studentIdx=25` (교수 계정의 userIdx)가 명시적으로 전달된 `lecSerial` 파라미터보다 우선 처리됨

---

## 원인 분석

### 🔍 호출 체인 추적

1. **Controller** (`EnrollmentController.java`)
   - 요청 수신: `lecSerial='ETH201'`, `studentIdx=null`
   - JWT에서 `userIdx=25` 자동 추출 → `studentIdx=25`로 설정
   - **문제 발생 지점**: 조건 검사 순서 오류

2. **Service** (`EnrollmentService.java`)
   - `getEnrollmentsByLecturePaged(lecIdx, pageable)` 호출
   - Repository로 위임

3. **Repository** (`EnrollmentExtendedTblRepository.java`)
   - JPA 쿼리 실행:
   ```java
   @Query("SELECT DISTINCT e FROM EnrollmentExtendedTbl e " +
          "JOIN FETCH e.lecture " +
          "JOIN FETCH e.student " +
          "WHERE e.lecIdx = :lecIdx")
   Page<EnrollmentExtendedTbl> findStudentsByLecture(@Param("lecIdx") Integer lecIdx, Pageable pageable);
   ```
   - **쿼리 자체는 정상**: `lecIdx`를 받으면 해당 강의의 수강생 목록 반환

### 🐛 근본 원인: Controller 조건 우선순위 오류

#### 수정 전 코드 (Lines 115-150)
```java
@PostMapping("/list")
public ResponseEntity<ApiResponse<?>> getEnrollmentList(
    @RequestBody EnrollmentListRequest request,
    @RequestHeader(value = "Authorization", required = false) String authHeader) {
    
    // JWT에서 studentIdx 자동 추출
    Integer studentIdx = jwtUtil.extractStudentIdx(authHeader);
    
    // 1. 통계 조회
    if (request.getStats() != null && request.getStats()) {
        // ...
    }
    
    // 2. 현재 수강중인 목록
    if (request.getEnrolled() != null && request.getEnrolled() && studentIdx != null) {
        // ...
    }
    
    // ❌ 문제: studentIdx 조건이 lecIdx보다 먼저 검사됨
    // 3. 학생별 수강 목록 (페이징) - JWT에서 추출된 studentIdx=25가 여기서 처리됨
    if (studentIdx != null && !request.getEnrolled()) {
        // studentIdx=25(교수)로 조회 → 학생이 아니므로 빈 목록 반환
        return ...;
    }
    
    // 4. 강의별 수강생 목록 (페이징) - 여기까지 도달하지 못함!
    if (lecIdx != null) {
        Pageable pageable = PageRequest.of(request.getPage(), request.getSize());
        Page<EnrollmentExtendedTbl> enrollments = 
            enrollmentService.getEnrollmentsByLecturePaged(lecIdx, pageable);
        // ...
    }
}
```

**문제 흐름**:
1. 요청: `{ lecSerial: 'ETH201', studentIdx: null }`
2. JWT 자동 추출: `studentIdx = 25` (교수 계정의 userIdx)
3. 조건 검사 순서:
   - ❌ `if (studentIdx != null && !request.getEnrolled())` → **TRUE** (studentIdx=25 존재, enrolled=false)
   - 👉 "학생 25의 수강 목록" 조회 → 교수는 학생이 아니므로 빈 목록 반환
   - ⛔ `if (lecIdx != null)` 조건은 **실행되지 않음**

---

## 해결 방법

### ✅ 수정 사항: 조건 검사 순서 변경

**핵심 원칙**: **명시적 파라미터(lecSerial)가 JWT 자동 추출 값(studentIdx)보다 우선**

#### 수정 후 코드 (Lines 115-150)
```java
@PostMapping("/list")
public ResponseEntity<ApiResponse<?>> getEnrollmentList(
    @RequestBody EnrollmentListRequest request,
    @RequestHeader(value = "Authorization", required = false) String authHeader) {
    
    // JWT에서 studentIdx 자동 추출
    Integer studentIdx = jwtUtil.extractStudentIdx(authHeader);
    
    // 1. 통계 조회
    if (request.getStats() != null && request.getStats()) {
        // ...
    }
    
    // 2. 현재 수강중인 목록
    if (request.getEnrolled() != null && request.getEnrolled() && studentIdx != null) {
        // ...
    }
    
    // ✅ 수정: lecIdx 조건을 studentIdx 조건보다 앞으로 이동
    // 3. 강의별 수강생 목록 (페이징) - 명시적 파라미터 우선 처리
    if (lecIdx != null) {
        Pageable pageable = PageRequest.of(request.getPage(), request.getSize());
        Page<EnrollmentExtendedTbl> enrollments = 
            enrollmentService.getEnrollmentsByLecturePaged(lecIdx, pageable);
        
        Map<String, Object> response = new HashMap<>();
        response.put("content", enrollments.getContent());
        response.put("totalElements", enrollments.getTotalElements());
        response.put("totalPages", enrollments.getTotalPages());
        response.put("number", enrollments.getNumber());
        response.put("size", enrollments.getSize());
        
        return ResponseEntity.ok(ApiResponse.success(response));
    }
    
    // 4. 학생별 수강 목록 (페이징) - JWT 자동 추출 값은 후순위
    if (studentIdx != null && !request.getEnrolled()) {
        Pageable pageable = PageRequest.of(request.getPage(), request.getSize());
        Page<EnrollmentExtendedTbl> enrollments = 
            enrollmentService.getEnrollmentsByStudentPaged(studentIdx, pageable);
        // ...
    }
}
```

**수정 후 흐름**:
1. 요청: `{ lecSerial: 'ETH201', studentIdx: null }`
2. JWT 자동 추출: `studentIdx = 25`
3. 조건 검사 순서:
   - ✅ `if (lecIdx != null)` → **TRUE** (lecSerial='ETH201' → lecIdx=48)
   - 👉 "강의 48(ETH201)의 수강생 목록" 조회 → 25명 반환
   - ✅ 정상 작동!

### 📝 추가 수정: 프론트엔드 방어 코드

```javascript
// 07_수강생목록_테스트.js
const data = {
    lecSerial,
    studentIdx: null,  // 명시적으로 null 전달하여 JWT 자동 추출 방지 (백엔드 수정으로 불필요하지만 명시적 방어)
    page: parseInt(page, 10) || 0,
    size: parseInt(size, 10) || 100
};
```

---

## 테스트 결과

### ✅ 수정 후 정상 작동 확인

```javascript
// 테스트 실행
enrollmentListTest.setContext({ lecSerial: 'ETH201' })
await enrollmentListTest.list()

// 응답 (성공)
{
  success: true,
  data: {
    content: [
      { studentIdx: 6, studentName: '테스터', ... },
      { studentIdx: 1, studentName: '집갈래', ... },
      { studentIdx: 33, studentName: '김민준', ... },
      // ... 총 25명
    ],
    totalElements: 25,
    totalPages: 1,
    number: 0,
    size: 100
  },
  duration: '1281.80ms'
}

// studentIdx 목록 (검증용)
[6, 1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55]
```

### 📊 성능
- **응답 시간**: ~1.3초 (25명 학생 정보 + JOIN FETCH)
- **데이터 정합성**: DB의 25명 전원 조회 성공
- **gradeConfig 확인**: 모든 학생에게 성적 구성 설정 저장됨 확인

---

## 관련 파일

### 수정된 파일
1. **EnrollmentController.java** (Lines 121-150)
   - 경로: `backend/BlueCrab/src/main/java/BlueCrab/com/example/controller/Lecture/EnrollmentController.java`
   - 변경 사항: 조건 검사 순서 변경 (lecIdx → studentIdx)

### 테스트 파일
2. **07_수강생목록_테스트.js**
   - 경로: `backend/BlueCrab/docs/강의관련문서-신판/찐막 기능테스트/07_수강생목록_테스트.js`
   - 용도: 수강생 목록 조회 API 테스트 스크립트

### 정상 동작하는 파일 (수정 불필요)
3. **EnrollmentService.java**
   - 경로: `backend/BlueCrab/src/main/java/BlueCrab/com/example/service/Lecture/EnrollmentService.java`
   - 메서드: `getEnrollmentsByLecturePaged(Integer lecIdx, Pageable pageable)`

4. **EnrollmentExtendedTblRepository.java**
   - 경로: `backend/BlueCrab/src/main/java/BlueCrab/com/example/repository/Lecture/EnrollmentExtendedTblRepository.java`
   - 쿼리: `findStudentsByLecture(@Param("lecIdx") Integer lecIdx, Pageable pageable)`

---

## 교훈 (Lessons Learned)

### 1. 조건 검사 순서의 중요성
- **명시적 파라미터를 암묵적 값(JWT 자동 추출)보다 우선 처리**해야 함
- 여러 조건이 동시에 만족될 수 있는 경우, 우선순위를 명확히 정의

### 2. JWT 자동 추출의 부작용
- JWT에서 자동으로 추출되는 값은 편리하지만, 명시적 파라미터와 충돌할 수 있음
- 조건문 설계 시 "명시적 요청 의도"를 우선 고려

### 3. 디버깅 체인 추적
- Controller → Service → Repository 전체 호출 체인을 추적하여 문제 위치 정확히 파악
- 쿼리가 정상이라면 **조건 검사 로직**을 의심

### 4. 로그 메시지의 중요성
- "JWT에서 studentIdx 자동 추출: 25" 로그가 문제 원인 파악에 결정적 도움
- 각 조건 분기에서 어떤 로직이 실행되는지 로그로 남기는 것이 중요

---

## 관련 이슈

- **동시 발생 문제**: [성적 구성 설정 API 504 Gateway Timeout](./성적구성설정_타임아웃_해결.md)
  - 원인: 25명 학생 순차 처리 (50+ 초)
  - 해결: 배치 처리 최적화 + 프론트엔드 타임아웃 120초 연장

---

**작성자**: GitHub Copilot  
**검토**: 2025-10-28 (프로덕션 배포 전 확인 완료)
