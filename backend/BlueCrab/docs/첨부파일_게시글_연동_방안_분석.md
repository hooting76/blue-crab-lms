# 첨부파일-게시글 연동 방안 분석

## 개요

BlueCrab LMS 시스템에서 게시글 작성/수정 시 첨부파일 기능을 연동하는 두 가지 방안을 분석한 문서입니다.

현재 독립적으로 구현된 게시글 관리 API와 첨부파일 업로드 API를 효과적으로 연동하기 위한 설계 방안을 제시하고, 각 방안의 장단점을 비교 분석합니다.

## 현재 구현 상황 (정확한 검토 결과)

- **게시글 API**: 
  - `BoardCreateController.createBoard()` - JSON 방식으로 게시글 생성 ✅
  - `BoardUpdateController.updateBoard()` - JSON 방식으로 게시글 수정 ✅
  - `BoardController.getBoardDetail()` - 게시글 상세 조회 ✅
- **첨부파일 API**: 
  - `BoardAttachmentUploadController.uploadFiles()` - 완전 구현 완료 ✅
  - `POST /api/board-attachments/upload/{boardIdx}` 엔드포인트
  - MinIO 업로드, JWT 검증, 파일 검증, 롤백 처리 모두 구현됨
- **데이터베이스**: 
  - `BoardAttachmentTbl` 완전 구현 (모든 필드 + validation)
  - `BOARD_IDX` 외래키로 게시글과 연결
  - `BoardAttachmentRepository` 구현 완료
- **기존 스키마**: `BOARD_TBL`에 `BOARD_FILE VARCHAR(250)` 컬럼이 이미 존재
- **서비스 계층**: `BoardAttachmentService.uploadFiles()` 완전 구현 완료

---

## A안: 순차 처리 방식 (Sequential Processing)

게시글 작성/수정 API 내부에서 첨부파일 업로드를 함께 처리하는 통합 방식입니다.

### 🔄 처리 흐름

1. **통합 요청 수신**
   - 프론트엔드에서 게시글 데이터와 첨부파일을 하나의 요청으로 전송
   - 백엔드에서 첨부파일 포함 여부를 확인

2. **조건부 처리**
   - **첨부파일 없음**: 게시글 정보만 저장 (`BOARD_FILE = NULL`)
   - **첨부파일 있음**: 첨부파일 업로드 완료 후 게시글 저장 (`BOARD_FILE = "123,124,125"` - 쉼표 구분)

3. **트랜잭션 처리**
   - `BOARD_TBL`에 게시글 정보 저장
   - `BOARD_ATTACHMENT_TBL`에 첨부파일 메타데이터 저장
   - `BOARD_TBL.BOARD_FILE`에 첨부파일 ID 목록 저장 (쉼표 구분, 최대 5개)

### 📊 데이터베이스 구조

```sql
-- 기존 BOARD_TBL의 BOARD_FILE 컬럼 활용 (이미 존재)
-- BOARD_FILE VARCHAR(250): 첨부파일 ATTACHMENT_IDX들을 쉼표로 구분하여 저장
-- 예시: "123,124,125" (최대 5개 첨부파일 지원)

-- 데이터 예시
-- 단일 첨부파일: BOARD_FILE = "123"
-- 다중 첨부파일: BOARD_FILE = "123,124,125,126,127"
```

### 🔧 API 설계 (현실적인 구현 방안)

**기존 API를 최대한 활용하는 현실적인 방식입니다:**

#### 🎯 **최종 권장 방식: 기존 API 활용 + 연결 API 추가**

```javascript
// 프론트엔드 구현 (기존 API 100% 재사용)
const createBoardWithAttachments = async (boardData, files) => {
    try {
        // 1. 게시글 생성 (기존 API - JSON 방식 유지)
        const boardResponse = await fetch('/api/boards/create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(boardData)
        });
        
        const boardResult = await boardResponse.json();
        const boardIdx = boardResult.board.boardIdx;
        
        // 2. 첨부파일이 있으면 업로드 (기존 API - FormData 방식)
        if (files && files.length > 0) {
            const formData = new FormData();
            files.forEach(file => formData.append('files', file));
            
            const attachmentResponse = await fetch(`/api/board-attachments/upload/${boardIdx}`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}` },
                body: formData
            });
            
            const attachmentResult = await attachmentResponse.json();
            
            // 3. 게시글에 첨부파일 연결 (새로 추가할 API - JSON 방식)
            const attachmentIds = attachmentResult.attachments.map(att => att.attachmentIdx);
            
            await fetch(`/api/boards/${boardIdx}/link-attachments`, {
                method: 'PATCH',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}` 
                },
                body: JSON.stringify({ attachmentIds })
            });
        }
        
        return { success: true, boardIdx };
        
    } catch (error) {
        console.error('게시글 생성 실패:', error);
        return { success: false, error: error.message };
    }
};
```

#### 🆕 **새로 추가할 API (단 하나만 필요)**

```java
// BoardController에 추가할 메서드
@PatchMapping("/{boardIdx}/link-attachments")
public ResponseEntity<?> linkAttachments(
    @PathVariable Integer boardIdx,
    @RequestBody AttachmentLinkRequest request,
    HttpServletRequest httpRequest) {
    
    try {
        // JWT 토큰 검증 (기존 방식과 동일)
        String authHeader = httpRequest.getHeader("Authorization");
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return ResponseEntity.status(401)
                .body(Map.of("success", false, "message", "토큰이 필요합니다."));
        }
        
        String token = authHeader.substring(7);
        if (!jwtUtil.validateToken(token)) {
            return ResponseEntity.status(401)
                .body(Map.of("success", false, "message", "유효하지 않은 토큰입니다."));
        }
        
        // 게시글 존재 확인
        Optional<BoardTbl> boardOpt = boardService.findById(boardIdx);
        if (!boardOpt.isPresent()) {
            return ResponseEntity.status(404)
                .body(Map.of("success", false, "message", "게시글을 찾을 수 없습니다."));
        }
        
        // BOARD_FILE 업데이트 (쉼표 구분으로 첨부파일 ID 저장)
        BoardTbl board = boardOpt.get();
        board.setAttachmentIds(request.getAttachmentIds());
        boardService.updateBoard(board);
        
        logger.info("첨부파일 연결 완료 - 게시글 IDX: {}, 첨부파일 수: {}", 
                   boardIdx, request.getAttachmentIds().size());
        
        return ResponseEntity.ok(Map.of(
            "success", true,
            "message", "첨부파일이 성공적으로 연결되었습니다.",
            "attachmentCount", request.getAttachmentIds().size()
        ));
        
    } catch (Exception e) {
        logger.error("첨부파일 연결 실패 - 게시글 IDX: {}, 오류: {}", boardIdx, e.getMessage());
        return ResponseEntity.status(500)
            .body(Map.of("success", false, "message", "첨부파일 연결 중 오류가 발생했습니다."));
    }
}

// 요청 DTO
public class AttachmentLinkRequest {
    private List<Integer> attachmentIds;
    
    public List<Integer> getAttachmentIds() {
        return attachmentIds;
    }
    
    public void setAttachmentIds(List<Integer> attachmentIds) {
        this.attachmentIds = attachmentIds;
    }
}
```

#### 🔧 **BoardTbl에 추가할 유틸리티 메서드**

```java
// BoardTbl.java에 추가
public void setAttachmentIds(List<Integer> attachmentIds) {
    if (attachmentIds != null && !attachmentIds.isEmpty()) {
        this.boardFile = attachmentIds.stream()
            .map(String::valueOf)
            .collect(Collectors.joining(","));
    } else {
        this.boardFile = null;
    }
}

public List<Integer> getAttachmentIds() {
    if (boardFile == null || boardFile.trim().isEmpty()) {
        return new ArrayList<>();
    }
    return Arrays.stream(boardFile.split(","))
        .filter(id -> !id.trim().isEmpty())
        .map(id -> Integer.parseInt(id.trim()))
        .collect(Collectors.toList());
}
```

### 🔄 개선된 처리 흐름

1. **게시글 먼저 생성**
   - 첨부파일 없이 게시글을 먼저 DB에 저장
   - `BOARD_IDX` 자동 생성으로 PK 확보

2. **기존 첨부파일 API 활용**
   - `BoardAttachmentService.uploadFiles(boardIdx, files)` 호출
   - 기존에 구현된 MinIO 업로드 로직 그대로 활용

3. **ATTACHMENT_IDX 수집 및 연결**
   - 업로드된 첨부파일들의 `ATTACHMENT_IDX` 수집
   - `"123,124,125"` 형태로 문자열 생성

4. **BOARD_FILE 업데이트**
   - 게시글의 `BOARD_FILE` 컬럼에 첨부파일 ID 목록 저장
   - 게시글 정보 업데이트

### ✅ A안의 실제 장점 (현실적 검토 후)

- **기존 API 100% 재사용**: 이미 완전 구현된 API들을 그대로 활용
- **JSON 인터페이스 유지**: 게시글 API는 JSON 방식 완전 유지
- **간단한 조회**: 게시글 조회 시 BOARD_FILE에서 첨부파일 ID를 직접 확인
- **기존 스키마 활용**: BOARD_TBL의 BOARD_FILE 컬럼을 바로 사용 가능
- **다중 첨부파일 지원**: 쉼표 구분으로 최대 5개 첨부파일 지원
- **최소 개발 공수**: 연결 API 하나만 추가하면 완료
- **검증된 로직 활용**: 이미 테스트된 MinIO 업로드 및 JWT 검증 로직 사용

### ❌ A안의 실제 단점 (현실적 검토 후)

- **3단계 API 호출**: 게시글 생성 → 첨부파일 업로드 → 연결의 순차 처리
- **프론트엔드 로직 증가**: 에러 처리 및 API 호출 순서 관리 필요
- **문자열 파싱**: BOARD_FILE에서 첨부파일 ID 추출 시 파싱 필요
- **부분 실패 가능성**: 중간 단계 실패 시 일관성 문제 (단, 각 API에서 개별 롤백 처리됨)

---

## B안: 병렬 처리 방식 (Parallel Processing)

게시글 API와 첨부파일 API를 독립적으로 호출하여 연동하는 분리형 방식입니다.

### 🔄 처리 흐름

1. **독립적 API 호출**
   - 프론트엔드에서 게시글 생성 API와 첨부파일 업로드 API를 별도로 호출
   - 각 API는 서로 독립적으로 처리되며 기존 구현을 그대로 활용

2. **게시글 존재 검증**
   - 첨부파일 업로드 API에서 대상 게시글의 존재 여부를 먼저 확인
   - 게시글이 정상 생성된 경우에만 첨부파일을 실제 저장소에 저장

3. **개별 데이터 저장**
   - `BOARD_TBL`에 게시글 정보 저장 (기존 구조 그대로 유지)
   - `BOARD_ATTACHMENT_TBL`에 첨부파일 메타데이터 저장 (`BOARD_IDX` 외래키로 연결)

### 📊 데이터베이스 구조

```sql
-- 기존 구조 유지 (변경 불필요)
-- BOARD_ATTACHMENT_TBL.BOARD_IDX로 연결
```

### 🔧 API 설계

```javascript
// 프론트엔드에서 병렬 호출
const createBoard = async () => {
    // 1. 게시글 작성 API 호출
    const boardPromise = fetch('/api/boards/create', {
        method: 'POST',
        body: JSON.stringify(boardData)
    });
    
    // 2. 첨부파일 업로드 API 호출 (게시글 생성 후)
    const boardResponse = await boardPromise;
    const { boardIdx } = await boardResponse.json();
    
    if (files.length > 0) {
        const formData = new FormData();
        files.forEach(file => formData.append('files', file));
        
        await fetch(`/api/board-attachments/upload/${boardIdx}`, {
            method: 'POST',
            body: formData
        });
    }
};
```

```java
// BoardAttachmentService에 게시글 존재 검증 로직 추가
public List<BoardAttachmentTbl> uploadFiles(Integer boardIdx, List<MultipartFile> files) {
    // 1. 게시글 존재 여부 확인
    if (!boardService.existsById(boardIdx)) {
        throw new IllegalArgumentException("존재하지 않는 게시글입니다: " + boardIdx);
    }
    
    // 2. 첨부파일 업로드 처리
    return processFileUpload(boardIdx, files);
}
```

### ✅ 장점

- **기존 구조 유지**: 데이터베이스 스키마나 API 인터페이스 변경이 불필요
- **다중 첨부파일 지원**: 여러 개의 첨부파일을 자연스럽게 지원 가능
- **API 독립성**: 기존 게시글 API와 첨부파일 API를 그대로 활용
- **확장성**: 다른 기능에서도 첨부파일 시스템을 재사용할 수 있음
- **유지보수성**: 각 기능이 독립적으로 관리되어 유지보수가 용이

### ❌ 단점

- **동기화 복잡성**: 두 개의 독립적인 API 간 타이밍 이슈 처리 필요
- **에러 처리**: 부분 실패 상황에 대한 롤백 로직이 복잡함
- **프론트엔드 복잡성**: 클라이언트에서 두 API의 호출 순서와 에러 처리 관리 필요
- **데이터 일관성**: 트랜잭션이 분리되어 일시적 불일치 상태 발생 가능

---

## 방안 비교 분석

두 방안의 주요 특징을 객관적으로 비교한 표입니다.

| 평가 항목 | A안 (순차 처리) | B안 (병렬 처리) |
|-----------|-----------------|-----------------|
| **DB 스키마 변경** | 불필요 (BOARD_FILE 컬럼 이미 존재) | 불필요 |
| **첨부파일 개수** | 다중 파일 지원 (쉼표 구분, 최대 5개) | 다중 파일 지원 |
| **API 인터페이스 변경** | 게시글 API 수정 필요 | 기존 API 그대로 유지 |
| **데이터 일관성** | 높음 (단일 트랜잭션) | 보통 (별도 검증 로직 필요) |
| **구현 복잡도** | 중간 | 높음 |
| **시스템 확장성** | 보통 | 높음 |
| **유지보수 난이도** | 보통 | 어려움 |
| **개발 공수** | 중간 | 높음 |
| **첨부파일 조회** | 빠름 (BOARD_FILE에서 직접) | 느림 (JOIN 또는 별도 조회) |

---

## 권장 방안 및 구현 전략

### 🎯 **권장 방안 재검토**

**A안과 B안 모두 다중 첨부파일을 지원할 수 있다는 점을 고려하면, 각 방안의 장단점이 다시 평가됩니다:**

**A안 (순차 처리)의 새로운 장점:**

- **빠른 첨부파일 조회**: BOARD_FILE 컬럼에서 직접 첨부파일 ID 목록을 얻을 수 있음
- **단순한 데이터 모델**: 게시글 조회 시 추가 JOIN이나 별도 쿼리 불필요
- **트랜잭션 일관성**: 게시글과 첨부파일이 동시에 생성/롤백됨

**B안 (병렬 처리)의 장점:**

- **기존 API 유지**: 현재 구현된 API들을 그대로 활용
- **높은 확장성**: 다른 기능에서도 첨부파일 시스템 재사용 가능
- **독립적 관리**: 각 기능이 독립적으로 개발/유지보수 가능

### 💡 **최종 권장: A안 (기존 API 활용 방식)**

**전체 검토 결과, A안이 가장 현실적이고 효율적입니다.**

**선택 이유:**

1. **기존 투자 보호**: 이미 완전 구현된 API와 서비스 로직을 그대로 활용
2. **최소 개발 공수**: 연결 API 하나와 유틸리티 메서드 몇 개만 추가
3. **JSON 인터페이스 유지**: 게시글 API의 기존 JSON 방식 완전 보존
4. **성능 우위**: BOARD_FILE에서 직접 첨부파일 ID 조회로 빠른 성능
5. **검증된 안정성**: 이미 테스트된 업로드 로직과 JWT 검증 활용

### 📋 **A안 구현 가이드 (실제 작업 목록)**

1. **BoardTbl.java 수정** (5분)
   - `setAttachmentIds()`, `getAttachmentIds()` 메서드 추가

2. **BoardController.java 수정** (15분)
   - `linkAttachments()` API 하나만 추가
   - JWT 검증 로직 포함

3. **AttachmentLinkRequest.java 생성** (3분)
   - 간단한 DTO 클래스 생성

4. **프론트엔드 구현** (30분)
   - 기존 API 호출 코드에 연결 API 호출 추가
   - 에러 처리 로직 추가

**총 예상 개발 시간: 1시간 이내**

---

## 결론

**BOARD_FILE 컬럼에 쉼표 구분으로 다중 ATTACHMENT_IDX를 저장할 수 있다는 점**을 고려하면, A안(순차 처리)이 성능과 구현 복잡도 면에서 더 유리합니다.

이 방식을 통해 기존 데이터베이스 구조를 최대한 활용하면서도 다중 첨부파일 기능을 효율적으로 구현할 수 있을 것으로 판단됩니다.
