# 프론트엔드 개발자를 위한 백엔드 동작 방식 설명 계획

> **작성 일자**: 2025-10-10  
> **대상**: 프론트엔드 개발자  
> **목적**: 백엔드 API의 동작 원리와 프론트엔드 연동 방법을 명확히 이해

---

## 📋 목차

1. [전체 아키텍처 개요](#1-전체-아키텍처-개요)
2. [요청-응답 흐름도](#2-요청-응답-흐름도)
3. [레이어별 동작 원리](#3-레이어별-동작-원리)
4. [실제 API 예제로 보는 동작 과정](#4-실제-api-예제로-보는-동작-과정)
5. [인증 메커니즘](#5-인증-메커니즘)
6. [에러 처리 및 응답 구조](#6-에러-처리-및-응답-구조)
7. [프론트엔드 연동 체크리스트](#7-프론트엔드-연동-체크리스트)

---

## 1. 전체 아키텍처 개요

### 1.1 시스템 구조 다이어그램

```
┌─────────────────────────────────────────────────────────────┐
│                    프론트엔드 (React)                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │ 컴포넌트  │  │  API호출  │  │  Context │  │   Hook   │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↓ HTTP Request
                            ↓ (JSON + JWT Token)
┌─────────────────────────────────────────────────────────────┐
│                    스프링 부트 백엔드                          │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         1. Interceptor (요청 전처리)                  │   │
│  │         - JWT 토큰 검증                               │   │
│  │         - 로그 기록                                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                            ↓                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         2. Controller (API 엔드포인트)                │   │
│  │         - 요청 수신 및 파라미터 검증                   │   │
│  │         - DTO 변환                                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                            ↓                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         3. Service (비즈니스 로직)                    │   │
│  │         - 권한 확인                                   │   │
│  │         - 비즈니스 규칙 처리                          │   │
│  │         - 트랜잭션 관리                               │   │
│  └─────────────────────────────────────────────────────┘   │
│                            ↓                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         4. Repository (데이터 접근)                   │   │
│  │         - JPA/JPQL 쿼리 실행                          │   │
│  └─────────────────────────────────────────────────────┘   │
│                            ↓                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         5. Database (MySQL)                          │   │
│  │         - 데이터 저장/조회                            │   │
│  └─────────────────────────────────────────────────────┘   │
│                            ↑                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         외부 서비스                                    │   │
│  │         - Redis (캐시, 세션)                          │   │
│  │         - MinIO (파일 저장소)                         │   │
│  │         - FCM (푸시 알림)                             │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↓ HTTP Response
                            ↓ (JSON)
┌─────────────────────────────────────────────────────────────┐
│                    프론트엔드 (React)                         │
│                    - 응답 데이터 처리                         │
│                    - UI 업데이트                             │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 백엔드 폴더 구조 (15개 레이어)

```
backend/BlueCrab/src/main/java/BlueCrab/com/example/
│
├── 📁 controller/          # HTTP 요청을 받는 진입점 (28개 클래스)
│   └── 역할: URL 매핑, 요청 검증, 응답 반환
│
├── 📁 service/             # 비즈니스 로직 구현 (26개 클래스)
│   └── 역할: 실제 기능 구현, 트랜잭션 관리
│
├── 📁 repository/          # 데이터베이스 접근 (JPA)
│   └── 역할: CRUD 쿼리, 복잡한 검색 쿼리
│
├── 📁 entity/              # 데이터베이스 테이블 매핑 (12개 엔티티)
│   └── 역할: DB 테이블과 1:1 매핑되는 Java 클래스
│
├── 📁 dto/                 # 데이터 전송 객체 (42개 클래스)
│   └── 역할: 프론트엔드와 주고받는 JSON 구조
│
├── 📁 config/              # 스프링 설정 클래스 (12개 설정)
│   └── 역할: Redis, Security, Firebase, MinIO 등 설정
│
├── 📁 security/            # 보안 관련 클래스
│   └── 역할: JWT 필터, Spring Security 설정
│
├── 📁 util/                # 유틸리티 클래스
│   └── 역할: JWT 처리, 파일 처리, 공통 기능
│
├── 📁 exception/           # 예외 처리 클래스
│   └── 역할: 커스텀 예외 정의, GlobalExceptionHandler
│
├── 📁 enums/               # 열거형 타입
│   └── 역할: 상태 코드, 예약 상태, 시설 타입 등
│
├── 📁 annotation/          # 커스텀 어노테이션
│   └── 역할: @RateLimit, @AdminOnly 등
│
├── 📁 interceptor/         # HTTP 요청 가로채기
│   └── 역할: 로깅, 인증 전처리
│
├── 📁 scheduler/           # 스케줄 작업
│   └── 역할: 정기적인 배치 작업 (토큰 정리 등)
│
├── 📁 initializer/         # 초기화 클래스
│   └── 역할: 애플리케이션 시작 시 초기 데이터 설정
│
└── 📁 model/               # 기타 모델 클래스
    └── 역할: DTO/Entity가 아닌 보조 클래스
```

### 1.3 프론트엔드 개발자가 자주 보게 될 폴더

| 우선순위 | 폴더 | 설명 | 확인 이유 |
|---------|------|------|----------|
| ⭐⭐⭐ | **dto/** | API 요청/응답 구조 | JSON 형식 확인 필수 |
| ⭐⭐⭐ | **controller/** | API 엔드포인트 | URL, HTTP 메서드 확인 |
| ⭐⭐ | **entity/** | 데이터베이스 구조 | 데이터 관계 이해 |
| ⭐⭐ | **enums/** | 상태 코드 | 드롭다운, 필터 옵션 |
| ⭐ | **exception/** | 에러 타입 | 에러 처리 방법 |
| ⭐ | **service/** | 비즈니스 규칙 | 복잡한 로직 이해 시 |

### 1.4 주요 기술 스택

| 레이어 | 기술 | 역할 |
|--------|------|------|
| **Controller** | Spring MVC | HTTP 요청/응답 처리 |
| **Service** | Spring Service | 비즈니스 로직 구현 |
| **Repository** | Spring Data JPA | 데이터베이스 접근 |
| **Security** | JWT + Spring Security | 인증/인가 처리 |
| **Cache** | Redis | 세션, 토큰 블랙리스트, FCM 세션 |
| **Storage** | MinIO | 파일 업로드/다운로드 (프로필, 첨부파일) |
| **Database** | MariaDB | 영구 데이터 저장 |
| **Push** | Firebase FCM | 푸시 알림 발송 |
| **Email** | SMTP | 이메일 인증 코드 발송 |

> 💡 **상세 버전 정보**: [기술 스택 및 버전 정보](./기술스택_및_버전정보.md) 문서 참조
> - Spring Boot 2.x (eGovFrame 4.3.0)
> - Tomcat 9.x (내장)
> - MariaDB JDBC 3.1.4
> - Redis 6.x/7.x
> - MinIO Client 8.5.2
> - Firebase Admin SDK 9.7.0
> - JWT (jjwt 0.12.6)

---

## 1.5 주요 폴더별 상세 내용

### 📁 dto/ - 프론트엔드가 가장 많이 볼 폴더 (42개)

**요청 DTO (Request)** - 프론트엔드가 백엔드로 보내는 데이터 형식
```
LoginRequest.java                    # 로그인 요청
ReservationCreateRequestDto.java     # 예약 생성 요청
SeatReserveRequestDto.java           # 좌석 예약 요청
FcmRegisterRequest.java              # FCM 토큰 등록 요청
PasswordResetIdentityRequest.java    # 비밀번호 재설정 본인 확인
```

**응답 DTO (Response)** - 백엔드가 프론트엔드로 보내는 데이터 형식
```
LoginResponse.java                   # 로그인 응답 (JWT 토큰 포함)
ReservationDto.java                  # 예약 정보
ReadingSeatDto.java                  # 열람실 좌석 정보
FcmRegisterResponse.java             # FCM 등록 결과
ApiResponse.java                     # 모든 API의 공통 응답 래퍼
```

**프론트엔드 사용 예시**:
```typescript
// TypeScript 인터페이스로 변환
interface LoginRequest {
  username: string;
  password: string;
}

interface LoginResponse {
  accessToken: string;
  refreshToken: string;
  tokenType: "Bearer";
  expiresIn: number;
  user: {
    userIdx: number;
    userEmail: string;
    userName: string;
  };
}
```

---

### 📁 entity/ - 데이터베이스 테이블 구조 (12개)

**핵심 엔티티**:
```
UserTbl.java                    # 사용자 테이블
BoardTbl.java                   # 게시판 테이블
BoardAttachmentTbl.java         # 게시판 첨부파일 테이블
FacilityTbl.java                # 시설 테이블
FacilityReservationTbl.java     # 시설 예약 테이블
ReadingSeat.java                # 열람실 좌석 테이블
FcmToken.java                   # FCM 토큰 테이블
AdminTbl.java                   # 관리자 테이블
```

**프론트엔드 관점**:
- Entity는 직접 받지 않고 DTO로 변환된 데이터를 받습니다
- 하지만 데이터 구조와 관계를 이해하는 데 유용합니다
- 예: `FacilityReservationTbl`은 `UserTbl`과 `FacilityTbl`을 참조 (외래키)

---

### 📁 enums/ - 상태 코드 및 타입 정의

**프론트엔드에서 사용할 Enum**:
```java
ReservationStatus.java          # 예약 상태
  - PENDING       # 대기 중
  - APPROVED      # 승인됨
  - REJECTED      # 거부됨
  - CANCELLED     # 취소됨
  
FacilityType.java              # 시설 타입
  - SEMINAR_ROOM  # 세미나실
  - CONFERENCE    # 회의실
  - LAB           # 실습실
  
BoardCode.java                 # 게시판 코드
  - SCHOOL_NOTICE    # 학교공지 (0)
  - ACADEMIC_NOTICE  # 학사공지 (1)
  - DEPT_NOTICE      # 학과공지 (2)
  - PROF_NOTICE      # 교수공지 (3)
```

**프론트엔드 사용 예시**:
```javascript
// React에서 사용
const ReservationStatus = {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

// 상태별 표시
const getStatusBadge = (status) => {
  switch(status) {
    case ReservationStatus.PENDING:
      return <Badge color="yellow">대기 중</Badge>;
    case ReservationStatus.APPROVED:
      return <Badge color="green">승인됨</Badge>;
    case ReservationStatus.REJECTED:
      return <Badge color="red">거부됨</Badge>;
    case ReservationStatus.CANCELLED:
      return <Badge color="gray">취소됨</Badge>;
  }
};
```

---

### 📁 config/ - 시스템 설정 (12개)

**주요 설정 파일**:
```
SecurityConfig.java            # Spring Security 설정 (JWT, CORS)
RedisConfig.java               # Redis 캐시 설정
FirebaseConfig.java            # Firebase FCM 설정
ObjectStorageConfig.java       # MinIO 파일 저장소 설정
WebConfig.java                 # CORS, 인터셉터 설정
RateLimitConfig.java           # API 호출 제한 설정
```

**프론트엔드 영향**:
- `WebConfig.java`: CORS 허용 도메인 확인
- `SecurityConfig.java`: 인증 필요한 URL 확인
- `RateLimitConfig.java`: API 호출 제한 확인 (예: 1분에 10회)

---

### 📁 exception/ - 예외 처리

**커스텀 예외**:
```
NotFoundException.java              # 404 - 리소스 없음
UnauthorizedException.java          # 401 - 인증 실패
ForbiddenException.java             # 403 - 권한 없음
BusinessException.java              # 409 - 비즈니스 규칙 위반
ValidationException.java            # 400 - 유효성 검증 실패
```

**GlobalExceptionHandler.java**:
- 모든 예외를 `ApiResponse<Void>` 형식으로 통일
- HTTP 상태 코드와 에러 메시지를 일관되게 반환

**프론트엔드에서 받는 에러 응답**:
```json
{
  "success": false,
  "message": "해당 시간대에 이미 예약이 존재합니다.",
  "data": null,
  "timestamp": "2025-10-10T10:30:00"
}
```

---

## 1.6 실제 파일 예시로 이해하기

### 📄 ApiResponse.java - 모든 API의 공통 응답 형식

```java
package BlueCrab.com.example.dto;

/**
 * API 응답을 위한 공통 DTO 클래스
 * 모든 REST 컨트롤러에서 일관된 응답 형식 제공
 */
public class ApiResponse<T> {
    private boolean success;        // 성공/실패
    private String message;         // 사용자 메시지
    private T data;                 // 실제 데이터 (제네릭)
    private LocalDateTime timestamp; // 응답 시간
    
    // 성공 응답 생성
    public static <T> ApiResponse<T> success(String message, T data) {
        return new ApiResponse<>(true, message, data, LocalDateTime.now());
    }
    
    // 실패 응답 생성
    public static <T> ApiResponse<T> failure(String message) {
        return new ApiResponse<>(false, message, null, LocalDateTime.now());
    }
}
```

**프론트엔드 관점**:
- 모든 API가 동일한 구조로 응답 → 일관된 처리 가능
- `success`로 성공/실패 판단
- `message`를 사용자에게 표시
- `data`에 실제 필요한 정보

---

### 📄 ReservationDto.java - 예약 정보 응답

```java
package BlueCrab.com.example.dto;

public class ReservationDto {
    private Integer reservationIdx;      // 예약 ID
    private Integer facilityIdx;         // 시설 ID
    private String facilityName;         // 시설 이름
    private String userCode;             // 사용자 코드
    private String userName;             // 사용자 이름
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime startTime;     // 시작 시간
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime endTime;       // 종료 시간
    
    private Integer partySize;           // 인원 수
    private String purpose;              // 예약 목적
    private ReservationStatus status;    // 예약 상태
    private String rejectionReason;      // 거부 사유
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
    private LocalDateTime createdAt;     // 생성 시간
    
    // getter, setter...
}
```

**프론트엔드에서 받는 JSON**:
```json
{
  "success": true,
  "message": "예약이 생성되었습니다.",
  "data": {
    "reservationIdx": 123,
    "facilityIdx": 5,
    "facilityName": "세미나실 A",
    "userCode": "20240001",
    "userName": "홍길동",
    "startTime": "2025-10-15T14:00:00",
    "endTime": "2025-10-15T16:00:00",
    "partySize": 10,
    "purpose": "학습 세미나",
    "status": "PENDING",
    "createdAt": "2025-10-10T10:30:00"
  },
  "timestamp": "2025-10-10T10:30:00"
}
```

---

### 📄 ReservationStatus.java - 예약 상태 Enum

```java
package BlueCrab.com.example.enums;

public enum ReservationStatus {
    PENDING("대기중"),      // 관리자 승인 대기
    APPROVED("승인됨"),     // 관리자가 승인
    REJECTED("반려됨"),     // 관리자가 거부
    CANCELLED("취소됨"),    // 사용자가 취소
    COMPLETED("완료됨");    // 예약 시간 종료
    
    private final String description;
    
    ReservationStatus(String description) {
        this.description = description;
    }
    
    @JsonValue
    public String getDescription() {
        return description;
    }
    
    @JsonCreator
    public static ReservationStatus fromString(String value) {
        for (ReservationStatus status : ReservationStatus.values()) {
            if (status.name().equalsIgnoreCase(value)) {
                return status;
            }
        }
        throw new IllegalArgumentException("Unknown status: " + value);
    }
}
```

**프론트엔드 사용법**:

```javascript
// React 컴포넌트에서
const ReservationStatusBadge = ({ status }) => {
  const statusConfig = {
    'PENDING': { color: 'yellow', text: '대기중', icon: '⏳' },
    'APPROVED': { color: 'green', text: '승인됨', icon: '✅' },
    'REJECTED': { color: 'red', text: '반려됨', icon: '❌' },
    'CANCELLED': { color: 'gray', text: '취소됨', icon: '🚫' },
    'COMPLETED': { color: 'blue', text: '완료됨', icon: '✔️' }
  };
  
  const config = statusConfig[status] || statusConfig['PENDING'];
  
  return (
    <span className={`badge badge-${config.color}`}>
      {config.icon} {config.text}
    </span>
  );
};

// 사용
<ReservationStatusBadge status={reservation.status} />
```

---

## 1.7 폴더 구조 탐색 가이드

### 프론트엔드 개발자가 백엔드 코드를 볼 때

#### 1단계: API 엔드포인트 확인하기
```
📁 controller/
  └── FacilityReservationController.java 열기
      → @RequestMapping("/api/reservations") 확인
      → @PostMapping, @GetMapping 등의 메서드 확인
      → 파라미터 타입 확인 (@RequestBody ReservationCreateRequestDto)
```

#### 2단계: 요청/응답 형식 확인하기
```
📁 dto/
  ├── ReservationCreateRequestDto.java 열기
  │   → 프론트엔드가 보내야 할 JSON 구조 확인
  │
  └── ReservationDto.java 열기
      → 백엔드가 반환하는 JSON 구조 확인
```

#### 3단계: 상태 코드 확인하기
```
📁 enums/
  └── ReservationStatus.java 열기
      → 드롭다운, 필터에 사용할 값 확인
```

#### 4단계: 에러 처리 확인하기
```
📁 exception/
  ├── BusinessException.java 확인
  │   → 어떤 경우에 발생하는지 확인
  │
  └── GlobalExceptionHandler.java 확인
      → 에러 응답 형식 확인
```

### 실전 예제: 시설 예약 API 완전 이해하기

**Step 1**: Controller 파일 열기
```java
// FacilityReservationController.java
@PostMapping
public ResponseEntity<ApiResponse<ReservationDto>> createReservation(
    @Valid @RequestBody ReservationCreateRequestDto request,
    HttpServletRequest httpRequest) {
    // ...
}
```
→ **확인사항**: URL은 `/api/reservations`, 메서드는 `POST`, 요청 타입은 `ReservationCreateRequestDto`

**Step 2**: 요청 DTO 파일 열기
```java
// ReservationCreateRequestDto.java
public class ReservationCreateRequestDto {
    @NotNull
    private Integer facilityIdx;
    
    @NotNull
    @Future
    private LocalDateTime startTime;
    
    @NotNull
    private LocalDateTime endTime;
    
    private Integer partySize;
    private String purpose;
}
```
→ **확인사항**: 필수 필드(facilityIdx, startTime, endTime), 선택 필드(partySize, purpose)

**Step 3**: 응답 DTO 파일 열기
```java
// ReservationDto.java
public class ReservationDto {
    private Integer reservationIdx;
    private String facilityName;
    private ReservationStatus status;
    // ... 기타 필드
}
```
→ **확인사항**: 응답에 포함되는 모든 필드

**Step 4**: 프론트엔드 코드 작성
```javascript
// reservationAPI.js
export const createReservation = async (reservationData) => {
  const response = await fetch('/api/reservations', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${getToken()}`
    },
    body: JSON.stringify({
      facilityIdx: reservationData.facilityId,
      startTime: reservationData.startTime,
      endTime: reservationData.endTime,
      partySize: reservationData.partySize,
      purpose: reservationData.purpose
    })
  });
  
  const data = await response.json();
  
  if (data.success) {
    return data.data;  // ReservationDto
  } else {
    throw new Error(data.message);
  }
};
```

---

## 2. 요청-응답 흐름도

### 2.1 일반적인 API 호출 흐름 (인증 필요한 경우)

```
프론트엔드                백엔드
    │                      │
    │  1. HTTP Request     │
    │  (Authorization:     │
    │   Bearer token)      │
    ├─────────────────────>│
    │                      │
    │                      │  2. Interceptor
    │                      │     - JWT 검증
    │                      │     - 사용자 정보 추출
    │                      │     - 블랙리스트 확인
    │                      ↓
    │                      │  3. Controller
    │                      │     - 요청 파라미터 검증
    │                      │     - @Valid 어노테이션
    │                      ↓
    │                      │  4. Service
    │                      │     - 비즈니스 로직
    │                      │     - 권한 확인
    │                      │     - 데이터 가공
    │                      ↓
    │                      │  5. Repository
    │                      │     - DB 쿼리 실행
    │                      │     - JPA Entity 조회/저장
    │                      ↓
    │                      │  6. 응답 생성
    │                      │     - ApiResponse 래핑
    │                      │     - JSON 직렬화
    │                      │
    │  7. HTTP Response    │
    │<─────────────────────┤
    │  {                   │
    │    "success": true,  │
    │    "message": "...", │
    │    "data": {...}     │
    │  }                   │
    │                      │
```

### 2.2 인증이 필요 없는 API 호출 흐름

```
프론트엔드                백엔드
    │                      │
    │  1. HTTP Request     │
    ├─────────────────────>│
    │                      │
    │                      │  2. Controller
    │                      │     - 바로 요청 처리
    │                      ↓
    │                      │  3. Service
    │                      ↓
    │                      │  4. Repository
    │                      ↓
    │                      │  5. 응답 생성
    │                      │
    │  6. HTTP Response    │
    │<─────────────────────┤
    │                      │
```

---

## 3. 레이어별 동작 원리

### 3.1 Controller 레이어

**역할**: HTTP 요청을 받아서 Service로 전달, 응답 반환

**주요 책임**:
- ✅ URL 매핑 (`@PostMapping`, `@GetMapping` 등)
- ✅ 요청 파라미터 바인딩
- ✅ 입력 유효성 검증 (`@Valid`, `@RequestBody`)
- ✅ HTTP 상태 코드 결정
- ❌ **하지 않는 것**: 비즈니스 로직, DB 직접 접근

**코드 예시**:
```java
@RestController
@RequestMapping("/api/reservations")
public class FacilityReservationController {
    
    private final FacilityReservationService reservationService;
    private final JwtUtil jwtUtil;
    
    // 예약 생성 API
    @PostMapping
    public ResponseEntity<ApiResponse<ReservationDto>> createReservation(
            @Valid @RequestBody ReservationCreateRequestDto request,
            HttpServletRequest httpRequest) {
        
        // 1. JWT에서 사용자 정보 추출
        String userCode = getUserCodeFromToken(httpRequest);
        
        // 2. Service에 비즈니스 로직 위임
        ReservationDto reservation = reservationService.createReservation(userCode, request);
        
        // 3. 응답 생성 및 반환
        String message = reservation.getStatus().name().equals("APPROVED")
            ? "예약이 자동으로 승인되었습니다."
            : "예약이 생성되었습니다. 관리자 승인 대기 중입니다.";
            
        return ResponseEntity.ok(ApiResponse.success(message, reservation));
    }
}
```

**프론트엔드 관점**:
- Controller는 API의 "출입구"입니다
- URL 경로(`/api/reservations`)로 어떤 Controller가 처리할지 결정됩니다
- `@RequestBody`는 프론트에서 보낸 JSON을 Java 객체로 변환합니다
- `ResponseEntity`는 HTTP 상태 코드와 응답 본문을 함께 반환합니다

---

### 3.2 Service 레이어

**역할**: 실제 비즈니스 로직 구현

**주요 책임**:
- ✅ 비즈니스 규칙 검증
- ✅ 트랜잭션 관리 (`@Transactional`)
- ✅ 여러 Repository 조율
- ✅ 데이터 가공 및 변환
- ✅ 외부 서비스 호출 (이메일, 파일 저장 등)
- ❌ **하지 않는 것**: HTTP 관련 처리, 직접적인 요청/응답 처리

**코드 예시**:
```java
@Service
public class FacilityReservationService {
    
    private final ReservationRepository reservationRepository;
    private final FacilityRepository facilityRepository;
    private final UserRepository userRepository;
    
    @Transactional
    public ReservationDto createReservation(String userCode, ReservationCreateRequestDto request) {
        // 1. 사용자 확인
        User user = userRepository.findByUserCode(userCode)
            .orElseThrow(() -> new IllegalArgumentException("사용자를 찾을 수 없습니다."));
        
        // 2. 시설 확인
        Facility facility = facilityRepository.findById(request.getFacilityId())
            .orElseThrow(() -> new IllegalArgumentException("시설을 찾을 수 없습니다."));
        
        // 3. 비즈니스 규칙 검증
        if (!facility.isAvailable()) {
            throw new IllegalStateException("예약할 수 없는 시설입니다.");
        }
        
        // 4. 시간 중복 확인
        boolean hasConflict = reservationRepository.existsByTimeOverlap(
            facility.getId(), 
            request.getStartTime(), 
            request.getEndTime()
        );
        
        if (hasConflict) {
            throw new IllegalStateException("해당 시간에 이미 예약이 있습니다.");
        }
        
        // 5. 엔티티 생성 및 저장
        Reservation reservation = Reservation.builder()
            .user(user)
            .facility(facility)
            .startTime(request.getStartTime())
            .endTime(request.getEndTime())
            .status(facility.isAutoApprove() ? ReservationStatus.APPROVED : ReservationStatus.PENDING)
            .build();
        
        Reservation saved = reservationRepository.save(reservation);
        
        // 6. DTO 변환 후 반환
        return ReservationDto.from(saved);
    }
}
```

**프론트엔드 관점**:
- Service는 실제로 "일을 하는" 곳입니다
- 여러 테이블을 확인하고 조합합니다
- 비즈니스 규칙(예: 중복 예약 불가)을 여기서 검증합니다
- `@Transactional`로 묶여 있어서 중간에 에러가 나면 모든 변경이 취소됩니다 (롤백)

---

### 3.3 Repository 레이어

**역할**: 데이터베이스와 직접 통신

**주요 책임**:
- ✅ CRUD 쿼리 실행
- ✅ 복잡한 검색 쿼리 (JPQL, QueryDSL)
- ✅ JPA Entity 관리
- ❌ **하지 않는 것**: 비즈니스 로직, 데이터 가공

**코드 예시**:
```java
@Repository
public interface ReservationRepository extends JpaRepository<Reservation, Long> {
    
    // 기본 CRUD는 자동 제공: save(), findById(), findAll(), delete() 등
    
    // 커스텀 쿼리: 사용자별 예약 조회
    List<Reservation> findByUserUserCodeOrderByStartTimeDesc(String userCode);
    
    // 복잡한 쿼리: 시간 중복 확인 (JPQL 사용)
    @Query("SELECT COUNT(r) > 0 FROM Reservation r " +
           "WHERE r.facility.id = :facilityId " +
           "AND r.status != 'CANCELLED' " +
           "AND ((r.startTime < :endTime AND r.endTime > :startTime))")
    boolean existsByTimeOverlap(
        @Param("facilityId") Long facilityId,
        @Param("startTime") LocalDateTime startTime,
        @Param("endTime") LocalDateTime endTime
    );
}
```

**프론트엔드 관점**:
- Repository는 데이터베이스의 "대변인"입니다
- SQL을 직접 작성하지 않고 메서드 이름으로 쿼리를 생성합니다
- `findByUserUserCodeOrderByStartTimeDesc` → "user.userCode로 찾고 startTime 내림차순 정렬"
- `@Query`는 복잡한 쿼리를 직접 작성할 때 사용합니다

---

### 3.4 Entity (JPA 엔티티)

**역할**: 데이터베이스 테이블과 매핑되는 클래스

**코드 예시**:
```java
@Entity
@Table(name = "reservations")
public class Reservation {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_code", referencedColumnName = "user_code")
    private User user;  // 관계: 한 명의 사용자가 여러 예약 가능
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "facility_id")
    private Facility facility;  // 관계: 하나의 시설에 여러 예약 가능
    
    @Column(name = "start_time", nullable = false)
    private LocalDateTime startTime;
    
    @Column(name = "end_time", nullable = false)
    private LocalDateTime endTime;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private ReservationStatus status;
    
    // created_at, updated_at 등...
}
```

**프론트엔드 관점**:
- Entity는 데이터베이스 테이블의 "Java 버전"입니다
- `@ManyToOne`은 외래키 관계를 나타냅니다
- 프론트엔드에서는 Entity를 직접 받지 않고 DTO로 변환된 데이터를 받습니다

---

### 3.5 DTO (Data Transfer Object)

**역할**: 프론트엔드와 백엔드 간 데이터 전송 객체

**코드 예시**:
```java
// 요청 DTO
public class ReservationCreateRequestDto {
    @NotNull(message = "시설 ID는 필수입니다.")
    private Long facilityId;
    
    @NotNull(message = "시작 시간은 필수입니다.")
    @Future(message = "시작 시간은 미래여야 합니다.")
    private LocalDateTime startTime;
    
    @NotNull(message = "종료 시간은 필수입니다.")
    private LocalDateTime endTime;
    
    private String purpose;  // 예약 목적 (선택)
}

// 응답 DTO
public class ReservationDto {
    private Long id;
    private String userCode;
    private String userName;
    private String facilityName;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String status;
    private LocalDateTime createdAt;
    
    // Entity에서 DTO로 변환하는 정적 메서드
    public static ReservationDto from(Reservation reservation) {
        return ReservationDto.builder()
            .id(reservation.getId())
            .userCode(reservation.getUser().getUserCode())
            .userName(reservation.getUser().getUserName())
            .facilityName(reservation.getFacility().getName())
            .startTime(reservation.getStartTime())
            .endTime(reservation.getEndTime())
            .status(reservation.getStatus().name())
            .createdAt(reservation.getCreatedAt())
            .build();
    }
}
```

**프론트엔드 관점**:
- DTO는 프론트엔드가 받는 실제 JSON 구조입니다
- Entity는 모든 정보를 가지고 있지만, DTO는 필요한 정보만 골라서 전달합니다
- `@NotNull`, `@Future` 같은 검증 어노테이션으로 입력값을 검증합니다

---

## 4. 실제 API 예제로 보는 동작 과정

### 4.1 시설 예약 생성 API 완전 분석

**프론트엔드 요청**:
```javascript
// React 컴포넌트에서 API 호출
const createReservation = async (facilityId, startTime, endTime, purpose) => {
  const token = localStorage.getItem('accessToken');
  
  const response = await fetch('https://bluecrab.chickenkiller.com/BlueCrab-1.0.0/api/reservations', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    },
    body: JSON.stringify({
      facilityId: facilityId,
      startTime: startTime,
      endTime: endTime,
      purpose: purpose
    })
  });
  
  const data = await response.json();
  return data;
};
```

**백엔드 처리 과정**:

#### Step 1: Interceptor에서 JWT 검증
```java
// JwtInterceptor.java
@Override
public boolean preHandle(HttpServletRequest request, 
                         HttpServletResponse response, 
                         Object handler) {
    // 1. Authorization 헤더에서 토큰 추출
    String authHeader = request.getHeader("Authorization");
    if (authHeader == null || !authHeader.startsWith("Bearer ")) {
        throw new UnauthorizedException("토큰이 없습니다.");
    }
    
    String token = authHeader.substring(7);
    
    // 2. 토큰 유효성 검증
    if (!jwtUtil.validateToken(token)) {
        throw new UnauthorizedException("유효하지 않은 토큰입니다.");
    }
    
    // 3. 블랙리스트 확인 (로그아웃된 토큰인지)
    if (tokenBlacklistService.isBlacklisted(token)) {
        throw new UnauthorizedException("로그아웃된 토큰입니다.");
    }
    
    // 4. 토큰에서 사용자 정보 추출하여 request에 저장
    String userCode = jwtUtil.getUserCodeFromToken(token);
    request.setAttribute("userCode", userCode);
    
    return true;  // 다음 단계(Controller)로 진행
}
```

#### Step 2: Controller에서 요청 수신
```java
@PostMapping
public ResponseEntity<ApiResponse<ReservationDto>> createReservation(
        @Valid @RequestBody ReservationCreateRequestDto request,  // JSON → DTO 변환
        HttpServletRequest httpRequest) {
    
    // Interceptor에서 저장한 사용자 정보 가져오기
    String userCode = (String) httpRequest.getAttribute("userCode");
    
    // Service 호출
    ReservationDto reservation = reservationService.createReservation(userCode, request);
    
    // 응답 생성
    String message = reservation.getStatus().equals("APPROVED")
        ? "예약이 자동으로 승인되었습니다."
        : "예약이 생성되었습니다. 관리자 승인 대기 중입니다.";
        
    return ResponseEntity.ok(ApiResponse.success(message, reservation));
}
```

#### Step 3: Service에서 비즈니스 로직 처리
```java
@Transactional
public ReservationDto createReservation(String userCode, ReservationCreateRequestDto request) {
    // 1단계: 사용자 조회
    User user = userRepository.findByUserCode(userCode)
        .orElseThrow(() -> new NotFoundException("사용자를 찾을 수 없습니다."));
    
    // 2단계: 시설 조회
    Facility facility = facilityRepository.findById(request.getFacilityId())
        .orElseThrow(() -> new NotFoundException("시설을 찾을 수 없습니다."));
    
    // 3단계: 시설 이용 가능 여부 확인
    if (!facility.isAvailable()) {
        throw new BusinessException("해당 시설은 현재 이용할 수 없습니다.");
    }
    
    // 4단계: 시간 유효성 검증
    if (request.getStartTime().isAfter(request.getEndTime())) {
        throw new ValidationException("시작 시간이 종료 시간보다 늦을 수 없습니다.");
    }
    
    // 5단계: 시간 중복 확인
    boolean hasOverlap = reservationRepository.existsByTimeOverlap(
        facility.getId(),
        request.getStartTime(),
        request.getEndTime()
    );
    
    if (hasOverlap) {
        throw new BusinessException("해당 시간대에 이미 예약이 존재합니다.");
    }
    
    // 6단계: 예약 생성
    Reservation reservation = Reservation.builder()
        .user(user)
        .facility(facility)
        .startTime(request.getStartTime())
        .endTime(request.getEndTime())
        .purpose(request.getPurpose())
        .status(facility.isAutoApprove() ? ReservationStatus.APPROVED : ReservationStatus.PENDING)
        .build();
    
    // 7단계: 데이터베이스 저장
    Reservation saved = reservationRepository.save(reservation);
    
    // 8단계: DTO 변환 후 반환
    return ReservationDto.from(saved);
}
```

#### Step 4: Repository에서 DB 쿼리 실행
```java
// 1. 사용자 조회 쿼리
// SQL: SELECT * FROM user_tbl WHERE user_code = ?
Optional<User> user = userRepository.findByUserCode(userCode);

// 2. 시설 조회 쿼리
// SQL: SELECT * FROM facilities WHERE id = ?
Optional<Facility> facility = facilityRepository.findById(facilityId);

// 3. 시간 중복 확인 쿼리
// SQL: 복잡한 시간 겹침 확인 쿼리
boolean hasOverlap = reservationRepository.existsByTimeOverlap(...);

// 4. 예약 저장 쿼리
// SQL: INSERT INTO reservations (user_code, facility_id, start_time, ...) VALUES (?, ?, ?, ...)
Reservation saved = reservationRepository.save(reservation);
```

#### Step 5: 응답 생성 및 반환
```java
// ApiResponse 래퍼 클래스로 응답 생성
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
    private LocalDateTime timestamp;
    
    public static <T> ApiResponse<T> success(String message, T data) {
        return ApiResponse.<T>builder()
            .success(true)
            .message(message)
            .data(data)
            .timestamp(LocalDateTime.now())
            .build();
    }
}
```

**프론트엔드가 받는 최종 응답**:
```json
{
  "success": true,
  "message": "예약이 생성되었습니다. 관리자 승인 대기 중입니다.",
  "data": {
    "id": 123,
    "userCode": "20240001",
    "userName": "홍길동",
    "facilityName": "세미나실 A",
    "startTime": "2025-10-15T14:00:00",
    "endTime": "2025-10-15T16:00:00",
    "status": "PENDING",
    "createdAt": "2025-10-10T10:30:00"
  },
  "timestamp": "2025-10-10T10:30:00"
}
```

---

### 4.2 에러 발생 시 처리 과정

**시나리오**: 이미 예약된 시간대에 예약 시도

#### Backend 에러 발생
```java
// Service에서 예외 발생
if (hasOverlap) {
    throw new BusinessException("해당 시간대에 이미 예약이 존재합니다.");
}
```

#### GlobalExceptionHandler에서 에러 처리
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiResponse<Void>> handleBusinessException(BusinessException e) {
        return ResponseEntity
            .status(HttpStatus.CONFLICT)  // 409 상태 코드
            .body(ApiResponse.error(e.getMessage()));
    }
}
```

#### Frontend에서 받는 에러 응답
```json
{
  "success": false,
  "message": "해당 시간대에 이미 예약이 존재합니다.",
  "data": null,
  "timestamp": "2025-10-10T10:30:00"
}
```

#### Frontend 에러 처리
```javascript
try {
  const result = await createReservation(facilityId, startTime, endTime, purpose);
  
  if (result.success) {
    alert(result.message);
    // 예약 목록 갱신
  } else {
    alert(`에러: ${result.message}`);
  }
} catch (error) {
  if (error.response?.status === 409) {
    alert('해당 시간대에 이미 예약이 존재합니다.');
  } else if (error.response?.status === 401) {
    alert('로그인이 필요합니다.');
    // 로그인 페이지로 이동
  } else {
    alert('예약 중 오류가 발생했습니다.');
  }
}
```

---

## 5. 인증 메커니즘

### 5.1 JWT 토큰 기반 인증 흐름

```
┌──────────────┐                  ┌──────────────┐
│   Frontend   │                  │   Backend    │
└──────┬───────┘                  └──────┬───────┘
       │                                  │
       │  1. POST /api/auth/login        │
       │  { email, password }             │
       ├─────────────────────────────────>│
       │                                  │
       │                                  │  2. 사용자 확인
       │                                  │     - DB에서 조회
       │                                  │     - 비밀번호 검증
       │                                  │
       │  3. 응답: JWT 토큰               │
       │  {                               │
       │    accessToken: "eyJ...",        │
       │    refreshToken: "eyJ...",       │
       │    expiresIn: 900  (15분)       │
       │  }                               │
       │<─────────────────────────────────┤
       │                                  │
       │  4. 토큰 저장                    │
       │  localStorage.setItem(...)       │
       │                                  │
       │                                  │
       │  5. 이후 모든 API 요청            │
       │  Authorization: Bearer eyJ...    │
       ├─────────────────────────────────>│
       │                                  │
       │                                  │  6. Interceptor
       │                                  │     - 토큰 검증
       │                                  │     - 만료 확인
       │                                  │     - 블랙리스트 확인
       │                                  │
       │  7. API 응답                     │
       │<─────────────────────────────────┤
       │                                  │
```

### 5.2 JWT 토큰 구조

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyQ29kZSI6IjIwMjQwMDAxIiwiaWF0IjoxNzI4NTQwMDAwLCJleHAiOjE3Mjg1NDA5MDB9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
│                                    │                                                                                                          │
│         Header (헤더)              │                              Payload (내용)                                                              │  Signature (서명)
│                                    │                                                                                                          │
└─ 알고리즘 정보                      └─ 사용자 정보 + 만료시간                                                                                   └─ 위조 방지 서명
   { "alg": "HS256" }                  { "userCode": "20240001",
                                         "iat": 1728540000,
                                         "exp": 1728540900 }
```

### 5.3 인증이 필요한 API vs 불필요한 API

| API | 인증 필요 | 이유 |
|-----|----------|------|
| `POST /api/auth/login` | ❌ | 로그인 자체가 토큰 발급 과정 |
| `POST /api/boards/list` | ❌ | 공개 게시글 조회 |
| `POST /api/boards/detail` | ❌ | 공개 게시글 상세 조회 |
| `POST /api/boards/create` | ✅ | 글 작성은 인증 필요 |
| `POST /api/reservations` | ✅ | 예약은 사용자 정보 필요 |
| `POST /api/reservations/my` | ✅ | 내 예약 목록 조회 |
| `POST /api/profile/image` | ✅ | 프로필 수정 |

### 5.4 관리자 인증 (2단계 인증)

```
관리자 로그인 흐름
┌────────────────────────────────────────────────────────┐
│  Step 1: 아이디/비밀번호 입력                           │
│  POST /api/admin/login                                 │
│  → Redis에 임시 세션 생성 (5분 유효)                    │
└────────────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────────────┐
│  Step 2: 이메일로 인증 코드 발송                        │
│  POST /api/admin/email/send-code                       │
│  → 6자리 코드 생성 및 이메일 발송                       │
└────────────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────────────┐
│  Step 3: 인증 코드 확인                                 │
│  POST /api/admin/email/verify-code                     │
│  → JWT 토큰 발급                                        │
└────────────────────────────────────────────────────────┘
```

---

## 6. 에러 처리 및 응답 구조

### 6.1 통일된 응답 구조 (ApiResponse)

**성공 응답**:
```json
{
  "success": true,
  "message": "요청이 성공적으로 처리되었습니다.",
  "data": {
    // 실제 데이터
  },
  "timestamp": "2025-10-10T10:30:00"
}
```

**실패 응답**:
```json
{
  "success": false,
  "message": "에러 메시지",
  "data": null,
  "timestamp": "2025-10-10T10:30:00"
}
```

### 6.2 HTTP 상태 코드 가이드

| 상태 코드 | 의미 | 프론트엔드 처리 |
|----------|------|----------------|
| **200 OK** | 요청 성공 | 정상 처리 |
| **201 Created** | 리소스 생성 성공 | 생성 완료 메시지 |
| **400 Bad Request** | 잘못된 요청 (유효성 검증 실패) | 입력값 확인 요청 |
| **401 Unauthorized** | 인증 실패 (토큰 없음/만료) | 로그인 페이지로 이동 |
| **403 Forbidden** | 권한 없음 | 접근 불가 메시지 |
| **404 Not Found** | 리소스 없음 | 존재하지 않음 메시지 |
| **409 Conflict** | 비즈니스 규칙 위반 (중복 등) | 에러 메시지 표시 |
| **500 Internal Server Error** | 서버 내부 오류 | "잠시 후 다시 시도" 메시지 |

### 6.3 에러 종류별 처리

#### 유효성 검증 에러 (400)
```java
// Backend
public class ReservationCreateRequestDto {
    @NotNull(message = "시설 ID는 필수입니다.")
    private Long facilityId;
    
    @Future(message = "시작 시간은 미래여야 합니다.")
    private LocalDateTime startTime;
}
```

**응답**:
```json
{
  "success": false,
  "message": "시작 시간은 미래여야 합니다.",
  "data": null,
  "timestamp": "2025-10-10T10:30:00"
}
```

#### 인증 에러 (401)
```javascript
// Frontend
if (error.response?.status === 401) {
  // 토큰 삭제
  localStorage.removeItem('accessToken');
  localStorage.removeItem('refreshToken');
  
  // 로그인 페이지로 이동
  navigate('/login');
  
  alert('로그인이 필요합니다.');
}
```

#### 비즈니스 로직 에러 (409)
```javascript
// Frontend
if (error.response?.status === 409) {
  // 사용자에게 명확한 메시지 표시
  alert(error.response.data.message);
  // 예: "해당 시간대에 이미 예약이 존재합니다."
}
```

---

## 7. 프론트엔드 연동 체크리스트

### 7.1 API 호출 전 준비사항

- [ ] **Base URL 확인**: `https://bluecrab.chickenkiller.com/BlueCrab-1.0.0`
- [ ] **Content-Type 헤더**: `application/json`
- [ ] **인증이 필요한 API인지 확인**
- [ ] **JWT 토큰 저장 위치 결정** (localStorage vs sessionStorage)

### 7.2 요청 시 체크사항

- [ ] **HTTP 메서드 확인** (GET, POST, PUT, DELETE)
- [ ] **Authorization 헤더 포함** (인증 필요 시)
  ```javascript
  headers: {
    'Authorization': `Bearer ${token}`
  }
  ```
- [ ] **요청 바디 형식 확인** (JSON.stringify 필요)
- [ ] **필수 파라미터 누락 없는지 확인**

### 7.3 응답 처리 체크사항

- [ ] **success 필드 확인**
  ```javascript
  if (response.data.success) {
    // 성공 처리
  } else {
    // 실패 처리
  }
  ```
- [ ] **HTTP 상태 코드에 따른 분기 처리**
- [ ] **에러 메시지 사용자에게 표시**
- [ ] **토큰 만료 시 리프레시 토큰으로 갱신**

### 7.4 예외 상황 처리

- [ ] **네트워크 에러 처리** (인터넷 연결 끊김)
- [ ] **타임아웃 처리** (응답이 너무 늦을 때)
- [ ] **401 에러 시 로그아웃 처리**
- [ ] **500 에러 시 재시도 로직**

---

## 8. 실전 연동 예제

### 8.1 인증이 필요 없는 API (게시글 목록 조회)

**Frontend 코드**:
```javascript
// noticeAPI.jsx
export const fetchNoticeList = async (page = 0, size = 10) => {
  try {
    const response = await fetch(
      'https://bluecrab.chickenkiller.com/BlueCrab-1.0.0/api/boards/bycode',
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
          // Authorization 헤더 불필요
        },
        body: JSON.stringify({
          boardCode: 0,  // 학교공지
          page: page,
          size: size
        })
      }
    );
    
    const data = await response.json();
    
    if (data.success) {
      return {
        success: true,
        notices: data.data.content,
        totalPages: data.data.totalPages
      };
    } else {
      throw new Error(data.message);
    }
  } catch (error) {
    console.error('게시글 조회 실패:', error);
    return {
      success: false,
      message: error.message
    };
  }
};
```

### 8.2 인증이 필요한 API (예약 생성)

**Frontend 코드**:
```javascript
// reservationAPI.jsx
import { getAccessToken } from '../auth/AuthFunc';

export const createReservation = async (reservationData) => {
  try {
    const token = getAccessToken();
    
    if (!token) {
      throw new Error('로그인이 필요합니다.');
    }
    
    const response = await fetch(
      'https://bluecrab.chickenkiller.com/BlueCrab-1.0.0/api/reservations',
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`  // JWT 토큰 포함 필수
        },
        body: JSON.stringify(reservationData)
      }
    );
    
    const data = await response.json();
    
    // HTTP 상태 코드별 처리
    if (response.status === 401) {
      // 토큰 만료 또는 인증 실패
      localStorage.removeItem('accessToken');
      window.location.href = '/login';
      throw new Error('로그인이 만료되었습니다.');
    }
    
    if (response.status === 409) {
      // 비즈니스 로직 에러 (시간 중복 등)
      throw new Error(data.message);
    }
    
    if (!response.ok) {
      throw new Error(data.message || '예약 생성에 실패했습니다.');
    }
    
    return {
      success: true,
      reservation: data.data,
      message: data.message
    };
    
  } catch (error) {
    console.error('예약 생성 실패:', error);
    return {
      success: false,
      message: error.message
    };
  }
};
```

### 8.3 파일 업로드 API

**Frontend 코드**:
```javascript
// profileAPI.jsx
export const uploadProfileImage = async (imageFile) => {
  try {
    const token = getAccessToken();
    
    // FormData 사용 (JSON이 아님!)
    const formData = new FormData();
    formData.append('file', imageFile);
    
    const response = await fetch(
      'https://bluecrab.chickenkiller.com/BlueCrab-1.0.0/api/profile/image',
      {
        method: 'POST',
        headers: {
          // Content-Type을 명시하지 않음 (브라우저가 자동으로 multipart/form-data 설정)
          'Authorization': `Bearer ${token}`
        },
        body: formData  // JSON.stringify 하지 않음!
      }
    );
    
    const data = await response.json();
    
    if (data.success) {
      return {
        success: true,
        imageUrl: data.data.imageUrl
      };
    } else {
      throw new Error(data.message);
    }
  } catch (error) {
    console.error('이미지 업로드 실패:', error);
    return {
      success: false,
      message: error.message
    };
  }
};
```

---

## 9. 디버깅 팁

### 9.1 백엔드 로그 확인하는 법

**Backend에서 로그 출력**:
```java
@Service
public class ReservationService {
    
    private static final Logger logger = LoggerFactory.getLogger(ReservationService.class);
    
    public ReservationDto createReservation(String userCode, ReservationCreateRequestDto request) {
        logger.info("예약 생성 시작 - 사용자: {}, 시설: {}", userCode, request.getFacilityId());
        
        try {
            // 비즈니스 로직...
            
            logger.info("예약 생성 완료 - 예약 ID: {}", reservation.getId());
            return dto;
        } catch (Exception e) {
            logger.error("예약 생성 실패 - 사용자: {}, 에러: {}", userCode, e.getMessage(), e);
            throw e;
        }
    }
}
```

**로그 확인 위치**: `backend/BlueCrab/logs/application.log`

### 9.2 API 테스트 도구 사용

**Postman/Insomnia로 테스트**:
```
1. URL 입력: https://bluecrab.chickenkiller.com/BlueCrab-1.0.0/api/reservations
2. Method: POST
3. Headers:
   - Content-Type: application/json
   - Authorization: Bearer eyJhbGc...
4. Body (JSON):
   {
     "facilityId": 1,
     "startTime": "2025-10-15T14:00:00",
     "endTime": "2025-10-15T16:00:00",
     "purpose": "세미나"
   }
5. Send 버튼 클릭
```

### 9.3 브라우저 개발자 도구 활용

**Network 탭에서 확인**:
- Request Headers: Authorization 토큰이 제대로 들어갔는지
- Request Payload: 요청 바디가 올바른 JSON인지
- Response: 응답 상태 코드와 데이터 확인
- Timing: 응답 시간 확인 (너무 느리면 최적화 필요)

**Console 탭에서 확인**:
```javascript
// API 응답 전체 로깅
console.log('API Response:', response);
console.log('Status Code:', response.status);
console.log('Response Data:', await response.json());
```

---

## 10. 자주 묻는 질문 (FAQ)

### Q1: API 호출 시 CORS 에러가 나요
**A**: 백엔드에서 CORS 설정을 확인해야 합니다. 현재 프로젝트는 이미 설정되어 있습니다:
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
            .allowedOrigins("http://localhost:5173", "https://your-frontend-domain.com")
            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
            .allowedHeaders("*")
            .allowCredentials(true);
    }
}
```

### Q2: 토큰이 만료되면 어떻게 하나요?
**A**: Refresh Token으로 새 Access Token을 발급받습니다:
```javascript
const refreshAccessToken = async () => {
  const refreshToken = localStorage.getItem('refreshToken');
  
  const response = await fetch('/api/auth/refresh', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ refreshToken })
  });
  
  const data = await response.json();
  
  if (data.success) {
    localStorage.setItem('accessToken', data.data.accessToken);
    return data.data.accessToken;
  } else {
    // Refresh Token도 만료됨 → 재로그인 필요
    localStorage.clear();
    window.location.href = '/login';
  }
};
```

### Q3: 파일 업로드는 어떻게 하나요?
**A**: `FormData`를 사용하고 `Content-Type`을 설정하지 않습니다:
```javascript
const formData = new FormData();
formData.append('file', fileInput.files[0]);

fetch('/api/upload', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${token}`
    // Content-Type 설정 안 함!
  },
  body: formData
});
```

### Q4: 페이징은 어떻게 처리하나요?
**A**: 요청에 `page`와 `size`를 포함하고, 응답에서 `totalPages`를 확인합니다:
```javascript
const [currentPage, setCurrentPage] = useState(0);
const [totalPages, setTotalPages] = useState(0);

const fetchList = async (page) => {
  const response = await fetch('/api/boards/list', {
    method: 'POST',
    body: JSON.stringify({ page, size: 10 })
  });
  
  const data = await response.json();
  setTotalPages(data.data.totalPages);
  return data.data.content;
};
```

### Q5: 에러 메시지를 어떻게 표시하나요?
**A**: `ApiResponse`의 `message` 필드를 사용합니다:
```javascript
try {
  const response = await createReservation(data);
  
  if (response.success) {
    alert(response.message);  // "예약이 생성되었습니다."
  } else {
    alert(`에러: ${response.message}`);
  }
} catch (error) {
  alert('네트워크 오류가 발생했습니다.');
}
```

---

## 11. 요약 및 핵심 포인트

### 🎯 백엔드 동작 핵심 3단계
1. **Controller**: HTTP 요청 받기 → DTO 변환 → Service 호출
2. **Service**: 비즈니스 로직 실행 → Repository 호출
3. **Repository**: 데이터베이스 쿼리 실행 → 결과 반환

### 🔐 인증 핵심
- JWT 토큰을 `Authorization: Bearer {token}` 헤더에 포함
- Access Token: 15분 (짧은 수명)
- Refresh Token: 7일 (긴 수명)
- 401 에러 → 로그인 페이지로 이동

### 📡 API 호출 핵심
- 모든 응답은 `ApiResponse<T>` 형식으로 통일
- `success` 필드로 성공/실패 확인
- `message` 필드로 사용자 메시지 표시
- `data` 필드에 실제 데이터 포함

### ⚠️ 에러 처리 핵심
- 400: 입력값 검증 실패 → 입력값 확인 요청
- 401: 인증 실패 → 로그인 페이지로 이동
- 409: 비즈니스 규칙 위반 → 에러 메시지 표시
- 500: 서버 오류 → "잠시 후 다시 시도" 메시지

---

## 12. 다음 단계

이 문서를 바탕으로:
1. ✅ **각 API 엔드포인트 문서 참고**: `api-documentation.md`
2. ✅ **실제 코드 구현**: 위 예제 코드 활용
3. ✅ **Postman으로 API 테스트**: 프론트 개발 전 백엔드 동작 확인
4. ✅ **에러 처리 구현**: 모든 예외 상황 대비
5. ✅ **로그 확인 습관**: 문제 발생 시 백엔드 로그 확인

---

**문서 작성자**: GitHub Copilot  
**최종 수정일**: 2025-10-10  
**관련 문서**:
- [`프론트엔드_완전_연동_가이드.md`](../프론트엔드_완전_연동_가이드.md)
- [`api-documentation.md`](./api-endpoints/api-documentation.md)
- [`backend-analysis/01-전체구조-분석.md`](./backend-analysis/01-전체구조-분석.md)
